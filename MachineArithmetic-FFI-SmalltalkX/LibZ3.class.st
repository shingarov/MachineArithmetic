"
FFI interface to libz3.so
"
Class {
	#name : #LibZ3,
	#superclass : #ExternalLibrary,
	#classVars : [
		'LibraryName',
		'UINT_PTR',
		'UniqueInstance'
	],
	#category : #'MachineArithmetic-FFI-SmalltalkX'
}

{ #category : #miscellaneous }
LibZ3 class >> getFullVersion [
	^self uniqueInstance getFullVersion

	"
	LibZ3 getFullVersion
	"

	"Modified (comment): / 12-08-2020 / 11:16:41 / Jan Vrany <jan.vrany@labware.com>"
]

{ #category : #miscellaneous }
LibZ3 class >> getVersion [
	| maj min b r version |
	maj := ExternalLong new.
	min := ExternalLong new.
	b   := ExternalLong new.
	r   := ExternalLong new.
	self uniqueInstance getVersion: maj minor: min build: b revision: r.
	version := Array
		with: maj value
		with: min value
		with: b   value
		with: r   value.
	maj free. min free. b free. r free.
	^ version
]

{ #category : #miscellaneous }
LibZ3 class >> getVersionString [
	| version |
	version := self getVersion. "Array of 4 Integers"
	^version first  printString, '.',
	 version second printString, '.',
	 version third  printString "omit rev, consistent with the Python API"
]

{ #category : #accessing }
LibZ3 class >> libraryName [

	"Just guessing here, really."
	(LibraryName isNil and:[ConfigurableFeatures includesFeature:#Tonel])   ifTrue:[
		| pkgdir |

		pkgdir := (Smalltalk at: #TonelRepository) discoverPackage: self package.
		(pkgdir notNil and: [ (LibraryName := pkgdir directory / 'z3' / 'build' / 'libz3.so') exists]) ifTrue: [
			 LibraryName := LibraryName asAbsoluteFilename pathName.
		] ifFalse:[ 
			 LibraryName := 'libz3.so'.
		].
	].
	^ LibraryName

	"
	self libraryName.
	LibraryName := nil.
	LibraryName := '/home/jv/Projects/SmalltalkX/sources/jv1_x32_lin/build/labware/machinearithmetic/z3/build/x86_64-pc-linux-gnu/libz3.so'
	"

	"Modified (comment): / 12-08-2020 / 11:14:24 / Jan Vrany <jan.vrany@labware.com>"
]

{ #category : #accessing }
LibZ3 class >> libraryName: aString [
	"Set name / path to Z3 dynamic library to use. Use this to
	 use custom Z3 library."

	LibraryName := aString
	"
	self libraryName.
	LibraryName := nil.
	LibraryName := '/home/jv/Projects/SmalltalkX/sources/jv1_x32_lin/build/labware/machinearithmetic/z3/build/x86_64-pc-linux-gnu/libz3.so'
	"

	"Created: / 12-08-2020 / 11:16:06 / Jan Vrany <jan.vrany@labware.com>"
]

{ #category : #accessing }
LibZ3 class >> uniqueInstance [
	"returns a singleton"

	UniqueInstance isNil ifTrue:[
		UniqueInstance := self basicNew initialize.
	].
	^ UniqueInstance.
]

{ #category : #'API - private' }
LibZ3 >> _add_const_interp: c _: m _: f _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_add_const_interp(Z3_context c, Z3_model m, Z3_func_decl f, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_add_const_interp ( Z3Context c, Z3Model m, Z3AST f, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _add_func_interp: c _: m _: f _: default_value [
	"
		PRIVATE - DO NOT USE!

		Z3_func_interp Z3_API Z3_add_func_interp(Z3_context c, Z3_model m, Z3_func_decl f, Z3_ast default_value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _add_rec_def: c _: f _: n _: args _: body [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_add_rec_def(Z3_context c, Z3_func_decl f, unsigned n, Z3_ast args[], Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_add_rec_def ( Z3Context c, Z3AST f, uint n, FFIExternalArray args, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_add: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_algebraic_add(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_algebraic_add ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_div: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_algebraic_div(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_algebraic_div ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_eq: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_eq(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_eq ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_eval: c _: p _: n _: a [
	"
		PRIVATE - DO NOT USE!

		int Z3_API Z3_algebraic_eval(Z3_context c, Z3_ast p, unsigned n, Z3_ast a[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_algebraic_eval ( Z3Context c, Z3AST p, uint n, FFIExternalArray a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_ge: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_ge(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_ge ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_get_i: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_algebraic_get_i(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_algebraic_get_i ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_get_poly: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_algebraic_get_poly(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_algebraic_get_poly ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_gt: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_gt(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_gt ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_is_neg: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_is_neg(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_is_neg ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_is_pos: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_is_pos(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_is_pos ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_is_value: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_is_value(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_is_value ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_is_zero: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_is_zero(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_is_zero ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_le: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_le(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_le ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_lt: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_lt(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_lt ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_mul: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_algebraic_mul(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_algebraic_mul ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_neq: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_algebraic_neq(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_algebraic_neq ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_power: c _: a _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_algebraic_power(Z3_context c, Z3_ast a, unsigned k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_algebraic_power ( Z3Context c, Z3AST a, uint k ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_root: c _: a _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_algebraic_root(Z3_context c, Z3_ast a, unsigned k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_algebraic_root ( Z3Context c, Z3AST a, uint k ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_roots: c _: p _: n _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_algebraic_roots(Z3_context c, Z3_ast p, unsigned n, Z3_ast a[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_algebraic_roots ( Z3Context c, Z3AST p, uint n, FFIExternalArray a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_sign: c _: a [
	"
		PRIVATE - DO NOT USE!

		int Z3_API Z3_algebraic_sign(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_algebraic_sign ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _algebraic_sub: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_algebraic_sub(Z3_context c, Z3_ast a, Z3_ast b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_algebraic_sub ( Z3Context c, Z3AST a, Z3AST b ) )

]

{ #category : #'API - private' }
LibZ3 >> _app_to_ast: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_app_to_ast(Z3_context c, Z3_app a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_app_to_ast ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _apply_result_dec_ref: c _: r [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_apply_result_dec_ref(Z3_context c, Z3_apply_result r);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type APPLY_RESULT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _apply_result_get_num_subgoals: c _: r [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_apply_result_get_num_subgoals(Z3_context c, Z3_apply_result r);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type APPLY_RESULT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _apply_result_get_subgoal: c _: r _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_goal Z3_API Z3_apply_result_get_subgoal(Z3_context c, Z3_apply_result r, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _apply_result_inc_ref: c _: r [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_apply_result_inc_ref(Z3_context c, Z3_apply_result r);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type APPLY_RESULT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _apply_result_to_string: c _: r [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_apply_result_to_string(Z3_context c, Z3_apply_result r);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type APPLY_RESULT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_contains: c _: m _: k [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_ast_map_contains(Z3_context c, Z3_ast_map m, Z3_ast k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_dec_ref: c _: m [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_map_dec_ref(Z3_context c, Z3_ast_map m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_erase: c _: m _: k [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_map_erase(Z3_context c, Z3_ast_map m, Z3_ast k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_find: c _: m _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_ast_map_find(Z3_context c, Z3_ast_map m, Z3_ast k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_inc_ref: c _: m [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_map_inc_ref(Z3_context c, Z3_ast_map m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_insert: c _: m _: k _: v [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_map_insert(Z3_context c, Z3_ast_map m, Z3_ast k, Z3_ast v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_keys: c _: m [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_ast_map_keys(Z3_context c, Z3_ast_map m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_reset: c _: m [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_map_reset(Z3_context c, Z3_ast_map m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_size: c _: m [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_ast_map_size(Z3_context c, Z3_ast_map m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_map_to_string: c _: m [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_ast_map_to_string(Z3_context c, Z3_ast_map m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _ast_to_string: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_ast_to_string(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_ast_to_string ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_dec_ref: c _: v [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_vector_dec_ref(Z3_context c, Z3_ast_vector v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_ast_vector_dec_ref ( Z3Context c, Z3ASTVector v ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_get: c _: v _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_ast_vector_get(Z3_context c, Z3_ast_vector v, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_ast_vector_get ( Z3Context c, Z3ASTVector v, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_inc_ref: c _: v [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_vector_inc_ref(Z3_context c, Z3_ast_vector v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_ast_vector_inc_ref ( Z3Context c, Z3ASTVector v ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_push: c _: v _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_vector_push(Z3_context c, Z3_ast_vector v, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_ast_vector_push ( Z3Context c, Z3ASTVector v, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_resize: c _: v _: n [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_vector_resize(Z3_context c, Z3_ast_vector v, unsigned n);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_ast_vector_resize ( Z3Context c, Z3ASTVector v, uint n ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_set: c _: v _: i _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_ast_vector_set(Z3_context c, Z3_ast_vector v, unsigned i, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_ast_vector_set ( Z3Context c, Z3ASTVector v, uint i, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_size: c _: v [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_ast_vector_size(Z3_context c, Z3_ast_vector v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_ast_vector_size ( Z3Context c, Z3ASTVector v ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_to_string: c _: v [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_ast_vector_to_string(Z3_context c, Z3_ast_vector v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_ast_vector_to_string ( Z3Context c, Z3ASTVector v ) )

]

{ #category : #'API - private' }
LibZ3 >> _ast_vector_translate: s _: v _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_ast_vector_translate(Z3_context s, Z3_ast_vector v, Z3_context t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_ast_vector_translate ( Z3Context s, Z3ASTVector v, Z3Context t ) )

]

{ #category : #'API - private' }
LibZ3 >> _benchmark_to_smtlib_string: c _: name _: logic _: status _: attributes _: num_assumptions _: assumptions _: formula [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_benchmark_to_smtlib_string(Z3_context c,
												   Z3_string name,
												   Z3_string logic,
												   Z3_string status,
												   Z3_string attributes,
												   unsigned num_assumptions,
												   Z3_ast const assumptions[],
												   Z3_ast formula);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_benchmark_to_smtlib_string ( Z3Context c, char * name, char * logic, char * status, char * attributes, uint num_assumptions, FFIExternalArray assumptions, Z3AST formula ) )

]

{ #category : #'API - private' }
LibZ3 >> _datatype_update_field: c _: field_access _: t _: value [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_datatype_update_field(Z3_context c, Z3_func_decl field_access,
										   Z3_ast t, Z3_ast value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_datatype_update_field ( Z3Context c, Z3AST field_access, Z3AST t, Z3AST value ) )

]

{ #category : #'API - private' }
LibZ3 >> _dec_ref: c _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_dec_ref(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_dec_ref ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _del_config: c [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_del_config(Z3_config c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_del_config ( Z3Config c ) )

]

{ #category : #'API - private' }
LibZ3 >> _del_constructor: c _: constr [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_del_constructor(Z3_context c, Z3_constructor constr);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_del_constructor ( Z3Context c, Z3Constructor constr ) )

]

{ #category : #'API - private' }
LibZ3 >> _del_constructor_list: c _: clist [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_del_constructor_list(Z3_context c, Z3_constructor_list clist);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type CONSTRUCTOR_LIST not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _del_context: c [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_del_context(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_del_context ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _disable_trace: tag [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_disable_trace(Z3_string tag);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_disable_trace ( char * tag ) )

]

{ #category : #'API - private' }
LibZ3 >> _enable_trace: tag [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_enable_trace(Z3_string tag);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_enable_trace ( char * tag ) )

]

{ #category : #'API - private' }
LibZ3 >> _eval_smtlib2_string: arg0 _: str [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_eval_smtlib2_string(Z3_context, Z3_string str);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_eval_smtlib2_string ( Z3Context arg0, char * str ) )

]

{ #category : #'API - private' }
LibZ3 >> _finalize_memory [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_finalize_memory(void);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_finalize_memory ( ) )

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_add_cover: c _: d _: level _: pred _: property [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_add_cover(Z3_context c, Z3_fixedpoint d, int level, Z3_func_decl pred, Z3_ast property);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_add_fact: c _: d _: r _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_add_fact(Z3_context c, Z3_fixedpoint d,
									   Z3_func_decl r,
									   unsigned num_args, unsigned args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_add_invariant: c _: d _: pred _: property [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_add_invariant(Z3_context c, Z3_fixedpoint d, Z3_func_decl pred, Z3_ast property);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_add_rule: c _: d _: rule _: name [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_add_rule(Z3_context c, Z3_fixedpoint d, Z3_ast rule, Z3_symbol name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_assert: c _: d _: axiom [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_assert(Z3_context c, Z3_fixedpoint d, Z3_ast axiom);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_dec_ref: c _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_dec_ref(Z3_context c, Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_from_file: c _: f _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_fixedpoint_from_file(Z3_context c,
												 Z3_fixedpoint f,
												 Z3_string s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_from_string: c _: f _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_fixedpoint_from_string(Z3_context c,
												   Z3_fixedpoint f,
												   Z3_string s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_answer: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_fixedpoint_get_answer(Z3_context c, Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_assertions: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_fixedpoint_get_assertions(
		Z3_context c,
		Z3_fixedpoint f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_cover_delta: c _: d _: level _: pred [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_fixedpoint_get_cover_delta(Z3_context c, Z3_fixedpoint d, int level, Z3_func_decl pred);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_ground_sat_answer: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_fixedpoint_get_ground_sat_answer(Z3_context c,Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_help: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_fixedpoint_get_help(Z3_context c, Z3_fixedpoint f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_num_levels: c _: d _: pred [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_fixedpoint_get_num_levels(Z3_context c, Z3_fixedpoint d, Z3_func_decl pred);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_param_descrs: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_param_descrs Z3_API Z3_fixedpoint_get_param_descrs(Z3_context c, Z3_fixedpoint f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_reachable: c _: d _: pred [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_fixedpoint_get_reachable(Z3_context c, Z3_fixedpoint d, Z3_func_decl pred);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_reason_unknown: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_fixedpoint_get_reason_unknown(Z3_context c, Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_rule_names_along_trace: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_fixedpoint_get_rule_names_along_trace(Z3_context c,Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_rules: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_fixedpoint_get_rules(
		Z3_context c,
		Z3_fixedpoint f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_rules_along_trace: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_fixedpoint_get_rules_along_trace(Z3_context c,Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_get_statistics: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_stats Z3_API Z3_fixedpoint_get_statistics(Z3_context c, Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_inc_ref: c _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_inc_ref(Z3_context c, Z3_fixedpoint d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_query: c _: d _: query [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_fixedpoint_query(Z3_context c, Z3_fixedpoint d, Z3_ast query);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_query_from_lvl: c _: d _: query _: lvl [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_fixedpoint_query_from_lvl (Z3_context c,Z3_fixedpoint d, Z3_ast query, unsigned lvl);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_query_relations: c _: d _: num_relations _: relations [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_fixedpoint_query_relations(
		Z3_context c, Z3_fixedpoint d,
		unsigned num_relations, Z3_func_decl const relations[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_register_relation: c _: d _: f [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_register_relation(Z3_context c, Z3_fixedpoint d, Z3_func_decl f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_set_params: c _: f _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_set_params(Z3_context c, Z3_fixedpoint f, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_set_predicate_representation: c _: d _: f _: num_relations _: relation_kinds [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_set_predicate_representation(
		Z3_context c,
		Z3_fixedpoint d,
		Z3_func_decl f,
		unsigned num_relations,
		Z3_symbol const relation_kinds[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_to_string: c _: f _: num_queries _: queries [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_fixedpoint_to_string(
		Z3_context c,
		Z3_fixedpoint f,
		unsigned num_queries,
		Z3_ast queries[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fixedpoint_update_rule: c _: d _: a _: name [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_fixedpoint_update_rule(Z3_context c, Z3_fixedpoint d, Z3_ast a, Z3_symbol name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_ebits: c _: s [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_fpa_get_ebits(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_fpa_get_ebits ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_exponent_bv: c _: t _: biased [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_fpa_get_numeral_exponent_bv(Z3_context c, Z3_ast t, bool biased);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_fpa_get_numeral_exponent_bv ( Z3Context c, Z3AST t, bool biased ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_exponent_int64: c _: t _: n _: biased [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_get_numeral_exponent_int64(Z3_context c, Z3_ast t, int64_t * n, bool biased);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_get_numeral_exponent_int64 ( Z3Context c, Z3AST t, int64 n, bool biased ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_exponent_string: c _: t _: biased [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_fpa_get_numeral_exponent_string(Z3_context c, Z3_ast t, bool biased);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_fpa_get_numeral_exponent_string ( Z3Context c, Z3AST t, bool biased ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_sign: c _: t _: sgn [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_get_numeral_sign(Z3_context c, Z3_ast t, int * sgn);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_get_numeral_sign ( Z3Context c, Z3AST t, int sgn ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_sign_bv: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_fpa_get_numeral_sign_bv(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_fpa_get_numeral_sign_bv ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_significand_bv: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_fpa_get_numeral_significand_bv(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_fpa_get_numeral_significand_bv ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_significand_string: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_fpa_get_numeral_significand_string(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_fpa_get_numeral_significand_string ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_numeral_significand_uint64: c _: t _: n [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_get_numeral_significand_uint64(Z3_context c, Z3_ast t, uint64_t * n);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_get_numeral_significand_uint64 ( Z3Context c, Z3AST t, uint65 n ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_get_sbits: c _: s [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_fpa_get_sbits(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_fpa_get_sbits ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_is_numeral_inf: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_is_numeral_inf(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_is_numeral_inf ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_is_numeral_nan: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_is_numeral_nan(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_is_numeral_nan ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_is_numeral_negative: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_is_numeral_negative(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_is_numeral_negative ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_is_numeral_normal: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_is_numeral_normal(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_is_numeral_normal ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_is_numeral_positive: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_is_numeral_positive(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_is_numeral_positive ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_is_numeral_subnormal: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_is_numeral_subnormal(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_is_numeral_subnormal ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _fpa_is_numeral_zero: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_fpa_is_numeral_zero(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_fpa_is_numeral_zero ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _func_decl_to_ast: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_func_decl_to_ast(Z3_context c, Z3_func_decl f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_func_decl_to_ast ( Z3Context c, Z3AST f ) )

]

{ #category : #'API - private' }
LibZ3 >> _func_decl_to_string: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_func_decl_to_string(Z3_context c, Z3_func_decl d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_func_decl_to_string ( Z3Context c, Z3AST d ) )

]

{ #category : #'API - private' }
LibZ3 >> _func_entry_dec_ref: c _: e [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_func_entry_dec_ref(Z3_context c, Z3_func_entry e);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_ENTRY not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_entry_get_arg: c _: e _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_func_entry_get_arg(Z3_context c, Z3_func_entry e, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_ENTRY not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_entry_get_num_args: c _: e [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_func_entry_get_num_args(Z3_context c, Z3_func_entry e);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_ENTRY not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_entry_get_value: c _: e [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_func_entry_get_value(Z3_context c, Z3_func_entry e);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_ENTRY not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_entry_inc_ref: c _: e [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_func_entry_inc_ref(Z3_context c, Z3_func_entry e);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_ENTRY not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_add_entry: c _: fi _: args _: value [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_func_interp_add_entry(Z3_context c, Z3_func_interp fi, Z3_ast_vector args, Z3_ast value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_dec_ref: c _: f [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_func_interp_dec_ref(Z3_context c, Z3_func_interp f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_get_arity: c _: f [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_func_interp_get_arity(Z3_context c, Z3_func_interp f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_get_else: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_func_interp_get_else(Z3_context c, Z3_func_interp f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_get_entry: c _: f _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_func_entry Z3_API Z3_func_interp_get_entry(Z3_context c, Z3_func_interp f, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_ENTRY not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_get_num_entries: c _: f [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_func_interp_get_num_entries(Z3_context c, Z3_func_interp f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_inc_ref: c _: f [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_func_interp_inc_ref(Z3_context c, Z3_func_interp f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _func_interp_set_else: c _: f _: else_value [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_func_interp_set_else(Z3_context c, Z3_func_interp f, Z3_ast else_value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_algebraic_number_lower: c _: a _: precision [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_algebraic_number_lower(Z3_context c, Z3_ast a, unsigned precision);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_algebraic_number_lower ( Z3Context c, Z3AST a, uint precision ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_algebraic_number_upper: c _: a _: precision [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_algebraic_number_upper(Z3_context c, Z3_ast a, unsigned precision);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_algebraic_number_upper ( Z3Context c, Z3AST a, uint precision ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_app_arg: c _: a _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_app_arg(Z3_context c, Z3_app a, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_app_arg ( Z3Context c, Z3AST a, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_app_decl: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_app_decl(Z3_context c, Z3_app a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_app_decl ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_app_num_args: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_app_num_args(Z3_context c, Z3_app a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_app_num_args ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_arity: c _: d [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_arity(Z3_context c, Z3_func_decl d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_arity ( Z3Context c, Z3AST d ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_array_sort_domain: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_array_sort_domain(Z3_context c, Z3_sort t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_array_sort_domain ( Z3Context c, Z3Sort t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_array_sort_range: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_array_sort_range(Z3_context c, Z3_sort t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_array_sort_range ( Z3Context c, Z3Sort t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_as_array_func_decl: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_as_array_func_decl(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_as_array_func_decl ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_ast_hash: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_ast_hash(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_ast_hash ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_ast_id: c _: t [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_ast_id(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_ast_id ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_ast_kind: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_kind Z3_API Z3_get_ast_kind(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_ast_kind ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_bool_value: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_get_bool_value(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_get_bool_value ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_bv_sort_size: c _: t [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_bv_sort_size(Z3_context c, Z3_sort t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_bv_sort_size ( Z3Context c, Z3Sort t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_datatype_sort_constructor: c _: t _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_datatype_sort_constructor(
		Z3_context c, Z3_sort t, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_datatype_sort_constructor ( Z3Context c, Z3Sort t, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_datatype_sort_constructor_accessor: c _: t _: idx_c _: idx_a [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_datatype_sort_constructor_accessor(Z3_context c,
																  Z3_sort t,
																  unsigned idx_c,
																  unsigned idx_a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_datatype_sort_constructor_accessor ( Z3Context c, Z3Sort t, uint idx_c, uint idx_a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_datatype_sort_num_constructors: c _: t [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_datatype_sort_num_constructors(
		Z3_context c, Z3_sort t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_datatype_sort_num_constructors ( Z3Context c, Z3Sort t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_datatype_sort_recognizer: c _: t _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_datatype_sort_recognizer(
		Z3_context c, Z3_sort t, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_datatype_sort_recognizer ( Z3Context c, Z3Sort t, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_ast_parameter: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_decl_ast_parameter(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_decl_ast_parameter ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_double_parameter: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		double Z3_API Z3_get_decl_double_parameter(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( double Z3_get_decl_double_parameter ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_func_decl_parameter: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_decl_func_decl_parameter(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_decl_func_decl_parameter ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_int_parameter: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		int Z3_API Z3_get_decl_int_parameter(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_get_decl_int_parameter ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_kind: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_decl_kind Z3_API Z3_get_decl_kind(Z3_context c, Z3_func_decl d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_decl_kind ( Z3Context c, Z3AST d ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_name: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_get_decl_name(Z3_context c, Z3_func_decl d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Symbol Z3_get_decl_name ( Z3Context c, Z3AST d ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_num_parameters: c _: d [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_decl_num_parameters(Z3_context c, Z3_func_decl d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_decl_num_parameters ( Z3Context c, Z3AST d ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_parameter_kind: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_parameter_kind Z3_API Z3_get_decl_parameter_kind(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_decl_parameter_kind ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_rational_parameter: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_decl_rational_parameter(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_decl_rational_parameter ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_sort_parameter: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_decl_sort_parameter(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_decl_sort_parameter ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_decl_symbol_parameter: c _: d _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_get_decl_symbol_parameter(Z3_context c, Z3_func_decl d, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Symbol Z3_get_decl_symbol_parameter ( Z3Context c, Z3AST d, uint idx ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_denominator: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_denominator(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_denominator ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_domain: c _: d _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_domain(Z3_context c, Z3_func_decl d, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_domain ( Z3Context c, Z3AST d, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_domain_size: c _: d [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_domain_size(Z3_context c, Z3_func_decl d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_domain_size ( Z3Context c, Z3AST d ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_error_code: c [
	"
		PRIVATE - DO NOT USE!

		Z3_error_code Z3_API Z3_get_error_code(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_error_code ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_error_msg: c _: err [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_error_msg(Z3_context c, Z3_error_code err);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type ERROR_CODE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_estimated_alloc_size [
	"
		PRIVATE - DO NOT USE!

		uint64_t Z3_API Z3_get_estimated_alloc_size(void);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint65 Z3_get_estimated_alloc_size ( ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_finite_domain_sort_size: c _: s _: r [
	"
		PRIVATE - DO NOT USE!

		Z3_bool_opt Z3_API Z3_get_finite_domain_sort_size(Z3_context c, Z3_sort s, uint64_t* r);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_get_finite_domain_sort_size ( Z3Context c, Z3Sort s, uint65 r ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_full_version [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_full_version(void);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_full_version ( ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_func_decl_id: c _: f [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_func_decl_id(Z3_context c, Z3_func_decl f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_func_decl_id ( Z3Context c, Z3AST f ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_implied_equalities: c _: s _: num_terms _: terms _: class_ids [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_get_implied_equalities(Z3_context c,
											  Z3_solver  s,
											  unsigned num_terms,
											  Z3_ast const terms[],
											  unsigned class_ids[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_get_implied_equalities ( Z3Context c, Z3Solver s, uint num_terms, FFIExternalArray terms, FFIExternalArray class_ids ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_index_value: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_index_value(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_index_value ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_lstring: c _: s _: length [
	"
		PRIVATE - DO NOT USE!

		Z3_char_ptr Z3_API Z3_get_lstring(Z3_context c, Z3_ast s, unsigned* length);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_lstring ( Z3Context c, Z3AST s, uint length ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_num_probes: c [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_num_probes(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_num_probes ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_num_tactics: c [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_num_tactics(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_num_tactics ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_binary_string: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_numeral_binary_string(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_numeral_binary_string ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_decimal_string: c _: a _: precision [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_numeral_decimal_string(Z3_context c, Z3_ast a, unsigned precision);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_numeral_decimal_string ( Z3Context c, Z3AST a, uint precision ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_double: c _: a [
	"
		PRIVATE - DO NOT USE!

		double Z3_API Z3_get_numeral_double(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( double Z3_get_numeral_double ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_int64: c _: v _: i [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_get_numeral_int64(Z3_context c, Z3_ast v, int64_t* i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_get_numeral_int64 ( Z3Context c, Z3AST v, int64 i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_int: c _: v _: i [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_get_numeral_int(Z3_context c, Z3_ast v, int* i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_get_numeral_int ( Z3Context c, Z3AST v, int i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_rational_int64: c _: v _: num _: den [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_get_numeral_rational_int64(Z3_context c, Z3_ast v, int64_t* num, int64_t* den);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_get_numeral_rational_int64 ( Z3Context c, Z3AST v, int64 num, int64 den ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_small: c _: a _: num _: den [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_get_numeral_small(Z3_context c, Z3_ast a, int64_t* num, int64_t* den);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_get_numeral_small ( Z3Context c, Z3AST a, int64 num, int64 den ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_string: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_numeral_string(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_numeral_string ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_uint64: c _: v _: u [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_get_numeral_uint64(Z3_context c, Z3_ast v, uint64_t* u);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_get_numeral_uint64 ( Z3Context c, Z3AST v, uint65 u ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numeral_uint: c _: v _: u [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_get_numeral_uint(Z3_context c, Z3_ast v, unsigned* u);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_get_numeral_uint ( Z3Context c, Z3AST v, uint u ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_numerator: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_numerator(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_numerator ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_pattern: c _: p _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_pattern(Z3_context c, Z3_pattern p, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PATTERN not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_pattern_num_terms: c _: p [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_pattern_num_terms(Z3_context c, Z3_pattern p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PATTERN not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_probe_name: c _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_probe_name(Z3_context c, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_probe_name ( Z3Context c, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_body: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_quantifier_body(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_quantifier_body ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_bound_name: c _: a _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_get_quantifier_bound_name(Z3_context c, Z3_ast a, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_bound_sort: c _: a _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_quantifier_bound_sort(Z3_context c, Z3_ast a, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_quantifier_bound_sort ( Z3Context c, Z3AST a, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_no_pattern_ast: c _: a _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_get_quantifier_no_pattern_ast(Z3_context c, Z3_ast a, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_quantifier_no_pattern_ast ( Z3Context c, Z3AST a, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_num_bound: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_quantifier_num_bound(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_quantifier_num_bound ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_num_no_patterns: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_quantifier_num_no_patterns(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_quantifier_num_no_patterns ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_num_patterns: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_quantifier_num_patterns(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_quantifier_num_patterns ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_pattern_ast: c _: a _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_pattern Z3_API Z3_get_quantifier_pattern_ast(Z3_context c, Z3_ast a, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PATTERN not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_quantifier_weight: c _: a [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_quantifier_weight(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_quantifier_weight ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_range: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_range(Z3_context c, Z3_func_decl d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_range ( Z3Context c, Z3AST d ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_re_sort_basis: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_re_sort_basis(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_re_sort_basis ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_relation_arity: c _: s [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_relation_arity(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_relation_arity ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_relation_column: c _: s _: col [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_relation_column(Z3_context c, Z3_sort s, unsigned col);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_relation_column ( Z3Context c, Z3Sort s, uint col ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_seq_sort_basis: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_seq_sort_basis(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_seq_sort_basis ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_sort: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_get_sort(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_get_sort ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_sort_id: c _: s [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_sort_id(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_sort_id ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_sort_kind: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_sort_kind Z3_API Z3_get_sort_kind(Z3_context c, Z3_sort t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_sort_kind ( Z3Context c, Z3Sort t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_sort_name: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_get_sort_name(Z3_context c, Z3_sort d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_string: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_string(Z3_context c, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_string ( Z3Context c, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_symbol_int: c _: s [
	"
		PRIVATE - DO NOT USE!

		int Z3_API Z3_get_symbol_int(Z3_context c, Z3_symbol s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_symbol_kind: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol_kind Z3_API Z3_get_symbol_kind(Z3_context c, Z3_symbol s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_symbol_string: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_symbol_string(Z3_context c, Z3_symbol s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _get_tactic_name: c _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_get_tactic_name(Z3_context c, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_get_tactic_name ( Z3Context c, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_tuple_sort_field_decl: c _: t _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_tuple_sort_field_decl(Z3_context c, Z3_sort t, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_tuple_sort_field_decl ( Z3Context c, Z3Sort t, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_tuple_sort_mk_decl: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_get_tuple_sort_mk_decl(Z3_context c, Z3_sort t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_get_tuple_sort_mk_decl ( Z3Context c, Z3Sort t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_tuple_sort_num_fields: c _: t [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_get_tuple_sort_num_fields(Z3_context c, Z3_sort t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_get_tuple_sort_num_fields ( Z3Context c, Z3Sort t ) )

]

{ #category : #'API - private' }
LibZ3 >> _get_version: major _: minor _: build_number _: revision_number [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_get_version(unsigned * major, unsigned * minor, unsigned * build_number, unsigned * revision_number);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_get_version ( uint major, uint minor, uint build_number, uint revision_number ) )

]

{ #category : #'API - private' }
LibZ3 >> _global_param_get: param_id _: param_value [
	"
		PRIVATE - DO NOT USE!

		Z3_bool_opt Z3_API Z3_global_param_get(Z3_string param_id, Z3_string_ptr param_value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_global_param_get ( char * param_id, char * param_value ) )

]

{ #category : #'API - private' }
LibZ3 >> _global_param_reset_all [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_global_param_reset_all(void);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_global_param_reset_all ( ) )

]

{ #category : #'API - private' }
LibZ3 >> _global_param_set: param_id _: param_value [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_global_param_set(Z3_string param_id, Z3_string param_value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_global_param_set ( char * param_id, char * param_value ) )

]

{ #category : #'API - private' }
LibZ3 >> _goal_assert: c _: g _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_goal_assert(Z3_context c, Z3_goal g, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_convert_model: c _: g _: m [
	"
		PRIVATE - DO NOT USE!

		Z3_model Z3_API Z3_goal_convert_model(Z3_context c, Z3_goal g, Z3_model m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_dec_ref: c _: g [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_goal_dec_ref(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_depth: c _: g [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_goal_depth(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_formula: c _: g _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_goal_formula(Z3_context c, Z3_goal g, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_inc_ref: c _: g [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_goal_inc_ref(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_inconsistent: c _: g [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_goal_inconsistent(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_is_decided_sat: c _: g [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_goal_is_decided_sat(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_is_decided_unsat: c _: g [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_goal_is_decided_unsat(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_num_exprs: c _: g [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_goal_num_exprs(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_precision: c _: g [
	"
		PRIVATE - DO NOT USE!

		Z3_goal_prec Z3_API Z3_goal_precision(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_reset: c _: g [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_goal_reset(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_size: c _: g [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_goal_size(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_to_dimacs_string: c _: g _: include_names [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_goal_to_dimacs_string(Z3_context c, Z3_goal g, bool include_names);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_to_string: c _: g [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_goal_to_string(Z3_context c, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _goal_translate: source _: g _: target [
	"
		PRIVATE - DO NOT USE!

		Z3_goal Z3_API Z3_goal_translate(Z3_context source, Z3_goal g, Z3_context target);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _inc_ref: c _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_inc_ref(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_inc_ref ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _interrupt: c [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_interrupt(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_interrupt ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_algebraic_number: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_algebraic_number(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_algebraic_number ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_app: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_app(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_app ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_as_array: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_as_array(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_as_array ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_eq_ast: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_eq_ast(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_eq_ast ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_eq_func_decl: c _: f1 _: f2 [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_eq_func_decl(Z3_context c, Z3_func_decl f1, Z3_func_decl f2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_eq_func_decl ( Z3Context c, Z3AST f1, Z3AST f2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_eq_sort: c _: s1 _: s2 [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_eq_sort(Z3_context c, Z3_sort s1, Z3_sort s2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_eq_sort ( Z3Context c, Z3Sort s1, Z3Sort s2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_lambda: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_lambda(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_lambda ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_numeral_ast: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_numeral_ast(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_numeral_ast ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_quantifier_exists: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_quantifier_exists(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_quantifier_exists ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_quantifier_forall: c _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_quantifier_forall(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_quantifier_forall ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_re_sort: c _: s [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_re_sort(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_re_sort ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_seq_sort: c _: s [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_seq_sort(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_seq_sort ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_string: c _: s [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_string(Z3_context c, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_string ( Z3Context c, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_string_sort: c _: s [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_string_sort(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_string_sort ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _is_well_sorted: c _: t [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_is_well_sorted(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_is_well_sorted ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_add: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_add(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_add ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_and: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_and(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_and ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_app: c _: d _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_app(
		Z3_context c,
		Z3_func_decl d,
		unsigned num_args,
		Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_app ( Z3Context c, Z3AST d, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_array_default: c _: array [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_array_default(Z3_context c, Z3_ast array);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_array_default ( Z3Context c, Z3AST array ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_array_ext: c _: arg1 _: arg2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_array_ext(Z3_context c, Z3_ast arg1, Z3_ast arg2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_array_ext ( Z3Context c, Z3AST arg1, Z3AST arg2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_array_sort: c _: domain _: range [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_array_sort(Z3_context c, Z3_sort domain, Z3_sort range);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_array_sort ( Z3Context c, Z3Sort domain, Z3Sort range ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_array_sort_n: c _: n _: domain _: range [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_array_sort_n(Z3_context c, unsigned n, Z3_sort const * domain, Z3_sort range);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_array_sort_n ( Z3Context c, uint n, FFIExternalArray domain, Z3Sort range ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_as_array: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_as_array(Z3_context c, Z3_func_decl f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_as_array ( Z3Context c, Z3AST f ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_ast_map: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_map Z3_API Z3_mk_ast_map(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_ast_vector: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_mk_ast_vector(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_mk_ast_vector ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_atleast: c _: num_args _: args _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_atleast(Z3_context c, unsigned num_args,
								Z3_ast const args[], unsigned k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_atleast ( Z3Context c, uint num_args, FFIExternalArray args, uint k ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_atmost: c _: num_args _: args _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_atmost(Z3_context c, unsigned num_args,
							   Z3_ast const args[], unsigned k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_atmost ( Z3Context c, uint num_args, FFIExternalArray args, uint k ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bool_sort: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_bool_sort(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_bool_sort ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bound: c _: index _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bound(Z3_context c, unsigned index, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bound ( Z3Context c, uint index, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bv2int: c _: t1 _: is_signed [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bv2int(Z3_context c,Z3_ast t1, bool is_signed);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bv2int ( Z3Context c, Z3AST t1, bool is_signed ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bv_numeral: c _: sz _: bits [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bv_numeral(Z3_context c, unsigned sz, bool const* bits);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bv_numeral ( Z3Context c, uint sz, FFIExternalArray bits ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bv_sort: c _: sz [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_bv_sort(Z3_context c, unsigned sz);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_bv_sort ( Z3Context c, uint sz ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvadd: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvadd(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvadd ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvadd_no_overflow: c _: t1 _: t2 _: is_signed [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvadd_no_overflow(Z3_context c, Z3_ast t1, Z3_ast t2, bool is_signed);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvadd_no_overflow ( Z3Context c, Z3AST t1, Z3AST t2, bool is_signed ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvadd_no_underflow: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvadd_no_underflow(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvadd_no_underflow ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvand: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvand(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvand ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvashr: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvashr(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvashr ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvlshr: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvlshr(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvlshr ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvmul: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvmul(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvmul ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvmul_no_overflow: c _: t1 _: t2 _: is_signed [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvmul_no_overflow(Z3_context c, Z3_ast t1, Z3_ast t2, bool is_signed);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvmul_no_overflow ( Z3Context c, Z3AST t1, Z3AST t2, bool is_signed ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvmul_no_underflow: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvmul_no_underflow(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvmul_no_underflow ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvnand: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvnand(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvnand ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvneg: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvneg(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvneg ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvneg_no_overflow: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvneg_no_overflow(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvneg_no_overflow ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvnor: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvnor(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvnor ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvnot: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvnot(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvnot ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvor: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvor(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvor ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvredand: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvredand(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvredand ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvredor: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvredor(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvredor ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsdiv: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsdiv(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsdiv ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsdiv_no_overflow: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsdiv_no_overflow(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsdiv_no_overflow ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsge: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsge(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsge ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsgt: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsgt(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsgt ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvshl: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvshl(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvshl ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsle: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsle(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsle ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvslt: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvslt(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvslt ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsmod: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsmod(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsmod ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsrem: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsrem(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsrem ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsub: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsub(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsub ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsub_no_overflow: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsub_no_overflow(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsub_no_overflow ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvsub_no_underflow: c _: t1 _: t2 _: is_signed [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvsub_no_underflow(Z3_context c, Z3_ast t1, Z3_ast t2, bool is_signed);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvsub_no_underflow ( Z3Context c, Z3AST t1, Z3AST t2, bool is_signed ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvudiv: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvudiv(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvudiv ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvuge: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvuge(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvuge ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvugt: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvugt(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvugt ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvule: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvule(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvule ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvult: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvult(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvult ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvurem: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvurem(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvurem ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvxnor: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvxnor(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvxnor ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_bvxor: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_bvxor(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_bvxor ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_concat: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_concat(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_concat ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_config [
	"
		PRIVATE - DO NOT USE!

		Z3_config Z3_API Z3_mk_config(void);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Config Z3_mk_config ( ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_const: c _: s _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_const(Z3_context c, Z3_symbol s, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_const_array: c _: domain _: v [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_const_array(Z3_context c, Z3_sort domain, Z3_ast v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_const_array ( Z3Context c, Z3Sort domain, Z3AST v ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_constructor: c _: name _: recognizer _: num_fields _: field_names _: sorts _: sort_refs [
	"
		PRIVATE - DO NOT USE!

		Z3_constructor Z3_API Z3_mk_constructor(Z3_context c,
											Z3_symbol name,
											Z3_symbol recognizer,
											unsigned num_fields,
											Z3_symbol const field_names[],
											Z3_sort_opt const sorts[],
											unsigned sort_refs[]
											);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_constructor_list: c _: num_constructors _: constructors [
	"
		PRIVATE - DO NOT USE!

		Z3_constructor_list Z3_API Z3_mk_constructor_list(Z3_context c,
													  unsigned num_constructors,
													  Z3_constructor const constructors[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type CONSTRUCTOR_LIST not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_context: c [
	"
		PRIVATE - DO NOT USE!

		Z3_context Z3_API Z3_mk_context(Z3_config c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Context Z3_mk_context ( Z3Config c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_context_rc: c [
	"
		PRIVATE - DO NOT USE!

		Z3_context Z3_API Z3_mk_context_rc(Z3_config c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Context Z3_mk_context_rc ( Z3Config c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_datatype: c _: name _: num_constructors _: constructors [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_datatype(Z3_context c,
								  Z3_symbol name,
								  unsigned num_constructors,
								  Z3_constructor constructors[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_datatypes: c _: num_sorts _: sort_names _: sorts _: constructor_lists [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_mk_datatypes(Z3_context c,
								unsigned num_sorts,
								Z3_symbol const sort_names[],
								Z3_sort sorts[],
								Z3_constructor_list constructor_lists[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_mk_datatypes ( Z3Context c, uint num_sorts, FFIExternalArray sort_names, FFIExternalArray sorts, FFIExternalArray constructor_lists ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_distinct: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_distinct(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_distinct ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_div: c _: arg1 _: arg2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_div(Z3_context c, Z3_ast arg1, Z3_ast arg2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_div ( Z3Context c, Z3AST arg1, Z3AST arg2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_divides: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_divides(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_divides ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_empty_set: c _: domain [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_empty_set(Z3_context c, Z3_sort domain);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_empty_set ( Z3Context c, Z3Sort domain ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_enumeration_sort: c _: name _: n _: enum_names _: enum_consts _: enum_testers [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_enumeration_sort(Z3_context c,
										  Z3_symbol name,
										  unsigned n,
										  Z3_symbol  const enum_names[],
										  Z3_func_decl enum_consts[],
										  Z3_func_decl enum_testers[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_eq: c _: l _: r [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_eq(Z3_context c, Z3_ast l, Z3_ast r);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_eq ( Z3Context c, Z3AST l, Z3AST r ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_exists: c _: weight _: num_patterns _: patterns _: num_decls _: sorts _: decl_names _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_exists(Z3_context c, unsigned weight,
							   unsigned num_patterns, Z3_pattern const patterns[],
							   unsigned num_decls, Z3_sort const sorts[],
							   Z3_symbol const decl_names[],
							   Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_exists ( Z3Context c, uint weight, uint num_patterns, FFIExternalArray patterns, uint num_decls, FFIExternalArray sorts, FFIExternalArray decl_names, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_exists_const: c _: weight _: num_bound _: bound _: num_patterns _: patterns _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_exists_const(
		Z3_context c,
		unsigned weight,
		unsigned num_bound,
		Z3_app const bound[],
		unsigned num_patterns,
		Z3_pattern const patterns[],
		Z3_ast body
		);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_exists_const ( Z3Context c, uint weight, uint num_bound, FFIExternalArray bound, uint num_patterns, FFIExternalArray patterns, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_ext_rotate_left: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_ext_rotate_left(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_ext_rotate_left ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_ext_rotate_right: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_ext_rotate_right(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_ext_rotate_right ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_extract: c _: high _: low _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_extract(Z3_context c, unsigned high, unsigned low, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_extract ( Z3Context c, uint high, uint low, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_false: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_false(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_false ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_finite_domain_sort: c _: name _: size [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_finite_domain_sort(Z3_context c, Z3_symbol name, uint64_t size);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_fixedpoint: c [
	"
		PRIVATE - DO NOT USE!

		Z3_fixedpoint Z3_API Z3_mk_fixedpoint(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FIXEDPOINT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_forall: c _: weight _: num_patterns _: patterns _: num_decls _: sorts _: decl_names _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_forall(Z3_context c, unsigned weight,
							   unsigned num_patterns, Z3_pattern const patterns[],
							   unsigned num_decls, Z3_sort const sorts[],
							   Z3_symbol const decl_names[],
							   Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_forall ( Z3Context c, uint weight, uint num_patterns, FFIExternalArray patterns, uint num_decls, FFIExternalArray sorts, FFIExternalArray decl_names, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_forall_const: c _: weight _: num_bound _: bound _: num_patterns _: patterns _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_forall_const(
		Z3_context c,
		unsigned weight,
		unsigned num_bound,
		Z3_app const bound[],
		unsigned num_patterns,
		Z3_pattern const patterns[],
		Z3_ast body
		);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_forall_const ( Z3Context c, uint weight, uint num_bound, FFIExternalArray bound, uint num_patterns, FFIExternalArray patterns, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_abs: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_abs(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_abs ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_add: c _: rm _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_add(Z3_context c, Z3_ast rm, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_add ( Z3Context c, Z3AST rm, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_div: c _: rm _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_div(Z3_context c, Z3_ast rm, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_div ( Z3Context c, Z3AST rm, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_eq: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_eq(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_eq ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_fma: c _: rm _: t1 _: t2 _: t3 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_fma(Z3_context c, Z3_ast rm, Z3_ast t1, Z3_ast t2, Z3_ast t3);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_fma ( Z3Context c, Z3AST rm, Z3AST t1, Z3AST t2, Z3AST t3 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_fp: c _: sgn _: exp _: sig [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_fp(Z3_context c, Z3_ast sgn, Z3_ast exp, Z3_ast sig);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_fp ( Z3Context c, Z3AST sgn, Z3AST exp, Z3AST sig ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_geq: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_geq(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_geq ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_gt: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_gt(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_gt ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_inf: c _: s _: negative [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_inf(Z3_context c, Z3_sort s, bool negative);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_inf ( Z3Context c, Z3Sort s, bool negative ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_is_infinite: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_is_infinite(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_is_infinite ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_is_nan: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_is_nan(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_is_nan ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_is_negative: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_is_negative(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_is_negative ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_is_normal: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_is_normal(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_is_normal ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_is_positive: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_is_positive(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_is_positive ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_is_subnormal: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_is_subnormal(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_is_subnormal ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_is_zero: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_is_zero(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_is_zero ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_leq: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_leq(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_leq ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_lt: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_lt(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_lt ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_max: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_max(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_max ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_min: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_min(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_min ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_mul: c _: rm _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_mul(Z3_context c, Z3_ast rm, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_mul ( Z3Context c, Z3AST rm, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_nan: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_nan(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_nan ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_neg: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_neg(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_neg ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_numeral_double: c _: v _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_numeral_double(Z3_context c, double v, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_numeral_double ( Z3Context c, double v, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_numeral_float: c _: v _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_numeral_float(Z3_context c, float v, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_numeral_float ( Z3Context c, float v, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_numeral_int64_uint64: c _: sgn _: exp _: sig _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_numeral_int64_uint64(Z3_context c, bool sgn, int64_t exp, uint64_t sig, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_numeral_int64_uint64 ( Z3Context c, bool sgn, int64 exp, uint65 sig, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_numeral_int: c _: v _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_numeral_int(Z3_context c, signed v, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_numeral_int ( Z3Context c, int v, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_numeral_int_uint: c _: sgn _: exp _: sig _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_numeral_int_uint(Z3_context c, bool sgn, signed exp, unsigned sig, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_numeral_int_uint ( Z3Context c, bool sgn, int exp, uint sig, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_rem: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_rem(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_rem ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_rna: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_rna(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_rna ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_rne: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_rne(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_rne ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_round_nearest_ties_to_away: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_round_nearest_ties_to_away(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_round_nearest_ties_to_away ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_round_nearest_ties_to_even: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_round_nearest_ties_to_even(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_round_nearest_ties_to_even ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_round_to_integral: c _: rm _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_round_to_integral(Z3_context c, Z3_ast rm, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_round_to_integral ( Z3Context c, Z3AST rm, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_round_toward_negative: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_round_toward_negative(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_round_toward_negative ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_round_toward_positive: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_round_toward_positive(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_round_toward_positive ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_round_toward_zero: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_round_toward_zero(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_round_toward_zero ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_rounding_mode_sort: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_rounding_mode_sort(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_rounding_mode_sort ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_rtn: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_rtn(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_rtn ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_rtp: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_rtp(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_rtp ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_rtz: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_rtz(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_rtz ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort: c _: ebits _: sbits [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort(Z3_context c, unsigned ebits, unsigned sbits);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort ( Z3Context c, uint ebits, uint sbits ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_128: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_128(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_128 ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_16: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_16(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_16 ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_32: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_32(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_32 ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_64: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_64(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_64 ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_double: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_double(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_double ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_half: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_half(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_half ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_quadruple: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_quadruple(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_quadruple ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sort_single: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_fpa_sort_single(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_fpa_sort_single ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sqrt: c _: rm _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_sqrt(Z3_context c, Z3_ast rm, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_sqrt ( Z3Context c, Z3AST rm, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_sub: c _: rm _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_sub(Z3_context c, Z3_ast rm, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_sub ( Z3Context c, Z3AST rm, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_fp_bv: c _: bv _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_fp_bv(Z3_context c, Z3_ast bv, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_fp_bv ( Z3Context c, Z3AST bv, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_fp_float: c _: rm _: t _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_fp_float(Z3_context c, Z3_ast rm, Z3_ast t, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_fp_float ( Z3Context c, Z3AST rm, Z3AST t, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_fp_int_real: c _: rm _: exp _: sig _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_fp_int_real(Z3_context c, Z3_ast rm, Z3_ast exp, Z3_ast sig, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_fp_int_real ( Z3Context c, Z3AST rm, Z3AST exp, Z3AST sig, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_fp_real: c _: rm _: t _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_fp_real(Z3_context c, Z3_ast rm, Z3_ast t, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_fp_real ( Z3Context c, Z3AST rm, Z3AST t, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_fp_signed: c _: rm _: t _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_fp_signed(Z3_context c, Z3_ast rm, Z3_ast t, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_fp_signed ( Z3Context c, Z3AST rm, Z3AST t, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_fp_unsigned: c _: rm _: t _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_fp_unsigned(Z3_context c, Z3_ast rm, Z3_ast t, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_fp_unsigned ( Z3Context c, Z3AST rm, Z3AST t, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_ieee_bv: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_ieee_bv(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_ieee_bv ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_real: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_real(Z3_context c, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_real ( Z3Context c, Z3AST t ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_sbv: c _: rm _: t _: sz [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_sbv(Z3_context c, Z3_ast rm, Z3_ast t, unsigned sz);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_sbv ( Z3Context c, Z3AST rm, Z3AST t, uint sz ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_to_ubv: c _: rm _: t _: sz [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_to_ubv(Z3_context c, Z3_ast rm, Z3_ast t, unsigned sz);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_to_ubv ( Z3Context c, Z3AST rm, Z3AST t, uint sz ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fpa_zero: c _: s _: negative [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fpa_zero(Z3_context c, Z3_sort s, bool negative);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fpa_zero ( Z3Context c, Z3Sort s, bool negative ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fresh_const: c _: prefix _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_fresh_const(Z3_context c, Z3_string prefix, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fresh_const ( Z3Context c, char * prefix, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_fresh_func_decl: c _: prefix _: domain_size _: domain _: range [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_fresh_func_decl(Z3_context c, Z3_string prefix,
												   unsigned domain_size, Z3_sort const domain[],
												   Z3_sort range);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_fresh_func_decl ( Z3Context c, char * prefix, uint domain_size, FFIExternalArray domain, Z3Sort range ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_full_set: c _: domain [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_full_set(Z3_context c, Z3_sort domain);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_full_set ( Z3Context c, Z3Sort domain ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_func_decl: c _: s _: domain_size _: domain _: range [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_func_decl(Z3_context c, Z3_symbol s,
										unsigned domain_size, Z3_sort const domain[],
										Z3_sort range);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_func_decl ( Z3Context c, Z3Symbol s, uint domain_size, FFIExternalArray domain, Z3Sort range ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_ge: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_ge(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_ge ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_goal: c _: models _: unsat_cores _: proofs [
	"
		PRIVATE - DO NOT USE!

		Z3_goal Z3_API Z3_mk_goal(Z3_context c, bool models, bool unsat_cores, bool proofs);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type GOAL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_gt: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_gt(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_gt ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_iff: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_iff(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_iff ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_implies: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_implies(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_implies ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_int2bv: c _: n _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_int2bv(Z3_context c, unsigned n, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_int2bv ( Z3Context c, uint n, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_int2real: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_int2real(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_int2real ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_int64: c _: v _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_int64(Z3_context c, int64_t v, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_int64 ( Z3Context c, int64 v, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_int: c _: v _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_int(Z3_context c, int v, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_int ( Z3Context c, int v, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_int_sort: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_int_sort(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_int_sort ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_int_symbol: c _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_mk_int_symbol(Z3_context c, int i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_int_to_str: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_int_to_str(Z3_context c, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_int_to_str ( Z3Context c, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_is_int: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_is_int(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_is_int ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_ite: c _: t1 _: t2 _: t3 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_ite(Z3_context c, Z3_ast t1, Z3_ast t2, Z3_ast t3);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_ite ( Z3Context c, Z3AST t1, Z3AST t2, Z3AST t3 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_lambda: c _: num_decls _: sorts _: decl_names _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_lambda(Z3_context c, 
							   unsigned num_decls, Z3_sort const sorts[],
							   Z3_symbol const decl_names[],
							   Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_lambda ( Z3Context c, uint num_decls, FFIExternalArray sorts, FFIExternalArray decl_names, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_lambda_const: c _: num_bound _: bound _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_lambda_const(Z3_context c, 
									 unsigned num_bound, Z3_app const bound[],
									 Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_lambda_const ( Z3Context c, uint num_bound, FFIExternalArray bound, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_le: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_le(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_le ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_linear_order: c _: a _: id [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_linear_order(Z3_context c, Z3_sort a, unsigned id);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_linear_order ( Z3Context c, Z3Sort a, uint id ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_list_sort: c _: name _: elem_sort _: nil_decl _: is_nil_decl _: cons_decl _: is_cons_decl _: head_decl _: tail_decl [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_list_sort(Z3_context c,
								   Z3_symbol name,
								   Z3_sort   elem_sort,
								   Z3_func_decl* nil_decl,
								   Z3_func_decl* is_nil_decl,
								   Z3_func_decl* cons_decl,
								   Z3_func_decl* is_cons_decl,
								   Z3_func_decl* head_decl,
								   Z3_func_decl* tail_decl
								   );

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_list_sort ( Z3Context c, Z3Symbol name, Z3Sort elem_sort, Z3AST nil_decl, Z3AST is_nil_decl, Z3AST cons_decl, Z3AST is_cons_decl, Z3AST head_decl, Z3AST tail_decl ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_lstring: c _: len _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_lstring(Z3_context c, unsigned len, Z3_string s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_lstring ( Z3Context c, uint len, char * s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_lt: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_lt(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_lt ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_map: c _: f _: n _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_map(Z3_context c, Z3_func_decl f, unsigned n, Z3_ast const* args);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_map ( Z3Context c, Z3AST f, uint n, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_mod: c _: arg1 _: arg2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_mod(Z3_context c, Z3_ast arg1, Z3_ast arg2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_mod ( Z3Context c, Z3AST arg1, Z3AST arg2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_model: c [
	"
		PRIVATE - DO NOT USE!

		Z3_model Z3_API Z3_mk_model(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Model Z3_mk_model ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_mul: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_mul(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_mul ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_not: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_not(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_not ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_numeral: c _: numeral _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_numeral(Z3_context c, Z3_string numeral, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_numeral ( Z3Context c, char * numeral, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_optimize: c [
	"
		PRIVATE - DO NOT USE!

		Z3_optimize Z3_API Z3_mk_optimize(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_or: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_or(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_or ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_params: c [
	"
		PRIVATE - DO NOT USE!

		Z3_params Z3_API Z3_mk_params(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_partial_order: c _: a _: id [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_partial_order(Z3_context c, Z3_sort a, unsigned id);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_partial_order ( Z3Context c, Z3Sort a, uint id ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_pattern: c _: num_patterns _: terms [
	"
		PRIVATE - DO NOT USE!

		Z3_pattern Z3_API Z3_mk_pattern(Z3_context c, unsigned num_patterns, Z3_ast const terms[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PATTERN not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_pbeq: c _: num_args _: args _: coeffs _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_pbeq(Z3_context c, unsigned num_args,
							 Z3_ast const args[], int const coeffs[],
							 int k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_pbeq ( Z3Context c, uint num_args, FFIExternalArray args, FFIExternalArray coeffs, int k ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_pbge: c _: num_args _: args _: coeffs _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_pbge(Z3_context c, unsigned num_args,
							 Z3_ast const args[], int const coeffs[],
							 int k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_pbge ( Z3Context c, uint num_args, FFIExternalArray args, FFIExternalArray coeffs, int k ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_pble: c _: num_args _: args _: coeffs _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_pble(Z3_context c, unsigned num_args,
							 Z3_ast const args[], int const coeffs[],
							 int k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_pble ( Z3Context c, uint num_args, FFIExternalArray args, FFIExternalArray coeffs, int k ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_piecewise_linear_order: c _: a _: id [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_piecewise_linear_order(Z3_context c, Z3_sort a, unsigned id);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_piecewise_linear_order ( Z3Context c, Z3Sort a, uint id ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_power: c _: arg1 _: arg2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_power(Z3_context c, Z3_ast arg1, Z3_ast arg2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_power ( Z3Context c, Z3AST arg1, Z3AST arg2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_probe: c _: name [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_mk_probe(Z3_context c, Z3_string name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_quantifier: c _: is_forall _: weight _: num_patterns _: patterns _: num_decls _: sorts _: decl_names _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_quantifier(
		Z3_context c,
		bool is_forall,
		unsigned weight,
		unsigned num_patterns, Z3_pattern const patterns[],
		unsigned num_decls, Z3_sort const sorts[],
		Z3_symbol const decl_names[],
		Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_quantifier ( Z3Context c, bool is_forall, uint weight, uint num_patterns, FFIExternalArray patterns, uint num_decls, FFIExternalArray sorts, FFIExternalArray decl_names, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_quantifier_const: c _: is_forall _: weight _: num_bound _: bound _: num_patterns _: patterns _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_quantifier_const(
		Z3_context c,
		bool is_forall,
		unsigned weight,
		unsigned num_bound,  Z3_app const bound[],
		unsigned num_patterns, Z3_pattern const patterns[],
		Z3_ast body
		);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_quantifier_const ( Z3Context c, bool is_forall, uint weight, uint num_bound, FFIExternalArray bound, uint num_patterns, FFIExternalArray patterns, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_quantifier_const_ex: c _: is_forall _: weight _: quantifier_id _: skolem_id _: num_bound _: bound _: num_patterns _: patterns _: num_no_patterns _: no_patterns _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_quantifier_const_ex(
		Z3_context c,
		bool is_forall,
		unsigned weight,
		Z3_symbol quantifier_id,
		Z3_symbol skolem_id,
		unsigned num_bound,  Z3_app const bound[],
		unsigned num_patterns, Z3_pattern const patterns[],
		unsigned num_no_patterns, Z3_ast const no_patterns[],
		Z3_ast body
		);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_quantifier_ex: c _: is_forall _: weight _: quantifier_id _: skolem_id _: num_patterns _: patterns _: num_no_patterns _: no_patterns _: num_decls _: sorts _: decl_names _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_quantifier_ex(
		Z3_context c,
		bool is_forall,
		unsigned weight,
		Z3_symbol quantifier_id,
		Z3_symbol skolem_id,
		unsigned num_patterns, Z3_pattern const patterns[],
		unsigned num_no_patterns, Z3_ast const no_patterns[],
		unsigned num_decls, Z3_sort const sorts[],
		Z3_symbol const decl_names[],
		Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_complement: c _: re [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_complement(Z3_context c, Z3_ast re);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_complement ( Z3Context c, Z3AST re ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_concat: c _: n _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_concat(Z3_context c, unsigned n, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_concat ( Z3Context c, uint n, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_empty: c _: re [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_empty(Z3_context c, Z3_sort re);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_empty ( Z3Context c, Z3Sort re ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_full: c _: re [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_full(Z3_context c, Z3_sort re);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_full ( Z3Context c, Z3Sort re ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_intersect: c _: n _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_intersect(Z3_context c, unsigned n, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_intersect ( Z3Context c, uint n, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_loop: c _: r _: lo _: hi [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_loop(Z3_context c, Z3_ast r, unsigned lo, unsigned hi);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_loop ( Z3Context c, Z3AST r, uint lo, uint hi ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_option: c _: re [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_option(Z3_context c, Z3_ast re);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_option ( Z3Context c, Z3AST re ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_plus: c _: re [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_plus(Z3_context c, Z3_ast re);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_plus ( Z3Context c, Z3AST re ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_range: c _: lo _: hi [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_range(Z3_context c, Z3_ast lo, Z3_ast hi);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_range ( Z3Context c, Z3AST lo, Z3AST hi ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_sort: c _: seq [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_re_sort(Z3_context c, Z3_sort seq);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_re_sort ( Z3Context c, Z3Sort seq ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_star: c _: re [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_star(Z3_context c, Z3_ast re);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_star ( Z3Context c, Z3AST re ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_re_union: c _: n _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_re_union(Z3_context c, unsigned n, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_re_union ( Z3Context c, uint n, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_real2int: c _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_real2int(Z3_context c, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_real2int ( Z3Context c, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_real: c _: num _: den [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_real(Z3_context c, int num, int den);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_real ( Z3Context c, int num, int den ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_real_sort: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_real_sort(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_real_sort ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_rec_func_decl: c _: s _: domain_size _: domain _: range [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_rec_func_decl(Z3_context c, Z3_symbol s,
										unsigned domain_size, Z3_sort const domain[],
										Z3_sort range);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_rec_func_decl ( Z3Context c, Z3Symbol s, uint domain_size, FFIExternalArray domain, Z3Sort range ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_rem: c _: arg1 _: arg2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_rem(Z3_context c, Z3_ast arg1, Z3_ast arg2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_rem ( Z3Context c, Z3AST arg1, Z3AST arg2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_repeat: c _: i _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_repeat(Z3_context c, unsigned i, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_repeat ( Z3Context c, uint i, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_rotate_left: c _: i _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_rotate_left(Z3_context c, unsigned i, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_rotate_left ( Z3Context c, uint i, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_rotate_right: c _: i _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_rotate_right(Z3_context c, unsigned i, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_rotate_right ( Z3Context c, uint i, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_select: c _: a _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_select(Z3_context c, Z3_ast a, Z3_ast i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_select ( Z3Context c, Z3AST a, Z3AST i ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_select_n: c _: a _: n _: idxs [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_select_n(Z3_context c, Z3_ast a, unsigned n, Z3_ast const* idxs);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_select_n ( Z3Context c, Z3AST a, uint n, FFIExternalArray idxs ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_at: c _: s _: index [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_at(Z3_context c, Z3_ast s, Z3_ast index);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_at ( Z3Context c, Z3AST s, Z3AST index ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_concat: c _: n _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_concat(Z3_context c, unsigned n, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_concat ( Z3Context c, uint n, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_contains: c _: container _: containee [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_contains(Z3_context c, Z3_ast container, Z3_ast containee);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_contains ( Z3Context c, Z3AST container, Z3AST containee ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_empty: c _: seq [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_empty(Z3_context c, Z3_sort seq);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_empty ( Z3Context c, Z3Sort seq ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_extract: c _: s _: offset _: length [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_extract(Z3_context c, Z3_ast s, Z3_ast offset, Z3_ast length);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_extract ( Z3Context c, Z3AST s, Z3AST offset, Z3AST length ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_in_re: c _: seq _: re [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_in_re(Z3_context c, Z3_ast seq, Z3_ast re);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_in_re ( Z3Context c, Z3AST seq, Z3AST re ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_index: c _: s _: substr _: offset [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_index(Z3_context c, Z3_ast s, Z3_ast substr, Z3_ast offset);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_index ( Z3Context c, Z3AST s, Z3AST substr, Z3AST offset ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_last_index: c _: arg1 _: substr [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_last_index(Z3_context c, Z3_ast, Z3_ast substr);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_last_index ( Z3Context c, Z3AST arg1, Z3AST substr ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_length: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_length(Z3_context c, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_length ( Z3Context c, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_nth: c _: s _: index [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_nth(Z3_context c, Z3_ast s, Z3_ast index);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_nth ( Z3Context c, Z3AST s, Z3AST index ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_prefix: c _: prefix _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_prefix(Z3_context c, Z3_ast prefix, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_prefix ( Z3Context c, Z3AST prefix, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_replace: c _: s _: src _: dst [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_replace(Z3_context c, Z3_ast s, Z3_ast src, Z3_ast dst);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_replace ( Z3Context c, Z3AST s, Z3AST src, Z3AST dst ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_sort: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_seq_sort(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_seq_sort ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_suffix: c _: suffix _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_suffix(Z3_context c, Z3_ast suffix, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_suffix ( Z3Context c, Z3AST suffix, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_to_re: c _: seq [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_to_re(Z3_context c, Z3_ast seq);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_to_re ( Z3Context c, Z3AST seq ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_seq_unit: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_seq_unit(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_seq_unit ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_add: c _: set _: elem [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_add(Z3_context c, Z3_ast set, Z3_ast elem);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_add ( Z3Context c, Z3AST set, Z3AST elem ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_complement: c _: arg [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_complement(Z3_context c, Z3_ast arg);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_complement ( Z3Context c, Z3AST arg ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_del: c _: set _: elem [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_del(Z3_context c, Z3_ast set, Z3_ast elem);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_del ( Z3Context c, Z3AST set, Z3AST elem ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_difference: c _: arg1 _: arg2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_difference(Z3_context c, Z3_ast arg1, Z3_ast arg2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_difference ( Z3Context c, Z3AST arg1, Z3AST arg2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_has_size: c _: set _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_has_size(Z3_context c, Z3_ast set, Z3_ast k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_has_size ( Z3Context c, Z3AST set, Z3AST k ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_intersect: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_intersect(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_intersect ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_member: c _: elem _: set [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_member(Z3_context c, Z3_ast elem, Z3_ast set);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_member ( Z3Context c, Z3AST elem, Z3AST set ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_sort: c _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_set_sort(Z3_context c, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_set_sort ( Z3Context c, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_subset: c _: arg1 _: arg2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_subset(Z3_context c, Z3_ast arg1, Z3_ast arg2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_subset ( Z3Context c, Z3AST arg1, Z3AST arg2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_set_union: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_set_union(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_set_union ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_sign_ext: c _: i _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_sign_ext(Z3_context c, unsigned i, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_sign_ext ( Z3Context c, uint i, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_simple_solver: c [
	"
		PRIVATE - DO NOT USE!

		Z3_solver Z3_API Z3_mk_simple_solver(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Solver Z3_mk_simple_solver ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_solver: c [
	"
		PRIVATE - DO NOT USE!

		Z3_solver Z3_API Z3_mk_solver(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Solver Z3_mk_solver ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_solver_for_logic: c _: logic [
	"
		PRIVATE - DO NOT USE!

		Z3_solver Z3_API Z3_mk_solver_for_logic(Z3_context c, Z3_symbol logic);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_solver_from_tactic: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_solver Z3_API Z3_mk_solver_from_tactic(Z3_context c, Z3_tactic t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_store: c _: a _: i _: v [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_store(Z3_context c, Z3_ast a, Z3_ast i, Z3_ast v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_store ( Z3Context c, Z3AST a, Z3AST i, Z3AST v ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_store_n: c _: a _: n _: idxs _: v [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_store_n(Z3_context c, Z3_ast a, unsigned n, Z3_ast const* idxs, Z3_ast v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_store_n ( Z3Context c, Z3AST a, uint n, FFIExternalArray idxs, Z3AST v ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_str_le: c _: prefix _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_str_le(Z3_context c, Z3_ast prefix, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_str_le ( Z3Context c, Z3AST prefix, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_str_lt: c _: prefix _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_str_lt(Z3_context c, Z3_ast prefix, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_str_lt ( Z3Context c, Z3AST prefix, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_str_to_int: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_str_to_int(Z3_context c, Z3_ast s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_str_to_int ( Z3Context c, Z3AST s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_string: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_string(Z3_context c, Z3_string s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_string ( Z3Context c, char * s ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_string_sort: c [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_string_sort(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_string_sort ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_string_symbol: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_mk_string_symbol(Z3_context c, Z3_string s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_sub: c _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_sub(Z3_context c, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_sub ( Z3Context c, uint num_args, FFIExternalArray args ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_tactic: c _: name [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_mk_tactic(Z3_context c, Z3_string name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_transitive_closure: c _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_transitive_closure(Z3_context c, Z3_func_decl f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_transitive_closure ( Z3Context c, Z3AST f ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_tree_order: c _: a _: id [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_mk_tree_order(Z3_context c, Z3_sort a, unsigned id);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_tree_order ( Z3Context c, Z3Sort a, uint id ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_true: c [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_true(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_true ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_tuple_sort: c _: mk_tuple_name _: num_fields _: field_names _: field_sorts _: mk_tuple_decl _: proj_decl [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_tuple_sort(Z3_context c,
										Z3_symbol mk_tuple_name,
										unsigned num_fields,
										Z3_symbol const field_names[],
										Z3_sort const field_sorts[],
										Z3_func_decl * mk_tuple_decl,
										Z3_func_decl proj_decl[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_mk_tuple_sort ( Z3Context c, Z3Symbol mk_tuple_name, uint num_fields, FFIExternalArray field_names, FFIExternalArray field_sorts, Z3AST mk_tuple_decl, FFIExternalArray proj_decl ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_unary_minus: c _: arg [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_unary_minus(Z3_context c, Z3_ast arg);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_unary_minus ( Z3Context c, Z3AST arg ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_uninterpreted_sort: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_mk_uninterpreted_sort(Z3_context c, Z3_symbol s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _mk_unsigned_int64: c _: v _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_unsigned_int64(Z3_context c, uint64_t v, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_unsigned_int64 ( Z3Context c, uint65 v, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_unsigned_int: c _: v _: ty [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_unsigned_int(Z3_context c, unsigned v, Z3_sort ty);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_unsigned_int ( Z3Context c, uint v, Z3Sort ty ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_xor: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_xor(Z3_context c, Z3_ast t1, Z3_ast t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_xor ( Z3Context c, Z3AST t1, Z3AST t2 ) )

]

{ #category : #'API - private' }
LibZ3 >> _mk_zero_ext: c _: i _: t1 [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_mk_zero_ext(Z3_context c, unsigned i, Z3_ast t1);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_mk_zero_ext ( Z3Context c, uint i, Z3AST t1 ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_dec_ref: c _: m [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_model_dec_ref(Z3_context c, Z3_model m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_model_dec_ref ( Z3Context c, Z3Model m ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_eval: c _: m _: t _: model_completion _: v [
	"
		PRIVATE - DO NOT USE!

		Z3_bool_opt Z3_API Z3_model_eval(Z3_context c, Z3_model m, Z3_ast t, bool model_completion, Z3_ast * v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_model_eval ( Z3Context c, Z3Model m, Z3AST t, bool model_completion, Z3AST v ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_extrapolate: c _: m _: fml [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_model_extrapolate
	  (Z3_context c,
	   Z3_model m,
	   Z3_ast fml);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_model_extrapolate ( Z3Context c, Z3Model m, Z3AST fml ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_const_decl: c _: m _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_model_get_const_decl(Z3_context c, Z3_model m, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_model_get_const_decl ( Z3Context c, Z3Model m, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_const_interp: c _: m _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_opt Z3_API Z3_model_get_const_interp(Z3_context c, Z3_model m, Z3_func_decl a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_model_get_const_interp ( Z3Context c, Z3Model m, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_func_decl: c _: m _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_model_get_func_decl(Z3_context c, Z3_model m, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_model_get_func_decl ( Z3Context c, Z3Model m, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_func_interp: c _: m _: f [
	"
		PRIVATE - DO NOT USE!

		Z3_func_interp_opt Z3_API Z3_model_get_func_interp(Z3_context c, Z3_model m, Z3_func_decl f);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type FUNC_INTERP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _model_get_num_consts: c _: m [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_model_get_num_consts(Z3_context c, Z3_model m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_model_get_num_consts ( Z3Context c, Z3Model m ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_num_funcs: c _: m [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_model_get_num_funcs(Z3_context c, Z3_model m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_model_get_num_funcs ( Z3Context c, Z3Model m ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_num_sorts: c _: m [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_model_get_num_sorts(Z3_context c, Z3_model m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_model_get_num_sorts ( Z3Context c, Z3Model m ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_sort: c _: m _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_sort Z3_API Z3_model_get_sort(Z3_context c, Z3_model m, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Sort Z3_model_get_sort ( Z3Context c, Z3Model m, uint i ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_get_sort_universe: c _: m _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_model_get_sort_universe(Z3_context c, Z3_model m, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_model_get_sort_universe ( Z3Context c, Z3Model m, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_has_interp: c _: m _: a [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_model_has_interp(Z3_context c, Z3_model m, Z3_func_decl a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( bool Z3_model_has_interp ( Z3Context c, Z3Model m, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_inc_ref: c _: m [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_model_inc_ref(Z3_context c, Z3_model m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_model_inc_ref ( Z3Context c, Z3Model m ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_to_string: c _: m [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_model_to_string(Z3_context c, Z3_model m);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_model_to_string ( Z3Context c, Z3Model m ) )

]

{ #category : #'API - private' }
LibZ3 >> _model_translate: c _: m _: dst [
	"
		PRIVATE - DO NOT USE!

		Z3_model Z3_API Z3_model_translate(Z3_context c, Z3_model m, Z3_context dst);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Model Z3_model_translate ( Z3Context c, Z3Model m, Z3Context dst ) )

]

{ #category : #'API - private' }
LibZ3 >> _optimize_assert: c _: o _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_assert(Z3_context c, Z3_optimize o, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_assert_and_track: c _: o _: a _: t [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_assert_and_track(Z3_context c, Z3_optimize o, Z3_ast a, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_assert_soft: c _: o _: a _: weight _: id [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_optimize_assert_soft(Z3_context c, Z3_optimize o, Z3_ast a, Z3_string weight, Z3_symbol id);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_check: c _: o _: num_assumptions _: assumptions [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_optimize_check(Z3_context c, Z3_optimize o, unsigned num_assumptions, Z3_ast const assumptions[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_dec_ref: c _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_dec_ref(Z3_context c, Z3_optimize d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_from_file: c _: o _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_from_file(Z3_context c, Z3_optimize o, Z3_string s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_from_string: c _: o _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_from_string(Z3_context c, Z3_optimize o, Z3_string s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_assertions: c _: o [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_optimize_get_assertions(Z3_context c, Z3_optimize o);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_help: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_optimize_get_help(Z3_context c, Z3_optimize t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_lower: c _: o _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_optimize_get_lower(Z3_context c, Z3_optimize o, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_lower_as_vector: c _: o _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_optimize_get_lower_as_vector(Z3_context c, Z3_optimize o, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_model: c _: o [
	"
		PRIVATE - DO NOT USE!

		Z3_model Z3_API Z3_optimize_get_model(Z3_context c, Z3_optimize o);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_objectives: c _: o [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_optimize_get_objectives(Z3_context c, Z3_optimize o);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_param_descrs: c _: o [
	"
		PRIVATE - DO NOT USE!

		Z3_param_descrs Z3_API Z3_optimize_get_param_descrs(Z3_context c, Z3_optimize o);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_reason_unknown: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_optimize_get_reason_unknown(Z3_context c, Z3_optimize d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_statistics: c _: d [
	"
		PRIVATE - DO NOT USE!

		Z3_stats Z3_API Z3_optimize_get_statistics(Z3_context c, Z3_optimize d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_upper: c _: o _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_optimize_get_upper(Z3_context c, Z3_optimize o, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_get_upper_as_vector: c _: o _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_optimize_get_upper_as_vector(Z3_context c, Z3_optimize o, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_inc_ref: c _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_inc_ref(Z3_context c, Z3_optimize d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_maximize: c _: o _: t [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_optimize_maximize(Z3_context c, Z3_optimize o, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_minimize: c _: o _: t [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_optimize_minimize(Z3_context c, Z3_optimize o, Z3_ast t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_pop: c _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_pop(Z3_context c, Z3_optimize d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_push: c _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_push(Z3_context c, Z3_optimize d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_set_params: c _: o _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_optimize_set_params(Z3_context c, Z3_optimize o, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _optimize_to_string: c _: o [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_optimize_to_string(Z3_context c, Z3_optimize o);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type OPTIMIZE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _param_descrs_dec_ref: c _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_param_descrs_dec_ref(Z3_context c, Z3_param_descrs p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _param_descrs_get_documentation: c _: p _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_param_descrs_get_documentation(Z3_context c, Z3_param_descrs p, Z3_symbol s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _param_descrs_get_kind: c _: p _: n [
	"
		PRIVATE - DO NOT USE!

		Z3_param_kind Z3_API Z3_param_descrs_get_kind(Z3_context c, Z3_param_descrs p, Z3_symbol n);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _param_descrs_get_name: c _: p _: i [
	"
		PRIVATE - DO NOT USE!

		Z3_symbol Z3_API Z3_param_descrs_get_name(Z3_context c, Z3_param_descrs p, unsigned i);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SYMBOL not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _param_descrs_inc_ref: c _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_param_descrs_inc_ref(Z3_context c, Z3_param_descrs p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _param_descrs_size: c _: p [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_param_descrs_size(Z3_context c, Z3_param_descrs p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _param_descrs_to_string: c _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_param_descrs_to_string(Z3_context c, Z3_param_descrs p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_dec_ref: c _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_params_dec_ref(Z3_context c, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_inc_ref: c _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_params_inc_ref(Z3_context c, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_set_bool: c _: p _: k _: v [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_params_set_bool(Z3_context c, Z3_params p, Z3_symbol k, bool v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_set_double: c _: p _: k _: v [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_params_set_double(Z3_context c, Z3_params p, Z3_symbol k, double v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_set_symbol: c _: p _: k _: v [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_params_set_symbol(Z3_context c, Z3_params p, Z3_symbol k, Z3_symbol v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_set_uint: c _: p _: k _: v [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_params_set_uint(Z3_context c, Z3_params p, Z3_symbol k, unsigned v);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_to_string: c _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_params_to_string(Z3_context c, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _params_validate: c _: p _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_params_validate(Z3_context c, Z3_params p, Z3_param_descrs d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _parse_smtlib2_file: c _: file_name _: num_sorts _: sort_names _: sorts _: num_decls _: decl_names _: decls [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_parse_smtlib2_file(Z3_context c,
										Z3_string file_name,
										unsigned num_sorts,
										Z3_symbol const sort_names[],
										Z3_sort const sorts[],
										unsigned num_decls,
										Z3_symbol const decl_names[],
										Z3_func_decl const decls[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_parse_smtlib2_file ( Z3Context c, char * file_name, uint num_sorts, FFIExternalArray sort_names, FFIExternalArray sorts, uint num_decls, FFIExternalArray decl_names, FFIExternalArray decls ) )

]

{ #category : #'API - private' }
LibZ3 >> _parse_smtlib2_string: c _: str _: num_sorts _: sort_names _: sorts _: num_decls _: decl_names _: decls [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_parse_smtlib2_string(Z3_context c,
										  Z3_string str,
										  unsigned num_sorts,
										  Z3_symbol const sort_names[],
										  Z3_sort const sorts[],
										  unsigned num_decls,
										  Z3_symbol const decl_names[],
										  Z3_func_decl const decls[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_parse_smtlib2_string ( Z3Context c, char * str, uint num_sorts, FFIExternalArray sort_names, FFIExternalArray sorts, uint num_decls, FFIExternalArray decl_names, FFIExternalArray decls ) )

]

{ #category : #'API - private' }
LibZ3 >> _pattern_to_ast: c _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_pattern_to_ast(Z3_context c, Z3_pattern p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PATTERN not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _pattern_to_string: c _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_pattern_to_string(Z3_context c, Z3_pattern p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PATTERN not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _polynomial_subresultants: c _: p _: q _: x [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_polynomial_subresultants(Z3_context c, Z3_ast p, Z3_ast q, Z3_ast x);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_polynomial_subresultants ( Z3Context c, Z3AST p, Z3AST q, Z3AST x ) )

]

{ #category : #'API - private' }
LibZ3 >> _probe_and: x _: p1 _: p2 [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_and(Z3_context x, Z3_probe p1, Z3_probe p2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_apply: c _: p _: g [
	"
		PRIVATE - DO NOT USE!

		double Z3_API Z3_probe_apply(Z3_context c, Z3_probe p, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_const: x _: val [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_const(Z3_context x, double val);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_dec_ref: c _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_probe_dec_ref(Z3_context c, Z3_probe p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_eq: x _: p1 _: p2 [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_eq(Z3_context x, Z3_probe p1, Z3_probe p2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_ge: x _: p1 _: p2 [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_ge(Z3_context x, Z3_probe p1, Z3_probe p2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_get_descr: c _: name [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_probe_get_descr(Z3_context c, Z3_string name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_probe_get_descr ( Z3Context c, char * name ) )

]

{ #category : #'API - private' }
LibZ3 >> _probe_gt: x _: p1 _: p2 [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_gt(Z3_context x, Z3_probe p1, Z3_probe p2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_inc_ref: c _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_probe_inc_ref(Z3_context c, Z3_probe p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_le: x _: p1 _: p2 [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_le(Z3_context x, Z3_probe p1, Z3_probe p2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_lt: x _: p1 _: p2 [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_lt(Z3_context x, Z3_probe p1, Z3_probe p2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_not: x _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_not(Z3_context x, Z3_probe p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _probe_or: x _: p1 _: p2 [
	"
		PRIVATE - DO NOT USE!

		Z3_probe Z3_API Z3_probe_or(Z3_context x, Z3_probe p1, Z3_probe p2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PROBE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _qe_model_project: c _: m _: num_bounds _: bound _: body [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_qe_model_project
	  (Z3_context c,
	   Z3_model m,
	   unsigned num_bounds,
	   Z3_app const bound[],
	   Z3_ast body);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_qe_model_project ( Z3Context c, Z3Model m, uint num_bounds, FFIExternalArray bound, Z3AST body ) )

]

{ #category : #'API - private' }
LibZ3 >> _qe_model_project_skolem: c _: m _: num_bounds _: bound _: body _: map [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_qe_model_project_skolem
	  (Z3_context c,
	   Z3_model m,
	   unsigned num_bounds,
	   Z3_app const bound[],
	   Z3_ast body,
	   Z3_ast_map map);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type AST_MAP not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _query_constructor: c _: constr _: num_fields _: constructor _: tester _: accessors [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_query_constructor(Z3_context c,
									 Z3_constructor constr,
									 unsigned num_fields,
									 Z3_func_decl* constructor,
									 Z3_func_decl* tester,
									 Z3_func_decl accessors[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_query_constructor ( Z3Context c, Z3Constructor constr, uint num_fields, Z3AST constructor, Z3AST tester, FFIExternalArray accessors ) )

]

{ #category : #'API - private' }
LibZ3 >> _rcf_add: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_add(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_del: c _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_rcf_del(Z3_context c, Z3_rcf_num a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_div: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_div(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_eq: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_rcf_eq(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_ge: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_rcf_ge(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_get_numerator_denominator: c _: a _: n _: d [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_rcf_get_numerator_denominator(Z3_context c, Z3_rcf_num a, Z3_rcf_num * n, Z3_rcf_num * d);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_gt: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_rcf_gt(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_inv: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_inv(Z3_context c, Z3_rcf_num a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_le: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_rcf_le(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_lt: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_rcf_lt(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_mk_e: c [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_mk_e(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_mk_infinitesimal: c [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_mk_infinitesimal(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_mk_pi: c [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_mk_pi(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_mk_rational: c _: val [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_mk_rational(Z3_context c, Z3_string val);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_mk_roots: c _: n _: a _: roots [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_rcf_mk_roots(Z3_context c, unsigned n, Z3_rcf_num const a[], Z3_rcf_num roots[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_rcf_mk_roots ( Z3Context c, uint n, FFIExternalArray a, FFIExternalArray roots ) )

]

{ #category : #'API - private' }
LibZ3 >> _rcf_mk_small_int: c _: val [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_mk_small_int(Z3_context c, int val);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_mul: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_mul(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_neg: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_neg(Z3_context c, Z3_rcf_num a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_neq: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_rcf_neq(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_num_to_decimal_string: c _: a _: prec [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_rcf_num_to_decimal_string(Z3_context c, Z3_rcf_num a, unsigned prec);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_num_to_string: c _: a _: compact _: html [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_rcf_num_to_string(Z3_context c, Z3_rcf_num a, bool compact, bool html);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_power: c _: a _: k [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_power(Z3_context c, Z3_rcf_num a, unsigned k);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _rcf_sub: c _: a _: b [
	"
		PRIVATE - DO NOT USE!

		Z3_rcf_num Z3_API Z3_rcf_sub(Z3_context c, Z3_rcf_num a, Z3_rcf_num b);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type RCF_NUM not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _reset_memory [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_reset_memory(void);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_reset_memory ( ) )

]

{ #category : #'API - private' }
LibZ3 >> _set_ast_print_mode: c _: mode [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_set_ast_print_mode(Z3_context c, Z3_ast_print_mode mode);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PRINT_MODE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _set_error: c _: e [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_set_error(Z3_context c, Z3_error_code e);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type ERROR_CODE not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _set_param_value: c _: param_id _: param_value [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_set_param_value(Z3_config c, Z3_string param_id, Z3_string param_value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_set_param_value ( Z3Config c, char * param_id, char * param_value ) )

]

{ #category : #'API - private' }
LibZ3 >> _simplify: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_simplify(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_simplify ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _simplify_ex: c _: a _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_simplify_ex(Z3_context c, Z3_ast a, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _simplify_get_help: c [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_simplify_get_help(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_simplify_get_help ( Z3Context c ) )

]

{ #category : #'API - private' }
LibZ3 >> _simplify_get_param_descrs: c [
	"
		PRIVATE - DO NOT USE!

		Z3_param_descrs Z3_API Z3_simplify_get_param_descrs(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _solver_assert: c _: s _: a [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_assert(Z3_context c, Z3_solver s, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_assert ( Z3Context c, Z3Solver s, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_assert_and_track: c _: s _: a _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_assert_and_track(Z3_context c, Z3_solver s, Z3_ast a, Z3_ast p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_assert_and_track ( Z3Context c, Z3Solver s, Z3AST a, Z3AST p ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_check: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_solver_check(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_solver_check ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_check_assumptions: c _: s _: num_assumptions _: assumptions [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_solver_check_assumptions(Z3_context c, Z3_solver s,
												unsigned num_assumptions, Z3_ast const assumptions[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_solver_check_assumptions ( Z3Context c, Z3Solver s, uint num_assumptions, FFIExternalArray assumptions ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_cube: c _: s _: vars _: backtrack_level [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_solver_cube(Z3_context c, Z3_solver s, Z3_ast_vector vars, unsigned backtrack_level);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_solver_cube ( Z3Context c, Z3Solver s, Z3ASTVector vars, uint backtrack_level ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_dec_ref: c _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_dec_ref(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_dec_ref ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_from_file: c _: s _: file_name [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_from_file(Z3_context c, Z3_solver s, Z3_string file_name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_from_file ( Z3Context c, Z3Solver s, char * file_name ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_from_string: c _: s _: file_name [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_from_string(Z3_context c, Z3_solver s, Z3_string file_name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_from_string ( Z3Context c, Z3Solver s, char * file_name ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_assertions: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_solver_get_assertions(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_solver_get_assertions ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_consequences: c _: s _: assumptions _: variables _: consequences [
	"
		PRIVATE - DO NOT USE!

		Z3_lbool Z3_API Z3_solver_get_consequences(Z3_context c,
											   Z3_solver s,
											   Z3_ast_vector assumptions,
											   Z3_ast_vector variables,
											   Z3_ast_vector consequences);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( int Z3_solver_get_consequences ( Z3Context c, Z3Solver s, Z3ASTVector assumptions, Z3ASTVector variables, Z3ASTVector consequences ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_help: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_solver_get_help(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_solver_get_help ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_levels: c _: s _: literals _: sz _: levels [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_get_levels(Z3_context c, Z3_solver s, Z3_ast_vector literals, unsigned sz,  unsigned levels[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_get_levels ( Z3Context c, Z3Solver s, Z3ASTVector literals, uint sz, FFIExternalArray levels ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_model: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_model Z3_API Z3_solver_get_model(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Model Z3_solver_get_model ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_non_units: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_solver_get_non_units(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_solver_get_non_units ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_num_scopes: c _: s [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_solver_get_num_scopes(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_solver_get_num_scopes ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_param_descrs: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_param_descrs Z3_API Z3_solver_get_param_descrs(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_proof: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_solver_get_proof(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_solver_get_proof ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_reason_unknown: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_solver_get_reason_unknown(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_solver_get_reason_unknown ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_statistics: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_stats Z3_API Z3_solver_get_statistics(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_trail: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_solver_get_trail(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_solver_get_trail ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_units: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_solver_get_units(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_solver_get_units ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_get_unsat_core: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast_vector Z3_API Z3_solver_get_unsat_core(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3ASTVector Z3_solver_get_unsat_core ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_import_model_converter: ctx _: src _: dst [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_import_model_converter(Z3_context ctx, Z3_solver src, Z3_solver dst);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_import_model_converter ( Z3Context ctx, Z3Solver src, Z3Solver dst ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_inc_ref: c _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_inc_ref(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_inc_ref ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_interrupt: c _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_interrupt(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_interrupt ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_pop: c _: s _: n [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_pop(Z3_context c, Z3_solver s, unsigned n);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_pop ( Z3Context c, Z3Solver s, uint n ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_propagate_consequence: c _: arg1 _: num_fixed _: fixed_ids _: num_eqs _: eq_lhs _: eq_rhs _: conseq [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_propagate_consequence(Z3_context c, Z3_solver_callback, unsigned num_fixed, unsigned const* fixed_ids, unsigned num_eqs, unsigned const* eq_lhs, unsigned const* eq_rhs, Z3_ast conseq);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type SOLVER_CALLBACK not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _solver_propagate_register: c _: s _: e [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_solver_propagate_register(Z3_context c, Z3_solver s, Z3_ast e);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( uint Z3_solver_propagate_register ( Z3Context c, Z3Solver s, Z3AST e ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_push: c _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_push(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_push ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_reset: c _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_reset(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_solver_reset ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_set_params: c _: s _: p [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_solver_set_params(Z3_context c, Z3_solver s, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAMS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _solver_to_dimacs_string: c _: s _: include_names [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_solver_to_dimacs_string(Z3_context c, Z3_solver s, bool include_names);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_solver_to_dimacs_string ( Z3Context c, Z3Solver s, bool include_names ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_to_string: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_solver_to_string(Z3_context c, Z3_solver s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_solver_to_string ( Z3Context c, Z3Solver s ) )

]

{ #category : #'API - private' }
LibZ3 >> _solver_translate: source _: s _: target [
	"
		PRIVATE - DO NOT USE!

		Z3_solver Z3_API Z3_solver_translate(Z3_context source, Z3_solver s, Z3_context target);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3Solver Z3_solver_translate ( Z3Context source, Z3Solver s, Z3Context target ) )

]

{ #category : #'API - private' }
LibZ3 >> _sort_to_ast: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_sort_to_ast(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_sort_to_ast ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _sort_to_string: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_sort_to_string(Z3_context c, Z3_sort s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_sort_to_string ( Z3Context c, Z3Sort s ) )

]

{ #category : #'API - private' }
LibZ3 >> _stats_dec_ref: c _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_stats_dec_ref(Z3_context c, Z3_stats s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_get_double_value: c _: s _: idx [
	"
		PRIVATE - DO NOT USE!

		double Z3_API Z3_stats_get_double_value(Z3_context c, Z3_stats s, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_get_key: c _: s _: idx [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_stats_get_key(Z3_context c, Z3_stats s, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_get_uint_value: c _: s _: idx [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_stats_get_uint_value(Z3_context c, Z3_stats s, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_inc_ref: c _: s [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_stats_inc_ref(Z3_context c, Z3_stats s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_is_double: c _: s _: idx [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_stats_is_double(Z3_context c, Z3_stats s, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_is_uint: c _: s _: idx [
	"
		PRIVATE - DO NOT USE!

		bool Z3_API Z3_stats_is_uint(Z3_context c, Z3_stats s, unsigned idx);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_size: c _: s [
	"
		PRIVATE - DO NOT USE!

		unsigned Z3_API Z3_stats_size(Z3_context c, Z3_stats s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _stats_to_string: c _: s [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_stats_to_string(Z3_context c, Z3_stats s);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type STATS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _substitute: c _: a _: num_exprs _: from _: to [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_substitute(Z3_context c,
								Z3_ast a,
								unsigned num_exprs,
								Z3_ast const from[],
								Z3_ast const to[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_substitute ( Z3Context c, Z3AST a, uint num_exprs, FFIExternalArray from, FFIExternalArray to ) )

]

{ #category : #'API - private' }
LibZ3 >> _substitute_vars: c _: a _: num_exprs _: to [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_substitute_vars(Z3_context c,
									 Z3_ast a,
									 unsigned num_exprs,
									 Z3_ast const to[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_substitute_vars ( Z3Context c, Z3AST a, uint num_exprs, FFIExternalArray to ) )

]

{ #category : #'API - private' }
LibZ3 >> _tactic_and_then: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_and_then(Z3_context c, Z3_tactic t1, Z3_tactic t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_apply: c _: t _: g [
	"
		PRIVATE - DO NOT USE!

		Z3_apply_result Z3_API Z3_tactic_apply(Z3_context c, Z3_tactic t, Z3_goal g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type APPLY_RESULT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_apply_ex: c _: t _: g _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_apply_result Z3_API Z3_tactic_apply_ex(Z3_context c, Z3_tactic t, Z3_goal g, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type APPLY_RESULT not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_cond: c _: p _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_cond(Z3_context c, Z3_probe p, Z3_tactic t1, Z3_tactic t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_dec_ref: c _: g [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_tactic_dec_ref(Z3_context c, Z3_tactic g);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_fail: c [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_fail(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_fail_if: c _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_fail_if(Z3_context c, Z3_probe p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_fail_if_not_decided: c [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_fail_if_not_decided(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_get_descr: c _: name [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_tactic_get_descr(Z3_context c, Z3_string name);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( char * Z3_tactic_get_descr ( Z3Context c, char * name ) )

]

{ #category : #'API - private' }
LibZ3 >> _tactic_get_help: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_string Z3_API Z3_tactic_get_help(Z3_context c, Z3_tactic t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_get_param_descrs: c _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_param_descrs Z3_API Z3_tactic_get_param_descrs(Z3_context c, Z3_tactic t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type PARAM_DESCRS not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_inc_ref: c _: t [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_tactic_inc_ref(Z3_context c, Z3_tactic t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_or_else: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_or_else(Z3_context c, Z3_tactic t1, Z3_tactic t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_par_and_then: c _: t1 _: t2 [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_par_and_then(Z3_context c, Z3_tactic t1, Z3_tactic t2);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_par_or: c _: num _: ts [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_par_or(Z3_context c, unsigned num, Z3_tactic const ts[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_repeat: c _: t _: max [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_repeat(Z3_context c, Z3_tactic t, unsigned max);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_skip: c [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_skip(Z3_context c);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_try_for: c _: t _: ms [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_try_for(Z3_context c, Z3_tactic t, unsigned ms);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_using_params: c _: t _: p [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_using_params(Z3_context c, Z3_tactic t, Z3_params p);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _tactic_when: c _: p _: t [
	"
		PRIVATE - DO NOT USE!

		Z3_tactic Z3_API Z3_tactic_when(Z3_context c, Z3_probe p, Z3_tactic t);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API supported: Type TACTIC not (yet) supported.'

]

{ #category : #'API - private' }
LibZ3 >> _to_app: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_app Z3_API Z3_to_app(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_to_app ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _to_func_decl: c _: a [
	"
		PRIVATE - DO NOT USE!

		Z3_func_decl Z3_API Z3_to_func_decl(Z3_context c, Z3_ast a);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_to_func_decl ( Z3Context c, Z3AST a ) )

]

{ #category : #'API - private' }
LibZ3 >> _toggle_warning_messages: enabled [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_toggle_warning_messages(bool enabled);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_toggle_warning_messages ( bool enabled ) )

]

{ #category : #'API - private' }
LibZ3 >> _translate: source _: a _: target [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_translate(Z3_context source, Z3_ast a, Z3_context target);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_translate ( Z3Context source, Z3AST a, Z3Context target ) )

]

{ #category : #'API - private' }
LibZ3 >> _update_param_value: c _: param_id _: param_value [
	"
		PRIVATE - DO NOT USE!

		void Z3_API Z3_update_param_value(Z3_context c, Z3_string param_id, Z3_string param_value);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( void Z3_update_param_value ( Z3Context c, char * param_id, char * param_value ) )

]

{ #category : #'API - private' }
LibZ3 >> _update_term: c _: a _: num_args _: args [
	"
		PRIVATE - DO NOT USE!

		Z3_ast Z3_API Z3_update_term(Z3_context c, Z3_ast a, unsigned num_args, Z3_ast const args[]);

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self ffiCall: #( Z3AST Z3_update_term ( Z3Context c, Z3AST a, uint num_args, FFIExternalArray args ) )

]

{ #category : #'string conversion' }
LibZ3 >> astToString: ctx ast: ast [
	"Convert the given AST node into a string.

	   \warning The result buffer is statically allocated by Z3. It will
	   be automatically deallocated when #Z3_del_context is invoked.
	   So, the buffer is invalidated in the next call to \c Z3_ast_to_string."
	^ self halt; ffiCall: #(String Z3_ast_to_string (Z3Context ctx, Z3AST ast) )
]

{ #category : #'as yet unclassified' }
LibZ3 >> astVectorToString: ctx astVector: fs [
	^ self halt; ffiCall: #( String Z3_ast_vector_to_string (Z3Context ctx, Z3ASTVector fs) )
]

{ #category : #'ref-counting' }
LibZ3 >> decRef: ctx astVector: fs [
	self halt; ffiCall: #( void Z3_ast_vector_dec_ref (Z3Context ctx, Z3ASTVector fs) )
]

{ #category : #'ref-counting' }
LibZ3 >> decRef: ctx model: model [
	self halt; ffiCall: #( void Z3_model_dec_ref (Z3Context ctx, Z3Model model) )
]

{ #category : #'ref-counting' }
LibZ3 >> decRef: ctx solver: solver [
	self halt; ffiCall: #( void Z3_solver_dec_ref (Z3Context ctx, Z3Solver solver) )
]

{ #category : #context }
LibZ3 >> delContext: c [
	"Delete the given logical context."
	^ self halt; ffiCall: #(void  Z3_del_context (Z3Context c) )
]

{ #category : #context }
LibZ3 >> delSolver: c solver: s [
	"Delete the given logical context."
	^ self halt; ffiCall: #(void  Z3_solver_dec_ref (Z3Context c, Z3Solver s) )
]

{ #category : #accessors }
LibZ3 >> funcDeclToAST: ctx funcDecl: aFuncDecl [
	"Convert a Z3_func_decl into Z3_ast.
	Z3 API documentation claims 'This is just type casting'
	but this doesn't work for me."
	^ self halt; ffiCall: #( void* Z3_get_func_decl_id (Z3Context ctx, FuncDecl aFuncDecl) )
]

{ #category : #accessors }
LibZ3 >> getAppArg: ctx app: a index: zeroBasedIndex [
	"Return the i-th argument of the given application.
	   def_API('Z3_get_app_arg', Z3AST, (_in(CONTEXT), _in(APP), _in(UINT)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_app a, unsigned i);"
	^ self halt; ffiCall: #( void*  Z3_get_app_arg (Z3Context ctx, Z3AppAST a, uint zeroBasedIndex) )
]

{ #category : #accessors }
LibZ3 >> getAppDecl: ctx app: aZ3App [
	"Return the declaration of a function application."
	^ self halt; ffiCall: #( FuncDecl  Z3_get_app_decl (Z3Context ctx, Z3AppAST aZ3App) )
]

{ #category : #accessors }
LibZ3 >> getAppNumArgs: ctx app: a [
	"Return the number of argument of an application.
	If a is a constant, then the number of arguments is 0.
		unsigned Z3_API Z3_get_app_num_args(Z3_context c, Z3_app a);"
	^ self halt; ffiCall: #( uint  Z3_get_app_num_args (Z3Context ctx, Z3AppAST a) )
]

{ #category : #accessors }
LibZ3 >> getArity: ctx funcDecl: aFuncDecl [
	"Alias for getDomainSize."
	^ self halt; ffiCall: #( uint  Z3_get_arity (Z3Context ctx, FuncDecl aFuncDecl) )
]

{ #category : #'as yet unclassified' }
LibZ3 >> getAstHash: ctx ast: a [
	"Return a hash code for the given AST.
	The hash code is structural."
	^ self halt; ffiCall: #( uint Z3_get_ast_hash (Z3Context ctx, Z3AST a) )
]

{ #category : #'as yet unclassified' }
LibZ3 >> getAstKind: ctx ast: a [
	"Return the kind of the given AST.
	 In Smalltalk, see ASTKind class."
	^ self halt; ffiCall: #( uint Z3_get_ast_kind (Z3Context ctx, Z3AST a) )
]

{ #category : #sorts }
LibZ3 >> getBVSortSize: ctx sort: aZ3Sort [
	"Return the size of the given bit-vector sort.
	The sort kind Z3_get_sort_kind(c, t) must be Z3_BV_SORT."
	^self halt; ffiCall: #( uint Z3_get_bv_sort_size (Z3Context ctx, Z3Sort aZ3Sort ) )
]

{ #category : #accessors }
LibZ3 >> getDeclName: ctx funcDecl: d [
	"Return the constant declaration name as a symbol."
	^ self halt; ffiCall: #( Z3Symbol  Z3_get_decl_name (Z3Context ctx, FuncDecl d) )
]

{ #category : #miscellaneous }
LibZ3 >> getFullVersion [
	^ self halt; ffiCall: #(String Z3_get_full_version( ) )
]

{ #category : #symbols }
LibZ3 >> getNumeralString: ctx ast: anAST [
	"Return numeral value, as a string of a numeric constant term.
	\pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST"
	^ self halt; ffiCall: #( String  Z3_get_numeral_string (Z3Context ctx, Z3AST anAST) )
]

{ #category : #accessors }
LibZ3 >> getSort: ctx ast: ast [
	"Return the sort of an AST node.
	The AST node must be a constant, application, numeral, bound variable, or quantifier."
	^ self halt; ffiCall: #( Z3Sort  Z3_get_sort (Z3Context ctx, Z3AST ast) )
]

{ #category : #accessors }
LibZ3 >> getSort: ctx astHandle: ast [
	"Return the sort of an AST node.
	The AST node must be a constant, application, numeral, bound variable, or quantifier."
	^ self halt; ffiCall: #( Z3Sort  Z3_get_sort (Z3Context ctx, void* ast) )
]

{ #category : #accessors }
LibZ3 >> getSortKind: ctx sort: t [
"Return the sort kind (e.g., array, tuple, int, bool, etc).

	   \sa Z3_sort_kind

	   def_API('', UINT, (_in(CONTEXT), _in(SORT)))
	*/
	Z3_sort_kind Z3_API Z3_get_sort_kind(Z3_context c, Z3_sort t);"
	^ self halt; ffiCall: #( uint  Z3_get_sort_kind (Z3Context ctx, Z3Sort t) )
]

{ #category : #accessors }
LibZ3 >> getSortName: ctx sort: aZ3Sort [
	"Return the sort of an AST node.
	The AST node must be a constant, application, numeral, bound variable, or quantifier."
	^ self halt; ffiCall: #( Z3Symbol  Z3_get_sort_name (Z3Context ctx, Z3Sort aZ3Sort) )
]

{ #category : #symbols }
LibZ3 >> getSymbolInt: ctx symbol: s [
	"Return the symbol int value."
	^ self halt; ffiCall: #( int  Z3_get_symbol_int (Z3Context ctx, Z3Symbol s) )

]

{ #category : #accessors }
LibZ3 >> getSymbolKind: ctx symbol: s [
	"Return Z3_INT_SYMBOL=0 if the symbol was constructed
	using Z3_mk_int_symbol, and Z3_STRING_SYMBOL=1 if the symbol
	was constructed using #Z3_mk_string_symbol."
	^ self halt; ffiCall: #( uint  Z3_get_symbol_kind (Z3Context ctx, Z3Symbol s) )
]

{ #category : #symbols }
LibZ3 >> getSymbolString: ctx symbol: s [
	"Return the symbol name.

	   \pre Z3_get_symbol_kind(s) == Z3_STRING_SYMBOL

	   \warning The returned buffer is statically allocated by Z3. It will
	   be automatically deallocated when #Z3_del_context is invoked.
	   So, the buffer is invalidated in the next call to \c Z3_get_symbol_string."
	^ self halt; ffiCall: #( String  Z3_get_symbol_string (Z3Context ctx, Z3Symbol s) )
]

{ #category : #miscellaneous }
LibZ3 >> getVersion: maj minor: min build: b revision: r [
	^ self halt; ffiCall: #(void Z3_get_version(pointer maj, pointer min, pointer b, pointer r) )
]

{ #category : #'global parameters' }
LibZ3 >> globalParam: paramId set: paramValue [
	"Set a global (or module) parameter.
	This setting is shared by all Z3 contexts.
	
	When a Z3 module is initialized it will use the value of these parameters
	when Z3_params objects are not provided.
	
	The name of parameter can be composed of characters [a-z][A-Z], digits [0-9], '-' and '_'.
	The character '.' is a delimiter (more later).
	
	The parameter names are case-insensitive. The character '-' should be viewed as an 'alias' for '_'.
	Thus, the following parameter names are considered equivalent: 'pp.decimal-precision' and 'PP.DECIMAL_PRECISION'.
	
	This function can be used to set parameters for a specific Z3 module.
	This can be done by using <module-name>.<parameter-name>.
	For example:
	Z3_global_param_set('pp.decimal', 'true')
	will set the parameter 'decimal' in the module 'pp' to true."
   ^ self halt; ffiCall: #( void Z3_global_param_set (String paramId, String paramValue) )

]

{ #category : #'ref-counting' }
LibZ3 >> incRef: ctx astVector: fs [
	self halt; ffiCall: #( void Z3_ast_vector_inc_ref (Z3Context ctx, Z3ASTVector  fs) )
]

{ #category : #'ref-counting' }
LibZ3 >> incRef: ctx model: model [
	self halt; ffiCall: #( void Z3_model_inc_ref (Z3Context ctx, Z3Model model) )
]

{ #category : #'ref-counting' }
LibZ3 >> incRef: ctx solver: solver [
	self halt; ffiCall: #( void Z3_solver_inc_ref (Z3Context ctx, Z3Solver solver) )
]

{ #category : #symbols }
LibZ3 >> isAsArray: ctx ast: a [
	^ self halt; ffiCall: #( bool  Z3_is_as_array (Z3Context ctx, Z3AST a) )
]

{ #category : #symbols }
LibZ3 >> isNumeral: ctx ast: anAST [
	^ self halt; ffiCall: #( bool  Z3_is_numeral_ast (Z3Context ctx, Z3AST anAST) )

]

{ #category : #'integers and reals' }
LibZ3 >> mkAdd: ctx numArgs: n args: args [
	"Create an AST node representing arg1 + ... + argN.
	The array args must have num_args elements.
	All arguments must have int or real sort.
	NB: The number of arguments must be greater than zero."
	^ self halt; ffiCall: #( Int Z3_mk_add (Z3Context ctx, int n, FFIExternalArray args) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkAnd: ctx numArgs: n args: args [
	"Create an AST node representing arg1 and ... and argN.
	 The array args must have num_args elements.
	 All arguments must have Boolean sort.
	 The number of arguments must be greater than zero."
	^ self halt; ffiCall: #( Bool Z3_mk_and (Z3Context ctx, int n, FFIExternalArray args) )
]

{ #category : #'constants and applications' }
LibZ3 >> mkApp: ctx func: decl arity: numArgs args: ffiArray [
	"Call Z3_mk_app with 0 args."
	^ self halt; ffiCall: #( void*  Z3_mk_app (Z3Context ctx, FuncDecl decl, uint numArgs, FFIExternalArray ffiArray) )
]

{ #category : #sorts }
LibZ3 >> mkArraySort: ctx domain: domain range: range [
	"Create an array type.
	We usually represent the array type as: [domain -> range].
	Arrays are usually used to model the heap/memory in software verification."
	^self halt; ffiCall: #( Z3Sort  Z3_mk_array_sort (Z3Context ctx, Z3Sort domain, Z3Sort range) )

]

{ #category : #'bit vectors' }
LibZ3 >> mkBV2Int: ctx t1: t1 isSigned: aBool [
	"CCreate an integer from the bit-vector argument \c t1.
	   If \c is_signed is false, then the bit-vector \c t1 is treated as unsigned.
	   So the result is non-negative
	   and in the range \ccode{[0..2^N-1]}, where N are the number of bits in \c t1.
	   If \c is_signed is true, \c t1 is treated as a signed bit-vector.


	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_bv2int', AST, (_in(CONTEXT), _in(AST), _in(BOOL)))
	*/
	Z3_ast Z3_API (Z3_context c,Z3_ast t1, bool is_signed);"
	^ self halt; ffiCall: #( void * Z3_mk_bv2int (void * ctx, void * t1, bool aBool) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVadd: ctx t1: t1 t2: t2 [
	"Standard two's complement addition.
	The nodes \c t1 and \c t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( BitVector Z3_mk_bvadd (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVand: ctx t1: t1 t2: t2 [
	"Bitwise and.
	 The nodes t1 and t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( BitVector Z3_mk_bvand (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVashr: ctx  t1: t1 t2: t2 [
	"Arithmetic shift right.

	   It is like logical shift right except that the most significant
	   bits of the result always copy the most significant bit of the
	   second argument.

	   The semantics of shift operations varies between environments. This
	   definition does not necessarily capture directly the semantics of the
	   programming language or assembly architecture you are modeling.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))

"
	^ self halt; ffiCall: #( void * Z3_mk_bvashr (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVmul: ctx t1: t1 t2: t2 [
	"Standard two's complement multiplication.

		The nodes \c t1 and \c t2 must have the same bit-vector sort.

		def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_bvmul(Z3_context c, Z3_ast t1, Z3_ast t2);"
	^ self halt; ffiCall: #( BitVector Z3_mk_bvmul (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVnand: ctx t1: t1 t2: t2 [
	"Bitwise nand.
	 The nodes t1 and t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( void * Z3_mk_bvnand (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVneg: ctx t1: t1 [
	"Standard two's complement unary minus.

	   The node \c t1 must have bit-vector sort."
	^ self halt; ffiCall: #( void * Z3_mk_bvneg (void * ctx, void * t1) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVnor: ctx t1: t1 t2: t2 [
	"Bitwise nor.
	 The nodes t1 and t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( void * Z3_mk_bvnor (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVnot: ctx t1: t1 [
	"Bitwise negation.

	   The node \c t1 must have a bit-vector sort."
	^ self halt; ffiCall: #( BitVector Z3_mk_bvnot (Z3Context ctx, BitVector t1) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVor: ctx t1: t1 t2: t2 [
	"Bitwise or.
	 The nodes t1 and t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( BitVector Z3_mk_bvxor (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVredand: ctx t1: t1 [
	"Take conjunction of bits in vector, return vector of length 1.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_bvredand', AST, (_in(CONTEXT), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1);
"
	^ self halt; ffiCall: #( void * Z3_mk_bvredand (void * ctx, void * t1) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVredor: ctx t1: t1 [
	"Take disjunction of bits in vector, return vector of length 1.

	   The node \c t1 must have a bit-vector sort.
"
	^ self halt; ffiCall: #( void * Z3_mk_bvredor (void * ctx, void * t1) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVsdiv: ctx t1: t1 t2: t2 [
	"Two's complement signed division.

		It is defined in the following way:

		- The \c floor of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 >= 0}.

		- The \c ceiling of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 < 0}.

		If \ccode{t2} is zero, then the result is undefined.

		The nodes \c t1 and \c t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( BitVector Z3_mk_bvsdiv (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVsge: ctx t1: t1 t2: t2 [
	"Two's complement signed greater than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvsge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1, Z3_ast t2);

"
	^ self halt; ffiCall: #( void * Z3_mk_bvsge (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVsgt: ctx t1: t1 t2: t2 [
	"Two's complement signed greater than.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_bvsgt(Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( void * Z3_mk_bvsgt (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVshl: ctx  t1: t1 t2: t2 [
	"Shift left.

	   It is equivalent to multiplication by \ccode{2^x} where \c x is the value of the
	   third argument.

	   NB. The semantics of shift operations varies between environments. This
	   definition does not necessarily capture directly the semantics of the
	   programming language or assembly architecture you are modeling.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvshl', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1, Z3_ast t2);

"
	^ self halt; ffiCall: #( BitVector Z3_mk_bvshl (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVsle: ctx t1: t1 t2: t2 [
	"Two's complement signed less than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvsle', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1, Z3_ast t2);"
	^ self halt; ffiCall: #( Bool  Z3_mk_bvsle (Z3Context ctx, Int t1, Int t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVslt: ctx t1: t1 t2: t2 [
	"Two's complement signed less than.

	   It abbreviates:
	   \code
		(or (and (= (extract[|m-1|:|m-1|] t1) bit1)
				(= (extract[|m-1|:|m-1|] t2) bit0))
			(and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
				(bvult t1 t2)))
	   \endcode

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_bvslt(Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( Bool  Z3_mk_bvslt (Z3Context ctx, #BitVector t1, #BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVsmod: ctx t1: t1 t2: t2 [
	"Two's complement signed remainder (sign follows divisor).

	   If \ccode{t2} is zero, then the result is undefined.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   \sa Z3_mk_bvsrem

	   def_API('Z3_mk_bvsmod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( void * Z3_mk_bvsmod (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVsrem: ctx t1: t1 t2: t2 [
	"Two's complement signed remainder (sign follows dividend).

	   It is defined as \ccode{t1 - (t1 /s t2) * t2}, where \ccode{/s} represents signed division.
	   The most significant bit (sign) of the result is equal to the most significant bit of \c t1.

	   If \ccode{t2} is zero, then the result is undefined.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
"
	^ self halt; ffiCall: #( void * Z3_mk_bvsrem (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVsub: ctx t1: t1 t2: t2 [
	"Standard two's complement subtraction.

		The nodes \c t1 and \c t2 must have the same bit-vector sort.

		def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_bvsub(Z3_context c, Z3_ast t1, Z3_ast t2);"
	^ self halt; ffiCall: #(#BitVector  Z3_mk_bvsub (Z3Context ctx, #BitVector t1, #BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVudiv: ctx t1: t1 t2: t2 [
	"Unsigned division.
	
	It is defined as the floor of t1/t2 if t2 is
	different from zero. If t2 is zero, then the result is undefined.
	The nodes t1 and t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( BitVector Z3_mk_bvudiv (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVuge: ctx t1: t1 t2: t2 [
	"Unsigned greater than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_bvuge(Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( void * Z3_mk_bvuge (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVugt: ctx t1: t1 t2: t2 [
	"Unsigned greater than.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvugt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1, Z3_ast t2);

"
	^ self halt; ffiCall: #( void * Z3_mk_bvugt (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVule: ctx t1: t1 t2: t2 [
	"Unsigned less than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_bvule(Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( void * Z3_mk_bvule (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVult: ctx t1: t1 t2: t2 [
	"Unsigned less than.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvult', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( void * Z3_mk_bvult (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVurem: ctx t1: t1 t2: t2 [
	"Unsigned remainder.

	   It is defined as \ccode{t1 - (t1 /u t2) * t2}, where \ccode{/u} represents unsigned division.

	   If \ccode{t2} is zero, then the result is undefined.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_bvurem(Z3_context c, Z3_ast t1, Z3_ast t2);"
	^ self halt; ffiCall: #( void * Z3_mk_bvurem (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVxnor: ctx t1: t1 t2: t2 [
	"Bitwise xnor.
	 The nodes t1 and t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( void * Z3_mk_bxvnor (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkBVxor: ctx t1: t1 t2: t2 [
	"Bitwise xor.
	 The nodes t1 and t2 must have the same bit-vector sort."
	^ self halt; ffiCall: #( void * Z3_mk_bvxor (void * ctx, void * t1, void * t2) )
]

{ #category : #sorts }
LibZ3 >> mkBoolSort: ctx [
	"Create the Boolean type.
	 This type is used to create propositional variables and predicates."
	^ self halt; ffiCall: #( Z3Sort  Z3_mk_bool_sort (Z3Context ctx) )
]

{ #category : #quantifiers }
LibZ3 >> mkBound: ctx index: anUnsigned sort: ty [
	"Create a bound variable.

	Bound variables are indexed by de-Bruijn indices.
	It is perhaps easiest to explain the meaning of de-Bruijn indices
	by indicating the compilation process from non-de-Bruijn formulas to de-Bruijn format.

	   abs(forall (x1) phi) = forall (x1) abs1(phi, x1, 0)
	   abs(forall (x1, x2) phi) = abs(forall (x1) abs(forall (x2) phi))
	   abs1(x, x, n) = b_n
	   abs1(y, x, n) = y
	   abs1(f(t1,...,tn), x, n) = f(abs1(t1,x,n), ..., abs1(tn,x,n))
	   abs1(forall (x1) phi, x, n) = forall (x1) (abs1(phi, x, n+1))

	The last line is significant: the index of a bound variable is different depending
	on the scope in which it appears. The deeper x appears, the higher is its index."
	^self halt; ffiCall: #( void*  Z3_mk_bound (Z3Context ctx, uint anUnsigned, Z3Sort ty) )
]

{ #category : #sorts }
LibZ3 >> mkBvSort: ctx size: sz [
	"Create a bit-vector type of the given size.
	 This type can also be seen as a machine integer.
	 NB: The size of the bit-vector type must be greater than zero."
	^ self halt; ffiCall: #( Z3Sort Z3_mk_bv_sort (Z3Context ctx, uint sz) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkConcat: ctx t1: t1 t2: t2 [
	"Concatenate the given bit-vectors."
	^ self halt; ffiCall: #( BitVector Z3_mk_concat (Z3Context ctx, BitVector t1, BitVector t2) )
]

{ #category : #configuration }
LibZ3 >> mkConfig [
	^ self halt; ffiCall: #(Z3Config Z3_mk_config () )
]

{ #category : #'constants and applications' }
LibZ3 >> mkConst: ctx symbol: s sort: ty [
	"Declare and create a constant.
	 Answers a Z3_ast pointer.
	 Z3 says this function is a shorthand for:
	   Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
	   Z3_ast n            = Z3_mk_app(c, d, 0, 0);"
	^ self halt; ffiCall: #( void*  Z3_mk_const (Z3Context ctx, Z3Symbol s, Z3Sort ty) )
]

{ #category : #sorts }
LibZ3 >> mkConstructor: ctx name: name recognizer: recognizer uint: numFields fieldNames: fieldNames sorts: sorts sortRefs: refs [
	"Create a constructor.
	Args:
	- ctx: logical context.
	- name constructor name.
	- recognizer name of recognizer function.
	- num_fields number of fields in constructor.
	- field_names names of the constructor fields.
	- sorts field sorts, 0 if the field sort refers to a recursive sort.
	- sort_refs reference to datatype sort that is an argument to the constructor;
	  if the corresponding sort reference is 0, then the value in sort_refs should
	  be an index referring to one of the recursive datatypes that is declared."
	self shouldBeImplemented .
	^ self halt; ffiCall: #( Z3Sort Z3_mk_int_sort (Z3Context ctx) )
]

{ #category : #context }
LibZ3 >> mkContext: cfg [
	^ self halt; ffiCall: #(Z3Context  Z3_mk_context (Z3Config cfg) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkDistinct: ctx numArgs: n args: args [
	"Create an AST node representing distinct(arg1, ... argN).
	   The \c distinct construct is used for declaring the arguments pairwise distinct.
	   That is, \ccode{Forall 0 <= i < j < num_args. not args[i] = args[j]}.

	   All arguments must have the same sort.

	   \remark The number of arguments of a distinct construct must be greater than one."
	^ self halt; ffiCall: #( void * Z3_mk_distinct (void * ctx, int n, FFIExternalArray args) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkDiv: ctx dividend: l divisor: r [
	"Create an AST node representing \ccode{arg1 div arg2}.

	   The arguments must either both have int type or both have real type.
	   If the arguments have int type, then the result type is an int type, otherwise the
	   the result type is real.

	   def_API('Z3_mk_div', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_div(Z3_context c, Z3_ast arg1, Z3_ast arg2);"
	^ self halt; ffiCall: #( Int Z3_mk_div (Z3Context ctx, Z3AST l, Z3AST r) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkEq: ctx l: l r: r [
	"Create an AST node representing l = r.
	 The nodes l and r must have the same type."
	^ self halt; ffiCall: #( Bool Z3_mk_eq (Z3Context ctx, Z3AST l, Z3AST r) )
]

{ #category : #quantifiers }
LibZ3 >> mkExistsConst: ctx numBound: nb bound: bound body: body [
	"Create an existential quantifier using a list of constants
	 that will form the set of bound variables.
	 This is the form without patterns."
	| null |
	null := ExternalAddress new.
	^ self mkExistsConst: ctx weight: 0 numBound: nb bound: bound numPatterns: 0 patterns: null body: body
]

{ #category : #quantifiers }
LibZ3 >> mkExistsConst: ctx weight: w numBound: nb bound: bound numPatterns: np patterns: p body: body [
	"Create aexistential quantifier using a list of constants
	 that will form the set of bound variables."
	^ self halt; ffiCall: #( void* Z3_mk_exists_const (Z3Context ctx, int w, int nb, FFIExternalArray bound, int np, void* p, Z3AST body) )

]

{ #category : #'bit vectors' }
LibZ3 >> mkExtRotateLeft: ctx  t1: t1 t2: t2 [
	"Rotate bits of \c t1 to the left \c t2 times.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_ext_rotate_left(Z3_context c, Z3_ast t1, Z3_ast t2);

"
	^ self halt; ffiCall: #( void * Z3_mk_ext_rotate_left (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkExtRotateRight: ctx  t1: t1 t2: t2 [
	"Rotate bits of \c t1 to the right \c t2 times.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_ext_rotate_right', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( void * Z3_mk_ext_rotate_right (void * ctx, void * t1, void * t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkExtract: ctx high: h low: l t1: t1 [
	"Extract the bits \c high down to \c low from a bit-vector of
	size \c m to yield a new bit-vector of size \c n, where \ccode{n = high - low + 1}.
	The node \c t1 must have a bit-vector sort."
	^ self halt; ffiCall: #( BitVector Z3_mk_extract (Z3Context ctx, uint h, uint l, BitVector t1) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkFalse: ctx [
	"Create an AST node representing false."
	^ self halt; ffiCall: #( void* Z3_mk_false (Z3Context ctx) )
]

{ #category : #quantifiers }
LibZ3 >> mkForAllConst: ctx numBound: nb bound: bound body: body [
	"Create a universal quantifier using a list of constants that will form the set of bound variables.
	This is the form without patterns."

	| null |
	null := ExternalAddress new.
	^ self mkForAllConst: ctx weight: 0 numBound: nb bound: bound numPatterns: 0 patterns: null body: body
]

{ #category : #quantifiers }
LibZ3 >> mkForAllConst: ctx weight: w numBound: nb bound: bound numPatterns: np patterns: p body: body [
	"Create a universal quantifier using a list of constants that will form the set of bound variables."
	^ self halt; ffiCall: #( void* Z3_mk_forall_const (Z3Context ctx, int w, int nb, FFIExternalArray bound, int np, void* p, Z3AST body) )

]

{ #category : #'constants and applications' }
LibZ3 >> mkFuncDecl: ctx symbol: s domainSize: nDim domain: anFFIExternalArray range: rangeSort [
	"Declare a constant or function.
	Arguments:
		ctx logical context.
		s name of the constant or function.
		domainSize number of arguments. It is 0 when declaring a constant.
		domain array containing the sort of each argument.
			   The array must contain domain_size elements. It is 0 when declaring a constant.
		rangeSort sort of the constant or the return sort of the function.
	After declaring a constant or function, the function Z3_mk_app can be used
	to create a constant or function application.
	See also: Z3_mk_app"
	^ self halt; ffiCall: #( FuncDecl  Z3_mk_func_decl (Z3Context ctx, Z3Symbol s, 
		uint nDim, FFIExternalArray anFFIExternalArray,
		Z3Sort rangeSort) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkGe: ctx t1: t1 t2: t2 [
	"Create greater than or equal to.
	The nodes t1 and t2 must have the same sort, and must be int or real."
	^ self halt; ffiCall: #(Z3AST Z3_mk_ge (Z3Context ctx, Z3AST t1, Z3AST t2) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkGt: ctx t1: t1 t2: t2 [
	"Create greater than.
	The nodes t1 and t2 must have the same sort, and must be int or real."
	^ self halt; ffiCall: #(Z3AST Z3_mk_gt (Z3Context ctx, Z3AST t1, Z3AST t2) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkITE: ctx t1: t1 t2: t2 t3: t3 [
	"Create an AST node representing an if-then-else: ite(t1, t2, t3).
	The node t1 must have Boolean sort;
	t2 and t3 must have the same sort.
	The sort of the new node is equal to the sort of t2 and t3."
	^self halt; ffiCall: #( void* Z3_mk_ite (Z3Context ctx, Z3AST t1, Z3AST t2, Z3AST t3) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkIff: ctx t1: t1 t2: t2 [
	"Create an AST node representing \ccode{t1 iff t2}.

	   The nodes \c t1 and \c t2 must have Boolean sort.

	   def_API('Z3_mk_iff', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_iff(Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( Bool  Z3_mk_iff (Z3Context ctx, Bool t1, Bool t2) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkImplies: ctx t1: t1 t2: t2 [
	"Create an AST node representing
		t1 => t2.
	The nodes t1 and t2 must have Boolean sort."
	^ self halt; ffiCall: #( Bool Z3_mk_implies (Z3Context ctx, Bool t1, Bool t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkInt2BV: ctx length: n t1: t1 [
	"Create an \c n bit bit-vector from the integer argument \c t1.

	   The resulting bit-vector has \c n bits, where the i'th bit (counting
	   from 0 to \c n-1) is 1 if \c (t1 div 2^i) mod 2 is 1.       

	   The node \c t1 must have integer sort.

	   def_API('', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_int2bv(Z3_context c, unsigned n, Z3_ast t1);"
	^ self halt; ffiCall: #( void * Z3_mk_int2bv (void * ctx, uint n, void * t1) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkInt2real: ctx t1: t1 [
	"Coerce an integer to a real.

		There is also a converse operation exposed.
		It follows the semantics prescribed by the SMT-LIB standard.

		You can take the floor of a real by
		creating an auxiliary integer constant \c k and
		and asserting \ccode{mk_int2real(k) <= t1 < mk_int2real(k)+1}.

		The node \c t1 must have sort integer.

		\sa Z3_mk_real2int
		\sa Z3_mk_is_int

		def_API('', AST, (_in(CONTEXT), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_int2real(Z3_context c, Z3_ast t1);"
	^ self halt; ffiCall: #( void * Z3_mk_int2real (void * ctx, void * t1) )
]

{ #category : #sorts }
LibZ3 >> mkInt: ctx int: v sort: ty [
	"Create a numeral of an int, bit-vector, or finite-domain sort.
	This function can be used to create numerals that fit in a machine integer.
	It is slightly faster than Z3_mk_numeral since it is not necessary to parse a string.

	   def_API('Z3_mk_int', AST, (_in(CONTEXT), _in(INT), _in(SORT)))
	*/
	Z3_ast Z3_API Z3_mk_int(Z3_context c, int v, Z3_sort ty)"
	^ self halt; ffiCall: #( Int Z3_mk_int (Z3Context ctx, int v, Z3Sort ty ) )
]

{ #category : #sorts }
LibZ3 >> mkIntSort: ctx [
	"Create the integer type.
	This type is not the int type found in programming languages.
	A machine integer can be represented using bit-vectors. The function
	Z3_mk_bv_sort creates a bit-vector type."
	^ self halt; ffiCall: #( Z3Sort Z3_mk_int_sort (Z3Context ctx) )
]

{ #category : #symbols }
LibZ3 >> mkIntSymbol: ctx int: i [
	"Create a Z3 symbol using an int.
	 Symbols are used to name several term and type constructors.
	 NB. In Z3 itself, not all integers can be passed to this function.
	 The legal range of unsigned integers is 0 to 2^30-1."
	^ self halt; ffiCall: #(Z3Symbol  Z3_mk_int_symbol (Z3Context ctx, int i) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkLe: ctx t1: t1 t2: t2 [
	"Create less than or equal to.
	The nodes t1 and t2 must have the same sort, and must be int or real."
	^ self halt; ffiCall: #(Z3AST Z3_mk_le (Z3Context ctx, Z3AST t1, Z3AST t2) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkLt: ctx t1: t1 t2: t2 [
	"Create less than.
	The nodes t1 and t2 must have the same sort, and must be int or real."
	^ self halt; ffiCall: #(Z3AST Z3_mk_lt (Z3Context ctx, Z3AST t1, Z3AST t2) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkMod: ctx arg1: arg1 arg2: arg2 [
	"Create an AST node representing \ccode{arg1 mod arg2}.

	   The arguments must have int type.

	   def_API('Z3_mk_mod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, Z3_ast arg1, Z3_ast arg2);
"
	^ self halt; ffiCall: #( void * Z3_mk_mod (void * ctx, void * arg1, void * arg2) )
]

{ #category : #models }
LibZ3 >> mkModel: ctx [
	"Create a fresh model object. It has reference count 0."
	^ self halt; ffiCall: #( Z3Model  Z3_mk_model(Z3Context ctx) ).
]

{ #category : #'integers and reals' }
LibZ3 >> mkMul: ctx numArgs: n args: args [
	"Create an AST node representing \ccode{args[0] * ... * args[num_args-1]}.

	   The array \c args must have \c num_args elements.
	   All arguments must have int or real sort.

	   \remark Z3 has limited support for non-linear arithmetic.
	   \remark The number of arguments must be greater than zero.

	   def_API('Z3_mk_mul', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	*/
	Z3_ast Z3_API Z3_mk_mul(Z3_context c, unsigned num_args, Z3_ast const args[]);"
	^ self halt; ffiCall: #( Int Z3_mk_mul (Z3Context ctx, int n, FFIExternalArray args) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkNot: ctx ast: a [
	"Create an AST node representing \ccode{t1 iff t2}.

	   The nodes \c t1 and \c t2 must have Boolean sort.

	   def_API('Z3_mk_iff', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_iff(Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( Bool Z3_mk_not (Z3Context ctx, Bool a) )
]

{ #category : #numerals }
LibZ3 >> mkNumeral: ctx numeral: aString type: aSort [
	"Create a numeral of a given sort.
	Arguments:
	 * aString - represents the numeral value in decimal notation.
				 The string may be of the form `[num]*[.[num]*][E[+|-][num]+]`.
				 If the given sort is a real, then the numeral can be a rational,
				 that is, a string of the form `[num]* / [num]*` .
	 * ty - the sort of the numeral.
			In the current implementation, the given sort can be an int, real,
			finite-domain, or bit-vectors of arbitrary size."
	^ self halt; ffiCall: #( void*  Z3_mk_numeral (Z3Context ctx, String aString, Z3Sort aSort) )	
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkOr: ctx numArgs: n args: args [

	^ self halt; ffiCall: #( Bool Z3_mk_or (Z3Context ctx, int n, FFIExternalArray args) )
]

{ #category : #parameters }
LibZ3 >> mkParams: ctx [
	"Create an empty parameter set.
	Starting at Z3 4.0, parameter sets are used to configure many components such as:
	simplifiers, tactics, solvers, etc.
	
	Reference counting must be used to manage parameter sets,
	even when the Z3_context was created using #Z3_mk_context instead of #Z3_mk_context_rc."
	
	^ self halt; ffiCall: #(Z3ParameterSet  Z3_mk_params (Z3Context ctx) )
]

{ #category : #quantifiers }
LibZ3 >> mkPattern: ctx numPatterns: anUnsigned terms: anAstArray [
self shouldBeImplemented 
]

{ #category : #'integers and reals' }
LibZ3 >> mkPower: ctx arg1: arg1 arg2: arg2 [
	"Create an AST node representing \ccode{arg1 ^ arg2}.

	   The arguments must have int or real type.

	   def_API('Z3_mk_power', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_power(Z3_context c, Z3_ast arg1, Z3_ast arg2);"
	^ self halt; ffiCall: #( void * Z3_mk_power (void * ctx, void * arg1, void * arg2) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkReal2Int: ctx t1: t1 [
	"Coerce a real to an integer.

		The semantics of this function follows the SMT-LIB standard
		for the function to_int"
	^ self halt; ffiCall: #( void * Z3_mk_real2int (void * ctx, void * t1) )
]

{ #category : #sorts }
LibZ3 >> mkRealSort: ctx [
	"Create the real type.
	Note that this type is not a floating point number."
	^ self halt; ffiCall: #( Z3Sort Z3_mk_real_sort (Z3Context ctx) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkRem: ctx arg1: arg1 arg2: arg2 [

	^ self halt; ffiCall: #( void * Z3_mk_rem (void * ctx, void * arg1, void * arg2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkRepeat: ctx i: i t1: t1 [
	"Repeat the given bit-vector up length i.
	The node t1 must have a bit-vector sort."
	^self halt; ffiCall: #( BitVector Z3_mk_repeat (Z3Context ctx, uint i, BitVector t1) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkRotateLeft: ctx i: i t1: t1 [
	"Rotate bits of t1 to the left i times.
	The node t1 must have a bit-vector sort."
	^self halt; ffiCall: #(Z3AST Z3_mk_rotate_left (Z3Context ctx, uint i, Z3AST t1) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkRotateRight: ctx i: i t1: t1 [
	"Rotate bits of t1 to the right i times.
	The node t1 must have a bit-vector sort."
	^self halt; ffiCall: #(Z3AST Z3_mk_rotate_right (Z3Context ctx, uint i, Z3AST t1) )
]

{ #category : #arrays }
LibZ3 >> mkSelect: ctx a: a i: i [
	"Array read.
	   The argument \c a is the array and \c i is the index of the array that gets read.

	   The node \c a must have an array sort \ccode{[domain -> range]},
	   and \c i must have the sort \c domain.
	   The sort of the result is \c range.

	   \sa Z3_mk_array_sort
	   \sa Z3_mk_store

	   def_API('', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_select(Z3_context c, Z3_ast a, Z3_ast i);"
	^ self halt; ffiCall: #( void* Z3_mk_select (Z3Context ctx, Z3AST a, Z3AST i) )
]

{ #category : #sets }
LibZ3 >> mkSet: ctx sort: ty [
	"Create Set type."
	^ self halt; ffiCall: #(void * Z3_mk_set_sort (void * ctx, void * ty) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkSignExtend: ctx i: i t1: t1 [
	"Sign-extend the given bit-vector to the (signed) equivalent bit-vector of
	 size {m+i} where m is the size of the given bit-vector.
	 The node t1 must have a bit-vector sort."
	^ self halt; ffiCall: #( void * Z3_mk_sign_ext (void * ctx, uint i, void * t1) )
]

{ #category : #solvers }
LibZ3 >> mkSolver: ctx [
	"Create a new solver. This solver is a 'combined solver' (see
	   combined_solver module) that internally uses a non-incremental (solver1) and an
	   incremental solver (solver2). This combined solver changes its behaviour based
	   on how it is used and how its parameters are set.

	   If the solver is used in a non incremental way (i.e. no calls to
	   #Z3_solver_push() or #Z3_solver_pop(), and no calls to
	   #Z3_solver_assert() or #Z3_solver_assert_and_track() after checking
	   satisfiability without an intervening #Z3_solver_reset()) then solver1
	   will be used. This solver will apply Z3's 'default' tactic.

	   The 'default' tactic will attempt to probe the logic used by the
	   assertions and will apply a specialized tactic if one is supported.
	   Otherwise the general `(and-then simplify smt)` tactic will be used.

	   If the solver is used in an incremental way then the combined solver
	   will switch to using solver2 (which behaves similarly to the general
	   'smt' tactic).

	   Note however it is possible to set the `solver2_timeout`,
	   `solver2_unknown`, and `ignore_solver1` parameters of the combined
	   solver to change its behaviour.

	   The function #Z3_solver_get_model retrieves a model if the
	   assertions is satisfiable (i.e., the result is \c
	   Z3_L_TRUE) and model construction is enabled.
	   The function #Z3_solver_get_model can also be used even
	   if the result is \c Z3_L_UNDEF, but the returned model
	   is not guaranteed to satisfy quantified assertions.

	   \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
	   Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

"
	^ self halt; ffiCall: #(Z3Solver Z3_mk_solver (Z3Context ctx) )
]

{ #category : #arrays }
LibZ3 >> mkStore: ctx a: a i: i v: v [
	"Array update.

	   The node \c a must have an array sort \ccode{[domain -> range]}, \c i must have sort \c domain,
	   \c v must have sort range. The sort of the result is \ccode{[domain -> range]}.
	   The semantics of this function is given by the theory of arrays described in the SMT-LIB
	   standard. See http://smtlib.org for more details.
	   The result of this function is an array that is equal to \c a (with respect to \c select)
	   on all indices except for \c i, where it maps to \c v (and the \c select of \c a with
	   respect to \c i may be a different value)."
	^ self halt; ffiCall: #( void* Z3_mk_store (Z3Context ctx, Z3AST a, Z3AST i, Z3AST v) )
]

{ #category : #symbols }
LibZ3 >> mkStringSymbol: ctx string: s [
	"Create a Z3 symbol using a Smalltalk String.
	Symbols are used to name several term and type constructors."
	^ self halt; ffiCall: #(Z3Symbol  Z3_mk_string_symbol (Z3Context ctx, String s) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkSub: ctx numArgs: n args: args [
	"Create an AST node representing \ccode{args[0] - ... - args[num_args - 1]}.

	   The array \c args must have \c num_args elements.
	   All arguments must have int or real sort.

	   \remark The number of arguments must be greater than zero.

	   def_API('Z3_mk_sub', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	*/
	Z3_ast Z3_API Z3_mk_sub(Z3_context c, unsigned num_args, Z3_ast const args[]);"
	^ self halt; ffiCall: #( Int Z3_mk_sub (Z3Context ctx, int n, FFIExternalArray args) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkTrue: ctx [
	"Create an AST node representing true."
	^ self halt; ffiCall: #( void * Z3_mk_true (Z3Context ctx) )
]

{ #category : #'integers and reals' }
LibZ3 >> mkUnaryMinus: ctx arg: a [
	"Create an AST node representing \ccode{- arg}.

	   The arguments must have int or real type.

	   def_API('Z3_mk_unary_minus', AST, (_in(CONTEXT), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_unary_minus(Z3_context c, Z3_ast arg);
"
	^ self halt; ffiCall: #( void * Z3_mk_unary_minus (void * ctx, void * a) )
]

{ #category : #sorts }
LibZ3 >> mkUninterpretedSort: ctx symbol: s [
	"Create a free (uninterpreted) type using the given name (symbol).
	Two free types are considered the same iff the have the same name."
	^ self halt; ffiCall: #( Z3Sort Z3_mk_uninterpreted_sort (Z3Context ctx, Z3Symbol s ) )
]

{ #category : #'propositional logic and equality' }
LibZ3 >> mkXor: ctx t1: t1 t2: t2 [
	"Create an AST node representing \ccode{t1 xor t2}.

	   The nodes \c t1 and \c t2 must have Boolean sort.

	   def_API('Z3_mk_xor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	*/
	Z3_ast Z3_API Z3_mk_xor(Z3_context c, Z3_ast t1, Z3_ast t2);
"
	^ self halt; ffiCall: #( Bool Z3_mk_xor (Z3Context ctx, Bool t1, Bool t2) )
]

{ #category : #'bit vectors' }
LibZ3 >> mkZeroExtend: ctx i: i t1: t1 [
	"Extend the given bit-vector with zeros to the (unsigned) equivalent
	   bit-vector of size \ccode{m+i}, where \c m is the size of the
	   given bit-vector.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_zero_ext', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	*/
	Z3_ast Z3_API (Z3_context c, unsigned i, Z3_ast t1);
"
	^ self halt; ffiCall: #( void * Z3_mk_zero_ext (void * ctx, uint i, void * t1) )
]

{ #category : #models }
LibZ3 >> modelEval: ctx model: m ast: t completion: aBool dest: v [
	"Evaluate the AST node t in the given model.
	Return \c true if succeeded, and store the result in v.

	   If \c model_completion is \c true, then Z3 will assign an interpretation for any constant or function that does
	   not have an interpretation in \c m. These constants and functions were essentially don't cares.

	   If \c model_completion is \c false, then Z3 will not assign interpretations to constants for functions that do
	   not have interpretations in \c m. Evaluation behaves as the identify function in this case.

	   The evaluation may fail for the following reasons:

	   - \c t contains a quantifier.

	   - the model \c m is partial, that is, it doesn't have a complete interpretation for uninterpreted functions.
	   That is, the option \ccode{MODEL_PARTIAL=true} was used.

	   - \c t is type incorrect.

	   - \c Z3_interrupt was invoked during evaluation.
"
	^ self halt; ffiCall: #( bool  Z3_model_eval (Z3Context ctx, Z3Model m, Z3AST t, bool aBool, void * v) )	
]

{ #category : #models }
LibZ3 >> modelGetConstDecl: ctx model: m index: j [
	"Return the i-th constant in the given model."
	^ self halt; ffiCall: #( FuncDecl  Z3_model_get_const_decl(Z3Context ctx, Z3Model m, uint j) )	
]

{ #category : #models }
LibZ3 >> modelGetConstInterp: ctx model: m funcDecl: aFuncDecl [ 
	"Return the i-th constant in the given model."
	^ self halt; ffiCall: #( void*  Z3_model_get_const_interp(Z3Context ctx, Z3Model m, FuncDecl aFuncDecl ) )	
]

{ #category : #models }
LibZ3 >> modelGetConstInterp: ctx model: m index: j [
	"Return the i-th constant in the given model."
	^ self halt; ffiCall: #( FuncDecl  Z3_model_get_const_decl(Z3Context ctx, Z3Model m, uint j) )	
]

{ #category : #models }
LibZ3 >> modelGetNumConsts: ctx model: m [
	"Return the number of constants assigned by the given model.

	   \sa Z3_model_get_const_decl
"
	^ self halt; ffiCall: #( uint  Z3_model_get_num_consts(Z3Context ctx, Z3Model m) )	
]

{ #category : #models }
LibZ3 >> modelIncRef: ctx model: m [
	"Increment the reference counter of the given model."
	^ self halt; ffiCall: #( void  Z3_model_inc_ref(Z3Context ctx, Z3Model m) ).
]

{ #category : #models }
LibZ3 >> modelToString: ctx model: m [

"Convert the given model into a string.

	   \warning The result buffer is statically allocated by Z3. It will
	   be automatically deallocated when #Z3_del_context is invoked.
	   So, the buffer is invalidated in the next call to \c Z3_model_to_string."
	^ self halt; ffiCall: #( String  Z3_model_to_string (Z3Context ctx, Z3Model m) )	
]

{ #category : #'interaction logging' }
LibZ3 >> openLog: filename [
	"Log interaction to a file.

	   extra_API('Z3_open_log', INT, (_in(STRING),))
	*/
	bool Z3_API Z3_open_log(Z3_string filename);
"
]

{ #category : #parameters }
LibZ3 >> paramsDecRef: ctx p: p [
	"Decrement the reference counter of the given parameter set."
	^ self halt; ffiCall: #( void Z3_params_inc_ref (void * c, void * p) )
]

{ #category : #parameters }
LibZ3 >> paramsIncRef: ctx p: p [
	"Increment the reference counter of the given parameter set."
	^ self halt; ffiCall: #( void Z3_params_inc_ref (void * c, void * p) )
]

{ #category : #parameters }
LibZ3 >> paramsSetUint: ctx p: p symbol: k unsigned: v [
	"Decrement the reference counter of the given parameter set."
	^ self halt; ffiCall: #( void  Z3_params_inc_ref (Z3Context ctx, Z3ParameterSet p, Z3Symbol k, uint v) )
]

{ #category : #parameters }
LibZ3 >> paramsToString: ctx p: p [
	"Convert a parameter set into a string.
	This function is mainly used for printing the contents of a parameter set."
	^ self halt; ffiCall: #( String  Z3_params_to_string (Z3Context ctx, Z3ParameterSet p) )
]

{ #category : #'parser interface' }
LibZ3 >> parseSmtlib2: ctx string: str unsigned: numSorts z3symbols: sortNames z3sorts: sorts unsigned: numDecls z3symbols: declNames funcDecls: decls [
	"Parse the given string using the SMT-LIB2 parser.
	It returns a formula comprising of the conjunction of assertions in the scope
	(up to push/pop) at the end of the string."
	^ self halt; ffiCall: #(Z3ASTVector  Z3_parse_smtlib2_string (Z3Context ctx, String str,
		uint numSorts, void* sortNames, void* sorts, uint numDecls, void* declNames, void* decls) )
]

{ #category : #'string conversion' }
LibZ3 >> setAstPrintMode: ctx mode: anInt [
	"Select mode for the format used for pretty-printing AST nodes.

	   The default mode for pretty printing AST nodes is to produce
	   SMT-LIB style output where common subexpressions are printed
	   at each occurrence. The mode is called \c Z3_PRINT_SMTLIB_FULL.
	   To print shared common subexpressions only once,
	   use the \c Z3_PRINT_LOW_LEVEL mode.
	   To print in way that conforms to SMT-LIB standards and uses let
	   expressions to share common sub-expressions use \c Z3_PRINT_SMTLIB2_COMPLIANT."
	^ self halt; ffiCall: #(void Z3_set_ast_print_mode (void * ctx, int anInt) )
]

{ #category : #simplification }
LibZ3 >> simplify: ctx ast: ast [
	"Interface to simplifier.
	Provides an interface to the AST simplifier used by Z3.
	It returns an AST object which is equal to the argument.
	The returned AST is simplified using algebraic simplification rules,
	such as constant propagation (propagating true/false over logical connectives).

	Implementation note: for now, there are special versions of this
	method for simplifications of each sort: apparently simplifying
	a bitvector can only yield a bitvector, etc."
	^ self halt; ffiCall: #( void*  Z3_simplify (Z3Context ctx, Z3AST ast) ).
]

{ #category : #solvers }
LibZ3 >> solverAssert: ctx solver: s ast: a [
	"Assert a constraint into the solver.

	   The functions #Z3_solver_check and #Z3_solver_check_assumptions should be
	   used to check whether the logical context is consistent or not.

	   \sa Z3_solver_assert_and_track
	   \sa Z3_solver_reset

	   def_API('Z3_solver_assert', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST)))
	*/
	void Z3_API Z3_solver_assert(Z3_context c, Z3_solver s, Z3_ast a);"
	^ self halt; ffiCall: #( void  Z3_solver_assert (Z3Context ctx, Z3Solver s, Bool a) )
]

{ #category : #solvers }
LibZ3 >> solverCheck: ctx solver: s [
	"
	Check whether the assertions in a given solver are consistent or not.

	   The function #Z3_solver_get_model retrieves a model if the
	   assertions is satisfiable (i.e., the result is \c
	   Z3_L_TRUE) and model construction is enabled.
	   Note that if the call returns \c Z3_L_UNDEF, Z3 does not
	   ensure that calls to #Z3_solver_get_model succeed and any models
	   produced in this case are not guaranteed to satisfy the assertions.

	   The function #Z3_solver_get_proof retrieves a proof if proof
	   generation was enabled when the context was created, and the
	   assertions are unsatisfiable (i.e., the result is \c Z3_L_FALSE).

	   \sa Z3_solver_check_assumptions

	   def_API('Z3_solver_check', INT, (_in(CONTEXT), _in(SOLVER)))
	*/
	Z3_lbool Z3_API (Z3_context c, Z3_solver s);

	"
	^ self halt; ffiCall: #( int Z3_solver_check (Z3Context ctx, Z3Solver s) )
]

{ #category : #solvers }
LibZ3 >> solverGetModel: ctx solver: s [
	"Retrieve the model for the last #Z3_solver_check or #Z3_solver_check_assumptions

	   The error handler is invoked if a model is not available because
	   the commands above were not invoked for the given solver, or if the result was \c Z3_L_FALSE."
	^self halt; ffiCall: #( Z3Model  Z3_solver_get_model (Z3Context ctx, Z3Solver s) ).
]

{ #category : #solvers }
LibZ3 >> solverGetNumScopes: ctx solver: s [
	"Return the number of backtracking points."
	^self halt; ffiCall: #( uint  Z3_solver_get_num_scopes (Z3Context ctx, Z3Solver s) ).
]

{ #category : #solvers }
LibZ3 >> solverPop: ctx solver: s n: n [
	"Backtrack n backtracking points."
	^self halt; ffiCall: #( void  Z3_solver_pop (Z3Context ctx, Z3Solver s, uint n) ).
]

{ #category : #solvers }
LibZ3 >> solverPush: ctx solver: s [
	"Create a backtracking point.
	 The solver contains a stack of assertions."
	^ self halt; ffiCall: #( void  Z3_solver_push (Z3Context ctx, Z3Solver s) ).
]

{ #category : #modifiers }
LibZ3 >> substitute: ctx ast: a numExprs: anUnsigned from: fromAstArray to: toAstArray [
	"Substitute every occurrence of from[i] in a with to[i], for i<numExprs.
	
	The result is the new AST.
	The arrays from and to must have size numExprs.
	
	   For every \c i smaller than \c num_exprs, we must have that sort of \ccode{from[i]} must be equal to sort of \ccode{to[i]}.
."
	^self halt; ffiCall: #( void*  Z3_substitute(Z3Context ctx, Z3AST a, uint anUnsigned,
		FFIExternalArray fromAstArray, FFIExternalArray toAstArray) )
]

{ #category : #modifiers }
LibZ3 >> substituteVars: ctx ast: a numExprs: anUnsigned to: toAstArray [
	"Substitute the free variables in a with the expressions in toAstArray.
	   For every \c i smaller than \c num_exprs, the variable with de-Bruijn index \c i is replaced with term \ccode{to[i]}"
	^self halt; ffiCall: #( void*  Z3_substitute_vars(Z3Context ctx, Z3AST a, uint anUnsigned, FFIExternalArray toAstArray) )
]

{ #category : #'accessing platform' }
LibZ3 >> unix64LibraryName [
	^ 'libz3.so'
]

{ #category : #'accessing platform' }
LibZ3 >> unix64ModuleName [
	^ 'libz3.so'
]
