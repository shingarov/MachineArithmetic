"
This test gives an example of a Galois connection â€” a pair of functions
which are ""almost inverse"" to each other in an amazing way.

One possible representation of Booleans in the computer, would be as an
isomorphism ð”¹â‰…{0,1}: ""0 for false, 1 for true"".
In this case we have a pair of functions, b2i and i2b:

  b2i :: ð”¹ â†’ {0,1}
  b2i(false) = 0
  b2i(true)  = 1

  i2b :: {0,1} â†’ ð”¹
  i2b(0) = false
  i2b(1) = true

These are inverses of each other:

  i2b âˆ˜ b2i = Id(ð”¹)
  b2i âˆ˜ i2b = Id({0,1})

In Kernighan and Ritchie's ""C"" language, booleans are represented in an
almost, but not quite the same way:

  if (c) {
    ...trueBranch...
  } else {
    ...falseBranch...
  }

takes the trueBranch when c is any nonzero int, and falseBranch if c==0.

Let's ignore the difference between int and â„¤ for simplicity, and try to
construct b2i and i2b similar to above:

  b2i :: ð”¹ â†’ â„¤
  b2i(false) = 0
  b2i(true)  = 1

  i2b :: â„¤ â†’ ð”¹
  i2b(0) = false
  i2b(i) = true âˆ€iâ‰ 0

These are no longer inverse: although

  i2b âˆ˜ b2i = Id(ð”¹),

it breaks in the other direction:

  b2i âˆ˜ i2b â‰  Id(â„¤)

because i2b is not injective: it ""loses information"" by ""squishing"" all
nonzero ints together into one point:

  b2i(i2b(42)) = 1 â‰  42.

This is a Galois connection.  ð”¹ is a ""blurry image"" of â„¤: looking through
the i2b lens, we can resolve 0 from 1 but we can't resolve 1 from 42.

If we order ð”¹ as usual:

  false â‰¤ true

and â„¤ as

  0 âŠ‘ i âˆ€iâˆˆâ„¤,
  1 â‰¡ 2 â‰¡ 3 â‰¡ ...,

then i2b is the left (aka lower) adjoint and b2i is the right (upper) adjoint:

  i2b(i) â‰¤ b  iff  i âŠ‘ b2i(b)

(In the terminology of Abstract Interpretation, i2b is the ""abstractor""
and b2i is the ""concretizer"").

           b2i
  true ---------â†’ 1â‰¡2â‰¡3â‰¡...
    â†‘              |
   â‰¤|              |âŠ‘
    |      i2b     â†“
  false â†--------  0

"
Class {
	#name : #BoolGaloisConnectionTest,
	#superclass : #SpriteLangTest,
	#category : #'SpriteLang-Tests-Simple'
}

{ #category : #tests }
BoolGaloisConnectionTest >> testAlphaClash [
	"This test is identical to testIidI, except w is renamed to i,
	 so must end up in the same UNSAFE result.
	 However, this breaks, see issue #139.
	"
	self skip. "Remove this skip after #139 is resolved."
	self proveUnsafe: '
âŸ¦val b2i : b:bool => int[i | ((i===0) not <=> b) & ((i===0)|(i===1)) ] âŸ§
let b2i = (b) => {
  if (b) { 1 } else { 0 }
};

âŸ¦val i2b : i:int => bool[b | (i===0) not <=> b ] âŸ§
let i2b = (i) => {
  let notZero = i != 0;
  if (notZero) { true } else { false }
};

âŸ¦val i2i : x:int => int[y | y === x ] âŸ§
let i2i = (i) => {
  let b = i2b(i);
  b2i(b)
};
'
]

{ #category : #tests }
BoolGaloisConnectionTest >> testAlphaClash2 [
	self proveSafe: '
âŸ¦val f1 : x:int => y:int => int[z | z === (x + y + 3) ] âŸ§
let f1 = (x,y) => {
	let x = x + 1;
	let y = y + x;	
	y + 2
};
'
]

{ #category : #tests }
BoolGaloisConnectionTest >> testB2I [
	self proveSafe: '
âŸ¦val b2i : b:bool => int[i | (i===0) not <=> b ] âŸ§
let b2i = (b) => {
  if (b) {
    1
  } else {
    0
  }
};
'
]

{ #category : #tests }
BoolGaloisConnectionTest >> testBidB [
	self proveSafe: '
âŸ¦val b2i : b:bool => int[i | (i===0) not <=> b ] âŸ§
let b2i = (b) => {
  if (b) {
    1
  } else {
    0
  }
};

âŸ¦val i2b : i:int => bool[b | (i===0) not <=> b ] âŸ§
let i2b = (i) => {
  let notZero = i != 0;
  if (notZero) {
    true
  } else {
    false
  }
};

âŸ¦val b2b : x:bool => bool[y | y === x ] âŸ§
let b2b = (b) => {
  let i = b2i(b);
  i2b(i)
};
'
]

{ #category : #tests }
BoolGaloisConnectionTest >> testGalois [
	self proveSafe: '
âŸ¦val b2i : b:bool => int[w | ((w===0) not <=> b) & ((w===0)|(w===1)) ] âŸ§
let b2i = (b) => {
  if (b) { 1 } else { 0 }
};

âŸ¦val i2b : i:int => bool[b | (i===0) not <=> b ] âŸ§
let i2b = (i) => {
  let notZero = i != 0;
  if (notZero) { true } else { false }
};

âŸ¦val leqB : b1:bool => b2:bool => bool[leq | leq <=> (b1 ==> b2) ] âŸ§
let leqB = (b1, b2) => {
  b1 ==> b2
};


âŸ¦val leqZ : k1:int => k2:int => bool[leqz | leqz <=> ( (k1===0) | (k2~==0) ) ] âŸ§
let leqZ = (k1, k2) => {
  let k1isZero = k1 == 0;
  if (k1isZero) {
    true
  } else {
    k2 != 0
  }
};

âŸ¦val galois : b:bool => i:int => bool[good|good] âŸ§
let galois = (b, i) => {
  let bb = i2b(i);             let ii = b2i(b);
  let leqb = leqB(bb, b);      let leqi = leqZ(i,ii);
  leqb                    <=>  leqi
};
'
]

{ #category : #tests }
BoolGaloisConnectionTest >> testI2B [
	self proveSafe: '
âŸ¦val i2b : i:int => bool[b | (i===0) not <=> b ] âŸ§
let i2b = (i) => {
  let notZero = i != 0;
  if (notZero) {
    true
  } else {
    false
  }
};
'
]

{ #category : #tests }
BoolGaloisConnectionTest >> testIidI [
	self proveUnsafe: '
âŸ¦val b2i : b:bool => int[w | ((w===0) not <=> b) & ((w===0)|(w===1)) ] âŸ§
let b2i = (b) => {
  if (b) { 1 } else { 0 }
};

âŸ¦val i2b : i:int => bool[b | (i===0) not <=> b ] âŸ§
let i2b = (i) => {
  let notZero = i != 0;
  if (notZero) { true } else { false }
};

âŸ¦val i2i : x:int => int[y | y === x ] âŸ§
let i2i = (i) => {
  let b = i2b(i);
  b2i(b)
};
'
]
