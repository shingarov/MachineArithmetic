Class {
	#name : #Z3,
	#superclass : #Object,
	#pools : [
		'Z3ASTKind'
	],
	#classInstVars : [
		'lib'
	],
	#category : #'Z3-Core'
}

{ #category : #API }
Z3 class >> add_const_interp: c _: m _: f _: a [
	"
	   \brief Add a constant interpretation.

	   def_API('Z3_add_const_interp', VOID, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	a ensureValidZ3AST.
	retval := lib _add_const_interp: c _: m _: f _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> add_func_interp: c _: m _: f _: default_value [
	"
	   \brief Create a fresh func_interp object, add it to a model for a specified function.
	   It has reference count 0.

	   \param c context
	   \param m model
	   \param f function declaration
	   \param default_value default value for function interpretation

	   def_API('Z3_add_func_interp', FUNC_INTERP, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> add_rec_def: c _: f _: n _: args _: body [
	"
	   \brief Define the body of a recursive function.
	   
	   \param c logical context.
	   \param f function declaration.
	   \param n number of arguments to the function
	   \param args constants that are used as arguments to the recursive function in the definition.
	   \param body body of the recursive function

	   After declaring a recursive function or a collection of  mutually recursive functions, use 
	   this function to provide the definition for the recursive function.

	   \sa Z3_mk_rec_func_decl

	   def_API('Z3_add_rec_def', VOID, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	args ensureValidZ3ASTArray.
	body ensureValidZ3AST.
	argsExt := self externalArrayFrom: args.
	retval := lib _add_rec_def: c _: f _: n _: argsExt _: body.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_add: c _: a _: b [
	"
	   \brief Return the value a + b.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)
	   \post Z3_algebraic_is_value(c, result)

	   def_API('Z3_algebraic_add', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_add: c _: a _: b.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> algebraic_div: c _: a _: b [
	"
	   \brief Return the value a / b.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)
	   \pre !Z3_algebraic_is_zero(c, b)
	   \post Z3_algebraic_is_value(c, result)

	   def_API('Z3_algebraic_div', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_div: c _: a _: b.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> algebraic_eq: c _: a _: b [
	"
	   \brief Return \c true if a == b, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)

	   def_API('Z3_algebraic_eq', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_eq: c _: a _: b.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_eval: c _: p _: n _: a [
	"
	   \brief Given a multivariate polynomial p(x_0, ..., x_{n-1}), return the
	   sign of p(a[0], ..., a[n-1]).

	   \pre p is a Z3 expression that contains only arithmetic terms and free variables.
	   \pre forall i in [0, n) Z3_algebraic_is_value(c, a[i])

	   def_API('Z3_algebraic_eval', INT, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval aExt |

	c ensureValidZ3Object.
	p ensureValidZ3AST.
	a ensureValidZ3ASTArray.
	aExt := self externalArrayFrom: a.
	retval := lib _algebraic_eval: c _: p _: n _: aExt.
	aExt notNil ifTrue:[aExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_ge: c _: a _: b [
	"
	   \brief Return \c true if a >= b, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)

	   def_API('Z3_algebraic_ge', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_ge: c _: a _: b.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_get_i: c _: a [
	"
	   \brief Return which root of the polynomial the algebraic number represents.

	   \pre Z3_algebraic_is_value(c, a)

	   def_API('Z3_algebraic_get_i', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_get_i: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_get_poly: c _: a [
	"
	   \brief Return the coefficients of the defining polynomial.

	   \pre Z3_algebraic_is_value(c, a)

	   def_API('Z3_algebraic_get_poly', AST_VECTOR, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_get_poly: c _: a.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> algebraic_gt: c _: a _: b [
	"
	   \brief Return \c true if a > b, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)

	   def_API('Z3_algebraic_gt', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_gt: c _: a _: b.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_is_neg: c _: a [
	"
	   \brief Return \c true if \c a is negative, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)

	   def_API('Z3_algebraic_is_neg', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_is_neg: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_is_pos: c _: a [
	"
	   \brief Return \c true if \c a is positive, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)

	   def_API('Z3_algebraic_is_pos', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_is_pos: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_is_value: c _: a [
	"
	   \brief Return \c true if \c a can be used as value in the Z3 real algebraic
	   number package.

	   def_API('Z3_algebraic_is_value', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_is_value: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_is_zero: c _: a [
	"
	   \brief Return \c true if \c a is zero, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)

	   def_API('Z3_algebraic_is_zero', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_is_zero: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_le: c _: a _: b [
	"
	   \brief Return \c true if a <= b, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)

	   def_API('Z3_algebraic_le', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_le: c _: a _: b.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_lt: c _: a _: b [
	"
	   \brief Return \c true if a < b, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)

	   def_API('Z3_algebraic_lt', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_lt: c _: a _: b.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_mul: c _: a _: b [
	"
	   \brief Return the value a * b.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)
	   \post Z3_algebraic_is_value(c, result)

	   def_API('Z3_algebraic_mul', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_mul: c _: a _: b.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> algebraic_neq: c _: a _: b [
	"
	   \brief Return \c true if a != b, and \c false otherwise.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)

	   def_API('Z3_algebraic_neq', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_neq: c _: a _: b.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_power: c _: a _: k [
	"
	   \brief Return the a^k

	   \pre Z3_algebraic_is_value(c, a)
	   \post Z3_algebraic_is_value(c, result)

	   def_API('Z3_algebraic_power', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_power: c _: a _: k.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> algebraic_root: c _: a _: k [
	"
	   \brief Return the a^(1/k)

	   \pre Z3_algebraic_is_value(c, a)
	   \pre k is even => !Z3_algebraic_is_neg(c, a)
	   \post Z3_algebraic_is_value(c, result)

	   def_API('Z3_algebraic_root', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_root: c _: a _: k.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> algebraic_roots: c _: p _: n _: a [
	"
	   \brief Given a multivariate polynomial p(x_0, ..., x_{n-1}, x_n), returns the
	   roots of the univariate polynomial p(a[0], ..., a[n-1], x_n).

	   \pre p is a Z3 expression that contains only arithmetic terms and free variables.
	   \pre forall i in [0, n) Z3_algebraic_is_value(c, a[i])
	   \post forall r in result Z3_algebraic_is_value(c, result)

	   def_API('Z3_algebraic_roots', AST_VECTOR, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval aExt |

	c ensureValidZ3Object.
	p ensureValidZ3AST.
	a ensureValidZ3ASTArray.
	aExt := self externalArrayFrom: a.
	retval := lib _algebraic_roots: c _: p _: n _: aExt.
	aExt notNil ifTrue:[aExt free].
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> algebraic_sign: c _: a [
	"
	   \brief Return 1 if \c a is positive, 0 if \c a is zero, and -1 if \c a is negative.

	   \pre Z3_algebraic_is_value(c, a)

	   def_API('Z3_algebraic_sign', INT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _algebraic_sign: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> algebraic_sub: c _: a _: b [
	"
	   \brief Return the value a - b.

	   \pre Z3_algebraic_is_value(c, a)
	   \pre Z3_algebraic_is_value(c, b)
	   \post Z3_algebraic_is_value(c, result)

	   def_API('Z3_algebraic_sub', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	b ensureValidZ3AST.
	retval := lib _algebraic_sub: c _: a _: b.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> app_to_ast: c _: a [
	"
	   \brief Convert a \c Z3_app into \c Z3_ast. This is just type casting.

	   def_API('Z3_app_to_ast', AST, (_in(CONTEXT), _in(APP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _app_to_ast: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> apply_result_dec_ref: c _: r [
	"
	   \brief Decrement the reference counter of the given \c Z3_apply_result object.

	   def_API('Z3_apply_result_dec_ref', VOID, (_in(CONTEXT), _in(APPLY_RESULT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type APPLY_RESULT not (yet) supported.'


]

{ #category : #API }
Z3 class >> apply_result_get_num_subgoals: c _: r [
	"
	   \brief Return the number of subgoals in the \c Z3_apply_result object returned by #Z3_tactic_apply.

	   def_API('Z3_apply_result_get_num_subgoals', UINT, (_in(CONTEXT), _in(APPLY_RESULT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type APPLY_RESULT not (yet) supported.'


]

{ #category : #API }
Z3 class >> apply_result_get_subgoal: c _: r _: i [
	"
	   \brief Return one of the subgoals in the \c Z3_apply_result object returned by #Z3_tactic_apply.

	   \pre i < Z3_apply_result_get_num_subgoals(c, r)

	   def_API('Z3_apply_result_get_subgoal', GOAL, (_in(CONTEXT), _in(APPLY_RESULT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> apply_result_inc_ref: c _: r [
	"
	   \brief Increment the reference counter of the given \c Z3_apply_result object.

	   def_API('Z3_apply_result_inc_ref', VOID, (_in(CONTEXT), _in(APPLY_RESULT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type APPLY_RESULT not (yet) supported.'


]

{ #category : #API }
Z3 class >> apply_result_to_string: c _: r [
	"
	   \brief Convert the \c Z3_apply_result object returned by #Z3_tactic_apply into a string.

	   def_API('Z3_apply_result_to_string', STRING, (_in(CONTEXT), _in(APPLY_RESULT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type APPLY_RESULT not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_contains: c _: m _: k [
	"
	\brief Return true if the map \c m contains the AST key \c k.

	def_API('Z3_ast_map_contains', BOOL, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_dec_ref: c _: m [
	"
	\brief Decrement the reference counter of the given AST map.

	def_API('Z3_ast_map_dec_ref', VOID, (_in(CONTEXT), _in(AST_MAP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_erase: c _: m _: k [
	"
	\brief Erase a key from the map.

	def_API('Z3_ast_map_erase', VOID, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_find: c _: m _: k [
	"
	\brief Return the value associated with the key \c k.

	The procedure invokes the error handler if \c k is not in the map.

	def_API('Z3_ast_map_find', AST, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_inc_ref: c _: m [
	"
	\brief Increment the reference counter of the given AST map.

	def_API('Z3_ast_map_inc_ref', VOID, (_in(CONTEXT), _in(AST_MAP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_insert: c _: m _: k _: v [
	"
	\brief Store/Replace a new key, value pair in the given map.

	def_API('Z3_ast_map_insert', VOID, (_in(CONTEXT), _in(AST_MAP), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_keys: c _: m [
	"
	\brief Return the keys stored in the given map.

	def_API('Z3_ast_map_keys', AST_VECTOR, (_in(CONTEXT), _in(AST_MAP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_reset: c _: m [
	"
	\brief Remove all keys from the given map.

	def_API('Z3_ast_map_reset', VOID, (_in(CONTEXT), _in(AST_MAP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_size: c _: m [
	"
	\brief Return the size of the given map.

	def_API('Z3_ast_map_size', UINT, (_in(CONTEXT), _in(AST_MAP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_map_to_string: c _: m [
	"
	\brief Convert the given map into a string.

	def_API('Z3_ast_map_to_string', STRING, (_in(CONTEXT), _in(AST_MAP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> ast_to_string: c _: a [
	"
	   \brief Convert the given AST node into a string.

	   \warning The result buffer is statically allocated by Z3. It will
	   be automatically deallocated when #Z3_del_context is invoked.
	   So, the buffer is invalidated in the next call to \c Z3_ast_to_string.

	   \sa Z3_pattern_to_string
	   \sa Z3_sort_to_string

	   def_API('Z3_ast_to_string', STRING, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _ast_to_string: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_dec_ref: c _: v [
	"
	   \brief Decrement the reference counter of the given AST vector.

	   def_API('Z3_ast_vector_dec_ref', VOID, (_in(CONTEXT), _in(AST_VECTOR)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	retval := lib _ast_vector_dec_ref: c _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_get: c _: v _: i [
	"
	   \brief Return the AST at position \c i in the AST vector \c v.

	   \pre i < Z3_ast_vector_size(c, v)

	   def_API('Z3_ast_vector_get', AST, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	retval := lib _ast_vector_get: c _: v _: i.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> ast_vector_inc_ref: c _: v [
	"
	   \brief Increment the reference counter of the given AST vector.

	   def_API('Z3_ast_vector_inc_ref', VOID, (_in(CONTEXT), _in(AST_VECTOR)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	retval := lib _ast_vector_inc_ref: c _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_push: c _: v _: a [
	"
	   \brief Add the AST \c a in the end of the AST vector \c v. The size of \c v is increased by one.

	   def_API('Z3_ast_vector_push', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _ast_vector_push: c _: v _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_resize: c _: v _: n [
	"
	   \brief Resize the AST vector \c v.

	   def_API('Z3_ast_vector_resize', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	retval := lib _ast_vector_resize: c _: v _: n.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_set: c _: v _: i _: a [
	"
	   \brief Update position \c i of the AST vector \c v with the AST \c a.

	   \pre i < Z3_ast_vector_size(c, v)

	   def_API('Z3_ast_vector_set', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _ast_vector_set: c _: v _: i _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_size: c _: v [
	"
	   \brief Return the size of the given AST vector.

	   def_API('Z3_ast_vector_size', UINT, (_in(CONTEXT), _in(AST_VECTOR)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	retval := lib _ast_vector_size: c _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_to_string: c _: v [
	"
	   \brief Convert AST vector into a string.

	   def_API('Z3_ast_vector_to_string', STRING, (_in(CONTEXT), _in(AST_VECTOR)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	v ensureValidZ3Object.
	retval := lib _ast_vector_to_string: c _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> ast_vector_translate: s _: v _: t [
	"
	   \brief Translate the AST vector \c v from context \c s into an AST vector in context \c t.

	   def_API('Z3_ast_vector_translate', AST_VECTOR, (_in(CONTEXT), _in(AST_VECTOR), _in(CONTEXT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	s ensureValidZ3Object.
	v ensureValidZ3Object.
	t ensureValidZ3Object.
	retval := lib _ast_vector_translate: s _: v _: t.
	s errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: s.
	


]

{ #category : #API }
Z3 class >> benchmark_to_smtlib_string: c _: name _: logic _: status _: attributes _: num_assumptions _: assumptions _: formula [
	"
	   \brief Convert the given benchmark into SMT-LIB formatted string.

	   \warning The result buffer is statically allocated by Z3. It will
	   be automatically deallocated when #Z3_del_context is invoked.
	   So, the buffer is invalidated in the next call to \c Z3_benchmark_to_smtlib_string.

	   \param c - context.
	   \param name - name of benchmark. The argument is optional.
	   \param logic - the benchmark logic.
	   \param status - the status string (sat, unsat, or unknown)
	   \param attributes - other attributes, such as source, difficulty or category.
	   \param num_assumptions - number of assumptions.
	   \param assumptions - auxiliary assumptions.
	   \param formula - formula to be checked for consistency in conjunction with assumptions.

	   def_API('Z3_benchmark_to_smtlib_string', STRING, (_in(CONTEXT), _in(STRING), _in(STRING), _in(STRING), _in(STRING), _in(UINT), _in_array(5, AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval assumptionsExt |

	c ensureValidZ3Object.
	assumptions ensureValidZ3ASTArray.
	formula ensureValidZ3AST.
	assumptionsExt := self externalArrayFrom: assumptions.
	retval := lib _benchmark_to_smtlib_string: c _: name _: logic _: status _: attributes _: num_assumptions _: assumptionsExt _: formula.
	assumptionsExt notNil ifTrue:[assumptionsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> datatype_update_field: c _: field_access _: t _: value [
	"
	   \brief Update record field with a value.

	   This corresponds to the 'with' construct in OCaml.
	   It has the effect of updating a record field with a given value.
	   The remaining fields are left unchanged. It is the record
	   equivalent of an array store (see \sa Z3_mk_store).
	   If the datatype has more than one constructor, then the update function
	   behaves as identity if there is a mismatch between the accessor and
	   constructor. For example ((_ update-field car) nil 1) is nil,
	   while ((_ update-field car) (cons 2 nil) 1) is (cons 1 nil).


	   \pre Z3_get_sort_kind(Z3_get_sort(c, t)) == Z3_get_domain(c, field_access, 1) == Z3_DATATYPE_SORT
	   \pre Z3_get_sort(c, value) == Z3_get_range(c, field_access)


	   def_API('Z3_datatype_update_field', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	field_access ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	t ensureValidZ3AST.
	value ensureValidZ3AST.
	retval := lib _datatype_update_field: c _: field_access _: t _: value.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> dec_ref: c _: a [
	"
	   \brief Decrement the reference counter of the given AST.
	   The context \c c should have been created using #Z3_mk_context_rc.
	   This function is a NOOP if \c c was created using #Z3_mk_context.

	   def_API('Z3_dec_ref', VOID, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _dec_ref: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> del_config: c [
	"
		\brief Delete the given configuration object.

		\sa Z3_mk_config

		def_API('Z3_del_config', VOID, (_in(CONFIG),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _del_config: c.
	^ retval


]

{ #category : #API }
Z3 class >> del_constructor: c _: constr [
	"
	   \brief Reclaim memory allocated to constructor.

	   \param c logical context.
	   \param constr constructor.

	   \sa Z3_mk_constructor

	   def_API('Z3_del_constructor', VOID, (_in(CONTEXT), _in(CONSTRUCTOR)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	constr ensureValidZ3Object.
	retval := lib _del_constructor: c _: constr.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> del_constructor_list: c _: clist [
	"
	   \brief Reclaim memory allocated for constructor list.

	   Each constructor inside the constructor list must be independently reclaimed using #Z3_del_constructor.

	   \param c logical context.
	   \param clist constructor list container.

	   \sa Z3_mk_constructor_list

	   def_API('Z3_del_constructor_list', VOID, (_in(CONTEXT), _in(CONSTRUCTOR_LIST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	clist ensureValidZ3Object.
	retval := lib _del_constructor_list: c _: clist.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> del_context: c [
	"
	   \brief Delete the given logical context.

	   \sa Z3_mk_context

	   def_API('Z3_del_context', VOID, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _del_context: c.
	^ retval


]

{ #category : #API }
Z3 class >> disable_trace: tag [
	"
	   \brief Disable tracing messages tagged as \c tag when Z3 is compiled in debug mode.
	   It is a NOOP otherwise

	   \sa Z3_enable_trace

	   def_API('Z3_disable_trace', VOID, (_in(STRING),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _disable_trace: tag.
	^ retval


]

{ #category : #API }
Z3 class >> enable_trace: tag [
	"
	   \brief Enable tracing messages tagged as \c tag when Z3 is compiled in debug mode.
	   It is a NOOP otherwise

	   \sa Z3_disable_trace

	   def_API('Z3_enable_trace', VOID, (_in(STRING),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _enable_trace: tag.
	^ retval


]

{ #category : #API }
Z3 class >> eval_smtlib2_string: arg0 _: str [
	"
	   \brief Parse and evaluate and SMT-LIB2 command sequence. The state from a previous call is saved so the next
			  evaluation builds on top of the previous call.

	   \returns output generated from processing commands.

	   def_API('Z3_eval_smtlib2_string', STRING, (_in(CONTEXT), _in(STRING),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	arg0 ensureValidZ3Object.
	retval := lib _eval_smtlib2_string: arg0 _: str.
	arg0 errorCheck.
	^ retval


]

{ #category : #utilities }
Z3 class >> externalArrayFrom: anArray [
	^ Z3Object externalArrayFrom: anArray

]

{ #category : #API }
Z3 class >> finalize_memory [
	"
	   \brief Destroy all allocated resources.

	   Any pointers previously returned by the API become invalid.
	   Can be used for memory leak detection.

	   def_API('Z3_finalize_memory', VOID, ())
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _finalize_memory.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_add_cover: c _: d _: level _: pred _: property [
	"
	   \brief Add property about the predicate \c pred.
	   Add a property of predicate \c pred at \c level.
	   It gets pushed forward when possible.

	   Note: level = -1 is treated as the fixedpoint. So passing -1 for the \c level
	   means that the property is true of the fixed-point unfolding with respect to \c pred.

	   Note: this functionality is PDR specific.

	   def_API('Z3_fixedpoint_add_cover', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	pred ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	property ensureValidZ3AST.
	retval := lib _fixedpoint_add_cover: c _: d _: level _: pred _: property.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_add_fact: c _: d _: r _: num_args _: args [
	"
	   \brief Add a Database fact.

	   \param c - context
	   \param d - fixed point context
	   \param r - relation signature for the row.
	   \param num_args - number of columns for the given row.
	   \param args - array of the row elements.

	   The number of arguments \c num_args should be equal to the number
	   of sorts in the domain of \c r. Each sort in the domain should be an integral
	  (bit-vector, Boolean or or finite domain sort).

	   The call has the same effect as adding a rule where \c r is applied to the arguments.

	   def_API('Z3_fixedpoint_add_fact', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	r ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	argsExt := Z3Object externalU32ArrayFrom: args.
	retval := lib _fixedpoint_add_fact: c _: d _: r _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_add_invariant: c _: d _: pred _: property [
	"
	   \brief Add an invariant for the predicate \c pred.
	   Add an assumed invariant of predicate \c pred.

	   Note: this functionality is Spacer specific.

	   def_API('Z3_fixedpoint_add_invariant', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	pred ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	property ensureValidZ3AST.
	retval := lib _fixedpoint_add_invariant: c _: d _: pred _: property.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_add_rule: c _: d _: rule _: name [
	"
	   \brief Add a universal Horn clause as a named rule.
	   The \c horn_rule should be of the form:

	   \code
		   horn_rule ::= (forall (bound-vars) horn_rule)
					  |  (=> atoms horn_rule)
					  |  atom
	   \endcode

	   def_API('Z3_fixedpoint_add_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	rule ensureValidZ3AST.
	name ensureValidZ3Object.
	retval := lib _fixedpoint_add_rule: c _: d _: rule _: name.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_assert: c _: d _: axiom [
	"
	   \brief Assert a constraint to the fixedpoint context.

	   The constraints are used as background axioms when the fixedpoint engine uses the PDR mode.
	   They are ignored for standard Datalog mode.

	   def_API('Z3_fixedpoint_assert', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	axiom ensureValidZ3AST.
	retval := lib _fixedpoint_assert: c _: d _: axiom.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_dec_ref: c _: d [
	"
	   \brief Decrement the reference counter of the given fixedpoint context.

	   def_API('Z3_fixedpoint_dec_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	retval := lib _fixedpoint_dec_ref: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_from_file: c _: f _: s [
	"
	   \brief Parse an SMT-LIB2 file with fixedpoint rules.
	   Add the rules to the current fixedpoint context.
	   Return the set of queries in the file.

	   \param c - context.
	   \param f - fixedpoint context.
	   \param s - path to file containing SMT2 specification.

	   \sa Z3_fixedpoint_from_string
	   \sa Z3_fixedpoint_to_string

	   def_API('Z3_fixedpoint_from_file', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3Object.
	retval := lib _fixedpoint_from_file: c _: f _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_from_string: c _: f _: s [
	"
	   \brief Parse an SMT-LIB2 string with fixedpoint rules.
	   Add the rules to the current fixedpoint context.
	   Return the set of queries in the string.

	   \param c - context.
	   \param f - fixedpoint context.
	   \param s - string containing SMT2 specification.

	   \sa Z3_fixedpoint_from_file
	   \sa Z3_fixedpoint_to_string

	   def_API('Z3_fixedpoint_from_string', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3Object.
	retval := lib _fixedpoint_from_string: c _: f _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_answer: c _: d [
	"
	   \brief Retrieve a formula that encodes satisfying answers to the query.


	   When used in Datalog mode, the returned answer is a disjunction of conjuncts.
	   Each conjunct encodes values of the bound variables of the query that are satisfied.
	   In PDR mode, the returned answer is a single conjunction.

	   When used in Datalog mode the previous call to #Z3_fixedpoint_query must have returned \c Z3_L_TRUE.
	   When used with the PDR engine, the previous call must have been either \c Z3_L_TRUE or \c Z3_L_FALSE.

	   def_API('Z3_fixedpoint_get_answer', AST, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	retval := lib _fixedpoint_get_answer: c _: d.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_assertions: c _: f [
	"
	   \brief Retrieve set of background assertions from fixedpoint context.

	   def_API('Z3_fixedpoint_get_assertions', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3Object.
	retval := lib _fixedpoint_get_assertions: c _: f.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_cover_delta: c _: d _: level _: pred [
	"
	   Retrieve the current cover of \c pred up to \c level unfoldings.
	   Return just the delta that is known at \c level. To
	   obtain the full set of properties of \c pred one should query
	   at \c level+1 , \c level+2 etc, and include \c level=-1.

	   Note: this functionality is PDR specific.

	   def_API('Z3_fixedpoint_get_cover_delta', AST, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	pred ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _fixedpoint_get_cover_delta: c _: d _: level _: pred.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_ground_sat_answer: c _: d [
	"
	   \brief Retrieve a bottom-up (from query) sequence of ground facts

	   The previous call to #Z3_fixedpoint_query must have returned \c Z3_L_TRUE.

	   def_API('Z3_fixedpoint_get_ground_sat_answer', AST, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	retval := lib _fixedpoint_get_ground_sat_answer: c _: d.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_help: c _: f [
	"
	   \brief Return a string describing all fixedpoint available parameters.

	   \sa Z3_fixedpoint_get_param_descrs
	   \sa Z3_fixedpoint_set_params

	   def_API('Z3_fixedpoint_get_help', STRING, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3Object.
	retval := lib _fixedpoint_get_help: c _: f.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_get_num_levels: c _: d _: pred [
	"
	   \brief Query the PDR engine for the maximal levels properties are known about predicate.

	   This call retrieves the maximal number of relevant unfoldings
	   of \c pred with respect to the current exploration state.
	   Note: this functionality is PDR specific.

	   def_API('Z3_fixedpoint_get_num_levels', UINT, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	pred ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _fixedpoint_get_num_levels: c _: d _: pred.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_get_param_descrs: c _: f [
	"
	   \brief Return the parameter description set for the given fixedpoint object.

	   \sa Z3_fixedpoint_get_help
	   \sa Z3_fixedpoint_set_params

	   def_API('Z3_fixedpoint_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> fixedpoint_get_reachable: c _: d _: pred [
	"
	   Retrieve reachable states of a predicate.
	   Note: this functionality is Spacer specific.

	   def_API('Z3_fixedpoint_get_reachable', AST, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	pred ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _fixedpoint_get_reachable: c _: d _: pred.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_reason_unknown: c _: d [
	"
	   \brief Retrieve a string that describes the last status returned by #Z3_fixedpoint_query.

	   Use this method when #Z3_fixedpoint_query returns \c Z3_L_UNDEF.

	   def_API('Z3_fixedpoint_get_reason_unknown', STRING, (_in(CONTEXT), _in(FIXEDPOINT) ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	retval := lib _fixedpoint_get_reason_unknown: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_get_rule_names_along_trace: c _: d [
	"
	   \brief Obtain the list of rules along the counterexample trace.

	   def_API('Z3_fixedpoint_get_rule_names_along_trace', SYMBOL, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	retval := lib _fixedpoint_get_rule_names_along_trace: c _: d.
	c errorCheck.
	^ Z3Symbol fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_rules: c _: f [
	"
	   \brief Retrieve set of rules from fixedpoint context.

	   def_API('Z3_fixedpoint_get_rules', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3Object.
	retval := lib _fixedpoint_get_rules: c _: f.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_rules_along_trace: c _: d [
	"
	   \brief Obtain the list of rules along the counterexample trace.

	   def_API('Z3_fixedpoint_get_rules_along_trace', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	retval := lib _fixedpoint_get_rules_along_trace: c _: d.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fixedpoint_get_statistics: c _: d [
	"
	   \brief Retrieve statistics information from the last call to #Z3_fixedpoint_query.

	   def_API('Z3_fixedpoint_get_statistics', STATS, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> fixedpoint_inc_ref: c _: d [
	"
	   \brief Increment the reference counter of the given fixedpoint context

	   def_API('Z3_fixedpoint_inc_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	retval := lib _fixedpoint_inc_ref: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_query: c _: d _: query [
	"
		\brief Pose a query against the asserted rules.

		\code
		   query ::= (exists (bound-vars) query)
				 |  literals
		\endcode

		query returns
		- \c Z3_L_FALSE if the query is unsatisfiable.
		- \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
		- \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.

		def_API('Z3_fixedpoint_query', INT, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	query ensureValidZ3AST.
	retval := lib _fixedpoint_query: c _: d _: query.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_query_from_lvl: c _: d _: query _: lvl [
	"
		\brief Pose a query against the asserted rules at the given level.

		\code
		   query ::= (exists (bound-vars) query)
				 |  literals
		\endcode

		query returns
		- \c Z3_L_FALSE if the query is unsatisfiable.
		- \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
		- \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.

		def_API('Z3_fixedpoint_query_from_lvl', INT, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	query ensureValidZ3AST.
	retval := lib _fixedpoint_query_from_lvl: c _: d _: query _: lvl.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_query_relations: c _: d _: num_relations _: relations [
	"
		\brief Pose multiple queries against the asserted rules.

		The queries are encoded as relations (function declarations).

		query returns
		- \c Z3_L_FALSE if the query is unsatisfiable.
		- \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
		- \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.

		def_API('Z3_fixedpoint_query_relations', INT, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval relationsExt |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	relations ensureValidZ3ASTArrayOfKind: FUNC_DECL_AST.
	relationsExt := self externalArrayFrom: relations.
	retval := lib _fixedpoint_query_relations: c _: d _: num_relations _: relationsExt.
	relationsExt notNil ifTrue:[relationsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_register_relation: c _: d _: f [
	"
	   \brief Register relation as Fixedpoint defined.
	   Fixedpoint defined relations have least-fixedpoint semantics.
	   For example, the relation is empty if it does not occur
	   in a head or a fact.

	   def_API('Z3_fixedpoint_register_relation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _fixedpoint_register_relation: c _: d _: f.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_set_params: c _: f _: p [
	"
	   \brief Set parameters on fixedpoint context.

	   \sa Z3_fixedpoint_get_help
	   \sa Z3_fixedpoint_get_param_descrs

	   def_API('Z3_fixedpoint_set_params', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _fixedpoint_set_params: c _: f _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_set_predicate_representation: c _: d _: f _: num_relations _: relation_kinds [
	"
	   \brief Configure the predicate representation.

	   It sets the predicate to use a set of domains given by the list of symbols.
	   The domains given by the list of symbols must belong to a set
	   of built-in domains.

	   def_API('Z3_fixedpoint_set_predicate_representation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval relation_kindsExt |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	relation_kinds ensureValidZ3ObjectArray.
	relation_kindsExt := self externalArrayFrom: relation_kinds.
	retval := lib _fixedpoint_set_predicate_representation: c _: d _: f _: num_relations _: relation_kindsExt.
	relation_kindsExt notNil ifTrue:[relation_kindsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_to_string: c _: f _: num_queries _: queries [
	"
	   \brief Print the current rules and background axioms as a string.
	   \param c - context.
	   \param f - fixedpoint context.
	   \param num_queries - number of additional queries to print.
	   \param queries - additional queries.

	   \sa Z3_fixedpoint_from_file
	   \sa Z3_fixedpoint_from_string

	   def_API('Z3_fixedpoint_to_string', STRING, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval queriesExt |

	c ensureValidZ3Object.
	f ensureValidZ3Object.
	queries ensureValidZ3ASTArray.
	queriesExt := self externalArrayFrom: queries.
	retval := lib _fixedpoint_to_string: c _: f _: num_queries _: queriesExt.
	queriesExt notNil ifTrue:[queriesExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fixedpoint_update_rule: c _: d _: a _: name [
	"
	   \brief Update a named rule.
	   A rule with the same name must have been previously created.

	   def_API('Z3_fixedpoint_update_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3Object.
	a ensureValidZ3AST.
	name ensureValidZ3Object.
	retval := lib _fixedpoint_update_rule: c _: d _: a _: name.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_get_ebits: c _: s [
	"
		\brief Retrieves the number of bits reserved for the exponent in a FloatingPoint sort.

		\param c logical context
		\param s FloatingPoint sort

		def_API('Z3_fpa_get_ebits', UINT, (_in(CONTEXT),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _fpa_get_ebits: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_get_numeral_exponent_bv: c _: t _: biased [
	"
		\brief Retrieves the exponent of a floating-point literal as a bit-vector expression.

		\param c logical context
		\param t a floating-point numeral
		\param biased flag to indicate whether the result is in biased representation

		Remarks: This function extracts the exponent in `t`, without normalization.
		NaN is an invalid arguments.

		def_API('Z3_fpa_get_numeral_exponent_bv', AST, (_in(CONTEXT), _in(AST), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_get_numeral_exponent_bv: c _: t _: biased.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fpa_get_numeral_exponent_int64: c _: t _: n _: biased [
	"
		\brief Return the exponent value of a floating-point numeral as a signed 64-bit integer

		\param c logical context
		\param t a floating-point numeral
		\param n exponent
		\param biased flag to indicate whether the result is in biased representation
		\returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false

		Remarks: This function extracts the exponent in `t`, without normalization.
		NaN is an invalid argument.

		def_API('Z3_fpa_get_numeral_exponent_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT64 not (yet) supported'


]

{ #category : #API }
Z3 class >> fpa_get_numeral_exponent_string: c _: t _: biased [
	"
		\brief Return the exponent value of a floating-point numeral as a string.

		\param c logical context
		\param t a floating-point numeral
		\param biased flag to indicate whether the result is in biased representation
		\returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false

		Remarks: This function extracts the exponent in `t`, without normalization.
		NaN is an invalid argument.

	def_API('Z3_fpa_get_numeral_exponent_string', STRING, (_in(CONTEXT), _in(AST), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_get_numeral_exponent_string: c _: t _: biased.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_get_numeral_sign: c _: t _: sgn [
	"
		\brief Retrieves the sign of a floating-point literal.

		\param c logical context
		\param t a floating-point numeral
		\param sgn the retrieved sign
		\returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false

		Remarks: sets \c sgn to 0 if `t' is positive and to 1 otherwise, except for
		NaN, which is an invalid argument.

		def_API('Z3_fpa_get_numeral_sign', BOOL, (_in(CONTEXT), _in(AST), _out(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT not (yet) supported'


]

{ #category : #API }
Z3 class >> fpa_get_numeral_sign_bv: c _: t [
	"
		\brief Retrieves the sign of a floating-point literal as a bit-vector expression.

		\param c logical context
		\param t a floating-point numeral

		Remarks: NaN is an invalid argument.

		def_API('Z3_fpa_get_numeral_sign_bv', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_get_numeral_sign_bv: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fpa_get_numeral_significand_bv: c _: t [
	"
		\brief Retrieves the significand of a floating-point literal as a bit-vector expression.

		\param c logical context
		\param t a floating-point numeral

		Remarks: NaN is an invalid argument.

		def_API('Z3_fpa_get_numeral_significand_bv', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_get_numeral_significand_bv: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> fpa_get_numeral_significand_string: c _: t [
	"
		\brief Return the significand value of a floating-point numeral as a string.

		\param c logical context
		\param t a floating-point numeral
		\returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false

		Remarks: The significand \c s is always \ccode{0.0 <= s < 2.0}; the resulting string is long
		enough to represent the real significand precisely.

		def_API('Z3_fpa_get_numeral_significand_string', STRING, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_get_numeral_significand_string: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_get_numeral_significand_uint64: c _: t _: n [
	"
		\brief Return the significand value of a floating-point numeral as a uint64.

		\param c logical context
		\param t a floating-point numeral
		\param n pointer to output uint64

		Remarks: This function extracts the significand bits in `t`, without the
		hidden bit or normalization. Sets the \c Z3_INVALID_ARG error code if the
		significand does not fit into a \c uint64. NaN is an invalid argument.

		def_API('Z3_fpa_get_numeral_significand_uint64', BOOL, (_in(CONTEXT), _in(AST), _out(UINT64)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type UINT64 not (yet) supported'


]

{ #category : #API }
Z3 class >> fpa_get_sbits: c _: s [
	"
		\brief Retrieves the number of bits reserved for the significand in a FloatingPoint sort.

		\param c logical context
		\param s FloatingPoint sort

		def_API('Z3_fpa_get_sbits', UINT, (_in(CONTEXT),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _fpa_get_sbits: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_is_numeral_inf: c _: t [
	"
		\brief Checks whether a given floating-point numeral is a +oo or -oo.

		\param c logical context
		\param t a floating-point numeral

		def_API('Z3_fpa_is_numeral_inf', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_is_numeral_inf: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_is_numeral_nan: c _: t [
	"
		\brief Checks whether a given floating-point numeral is a NaN.

		\param c logical context
		\param t a floating-point numeral

		def_API('Z3_fpa_is_numeral_nan', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_is_numeral_nan: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_is_numeral_negative: c _: t [
	"
		\brief Checks whether a given floating-point numeral is negative.

		\param c logical context
		\param t a floating-point numeral

		def_API('Z3_fpa_is_numeral_negative', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_is_numeral_negative: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_is_numeral_normal: c _: t [
	"
		\brief Checks whether a given floating-point numeral is normal.

		\param c logical context
		\param t a floating-point numeral

		def_API('Z3_fpa_is_numeral_normal', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_is_numeral_normal: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_is_numeral_positive: c _: t [
	"
		\brief Checks whether a given floating-point numeral is positive.

		\param c logical context
		\param t a floating-point numeral

		def_API('Z3_fpa_is_numeral_positive', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_is_numeral_positive: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_is_numeral_subnormal: c _: t [
	"
		\brief Checks whether a given floating-point numeral is subnormal.

		\param c logical context
		\param t a floating-point numeral

		def_API('Z3_fpa_is_numeral_subnormal', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_is_numeral_subnormal: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> fpa_is_numeral_zero: c _: t [
	"
		\brief Checks whether a given floating-point numeral is +zero or -zero.

		\param c logical context
		\param t a floating-point numeral

		def_API('Z3_fpa_is_numeral_zero', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _fpa_is_numeral_zero: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> func_decl_to_ast: c _: f [
	"
	   \brief Convert a \c Z3_func_decl into \c Z3_ast. This is just type casting.

	   def_API('Z3_func_decl_to_ast', AST, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _func_decl_to_ast: c _: f.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> func_decl_to_string: c _: d [
	"
	  def_API('Z3_func_decl_to_string', STRING, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _func_decl_to_string: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> func_entry_dec_ref: c _: e [
	"
	   \brief Decrement the reference counter of the given \c Z3_func_entry object.

	   def_API('Z3_func_entry_dec_ref', VOID, (_in(CONTEXT), _in(FUNC_ENTRY)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_ENTRY not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_entry_get_arg: c _: e _: i [
	"
	   \brief Return an argument of a \c Z3_func_entry object.

	   \pre i < Z3_func_entry_get_num_args(c, e)

	   \sa Z3_func_interp_get_entry

	   def_API('Z3_func_entry_get_arg', AST, (_in(CONTEXT), _in(FUNC_ENTRY), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_ENTRY not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_entry_get_num_args: c _: e [
	"
	   \brief Return the number of arguments in a \c Z3_func_entry object.

	   \sa Z3_func_interp_get_entry

	   def_API('Z3_func_entry_get_num_args', UINT, (_in(CONTEXT), _in(FUNC_ENTRY)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_ENTRY not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_entry_get_value: c _: e [
	"
	   \brief Return the value of this point.

	   A \c Z3_func_entry object represents an element in the finite map used to encode
	   a function interpretation.

	   \sa Z3_func_interp_get_entry

	   def_API('Z3_func_entry_get_value', AST, (_in(CONTEXT), _in(FUNC_ENTRY)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_ENTRY not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_entry_inc_ref: c _: e [
	"
	   \brief Increment the reference counter of the given \c Z3_func_entry object.

	   def_API('Z3_func_entry_inc_ref', VOID, (_in(CONTEXT), _in(FUNC_ENTRY)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_ENTRY not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_add_entry: c _: fi _: args _: value [
	"
	   \brief add a function entry to a function interpretation.

	   \param c logical context
	   \param fi a function interpretation to be updated.
	   \param args list of arguments. They should be constant values (such as integers) and be of the same types as the domain of the function.
	   \param value value of the function when the parameters match args.

	   It is assumed that entries added to a function cover disjoint arguments.
	   If an two entries are added with the same arguments, only the second insertion survives and the
	   first inserted entry is removed.

	   def_API('Z3_func_interp_add_entry', VOID, (_in(CONTEXT), _in(FUNC_INTERP), _in(AST_VECTOR), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_dec_ref: c _: f [
	"
	   \brief Decrement the reference counter of the given Z3_func_interp object.

	   def_API('Z3_func_interp_dec_ref', VOID, (_in(CONTEXT), _in(FUNC_INTERP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_get_arity: c _: f [
	"
	   \brief Return the arity (number of arguments) of the given function interpretation.

	   def_API('Z3_func_interp_get_arity', UINT, (_in(CONTEXT), _in(FUNC_INTERP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_get_else: c _: f [
	"
	   \brief Return the 'else' value of the given function interpretation.

	   A function interpretation is represented as a finite map and an 'else' value.
	   This procedure returns the 'else' value.

	   def_API('Z3_func_interp_get_else', AST, (_in(CONTEXT), _in(FUNC_INTERP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_get_entry: c _: f _: i [
	"
	   \brief Return a 'point' of the given function interpretation. It represents the
	   value of \c f in a particular point.

	   \pre i < Z3_func_interp_get_num_entries(c, f)

	   \sa Z3_func_interp_get_num_entries

	   def_API('Z3_func_interp_get_entry', FUNC_ENTRY, (_in(CONTEXT), _in(FUNC_INTERP), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_ENTRY not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_get_num_entries: c _: f [
	"
	   \brief Return the number of entries in the given function interpretation.

	   A function interpretation is represented as a finite map and an 'else' value.
	   Each entry in the finite map represents the value of a function given a set of arguments.
	   This procedure return the number of element in the finite map of \c f.

	   def_API('Z3_func_interp_get_num_entries', UINT, (_in(CONTEXT), _in(FUNC_INTERP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_inc_ref: c _: f [
	"
	   \brief Increment the reference counter of the given Z3_func_interp object.

	   def_API('Z3_func_interp_inc_ref', VOID, (_in(CONTEXT), _in(FUNC_INTERP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> func_interp_set_else: c _: f _: else_value [
	"
	   \brief Return the 'else' value of the given function interpretation.

	   A function interpretation is represented as a finite map and an 'else' value.
	   This procedure can be used to update the 'else' value.

	   def_API('Z3_func_interp_set_else', VOID, (_in(CONTEXT), _in(FUNC_INTERP), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #utilities }
Z3 class >> getVersion [
	| maj min b r |
	maj := Array with: 0.
	min := Array with: 0.
	b   := Array with: 0.
	r   := Array with: 0.
	Z3 get_version: maj _: min _: b _: r.
	^ maj , min , b , r

	"
	Z3 getVersion
	"

]

{ #category : #API }
Z3 class >> get_algebraic_number_lower: c _: a _: precision [
	"
	   \brief Return a lower bound for the given real algebraic number.
	   The interval isolating the number is smaller than 1/10^precision.
	   The result is a numeral AST of sort Real.

	   \pre Z3_is_algebraic_number(c, a)

	   def_API('Z3_get_algebraic_number_lower', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_algebraic_number_lower: c _: a _: precision.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_algebraic_number_upper: c _: a _: precision [
	"
	   \brief Return a upper bound for the given real algebraic number.
	   The interval isolating the number is smaller than 1/10^precision.
	   The result is a numeral AST of sort Real.

	   \pre Z3_is_algebraic_number(c, a)

	   def_API('Z3_get_algebraic_number_upper', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_algebraic_number_upper: c _: a _: precision.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_app_arg: c _: a _: i [
	"
	   \brief Return the i-th argument of the given application.

	   \pre i < Z3_get_app_num_args(c, a)

	   def_API('Z3_get_app_arg', AST, (_in(CONTEXT), _in(APP), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_app_arg: c _: a _: i.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_app_decl: c _: a [
	"
	   \brief Return the declaration of a constant or function application.

	   def_API('Z3_get_app_decl', FUNC_DECL, (_in(CONTEXT), _in(APP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_app_decl: c _: a.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_app_num_args: c _: a [
	"
	   \brief Return the number of argument of an application. If \c t
	   is an constant, then the number of arguments is 0.

	   def_API('Z3_get_app_num_args', UINT, (_in(CONTEXT), _in(APP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_app_num_args: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_arity: c _: d [
	"
	   \brief Alias for \c Z3_get_domain_size.

	   \sa Z3_get_domain_size

	   def_API('Z3_get_arity', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_arity: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_array_sort_domain: c _: t [
	"
	   \brief Return the domain of the given array sort.
	   In the case of a multi-dimensional array, this function returns the sort of the first dimension.

	   \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT

	   \sa Z3_mk_array_sort
	   \sa Z3_get_sort_kind
	   \sa Z3_get_array_sort_domain_n

	   def_API('Z3_get_array_sort_domain', SORT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_array_sort_domain: c _: t.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_array_sort_domain_n: c _: t _: idx [
	"
	   \brief Return the i'th domain sort of an n-dimensional array.

	   \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT

	   \sa Z3_mk_array_sort
	   \sa Z3_get_sort_kind
	   \sa Z3_get_array_sort_domain

	   def_API('Z3_get_array_sort_domain_n', SORT, (_in(CONTEXT), _in(SORT), _in(UINT)))
	   
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_array_sort_domain_n: c _: t _: idx.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_array_sort_range: c _: t [
	"
	   \brief Return the range of the given array sort.

	   \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT

	   \sa Z3_mk_array_sort
	   \sa Z3_get_sort_kind

	   def_API('Z3_get_array_sort_range', SORT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_array_sort_range: c _: t.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_as_array_func_decl: c _: a [
	"
	   \brief Return the function declaration \c f associated with a \ccode{(_ as_array f)} node.

	   \sa Z3_is_as_array

	   def_API('Z3_get_as_array_func_decl', FUNC_DECL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_as_array_func_decl: c _: a.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_ast_hash: c _: a [
	"
	   \brief Return a hash code for the given AST.
	   The hash code is structural but two different AST objects can map to the same hash.
	   The result of \c Z3_get_ast_id returns an indentifier that is unique over the 
	   set of live AST objects.

	   def_API('Z3_get_ast_hash', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_ast_hash: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_ast_id: c _: t [
	"
		\brief Return a unique identifier for \c t.
		The identifier is unique up to structural equality. Thus, two ast nodes
		created by the same context and having the same children and same function symbols
		have the same identifiers. Ast nodes created in the same context, but having
		different children or different functions have different identifiers.
		Variables and quantifiers are also assigned different identifiers according to
		their structure.

		def_API('Z3_get_ast_id', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _get_ast_id: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_ast_kind: c _: a [
	"
	   \brief Return the kind of the given AST.

	   def_API('Z3_get_ast_kind', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_ast_kind: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_bool_value: c _: a [
	"
	   \brief Return \c Z3_L_TRUE if \c a is true, \c Z3_L_FALSE if it is false, and \c Z3_L_UNDEF otherwise.

	   def_API('Z3_get_bool_value', INT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_bool_value: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_bv_sort_size: c _: t [
	"
	   \brief Return the size of the given bit-vector sort.

	   \pre Z3_get_sort_kind(c, t) == Z3_BV_SORT

	   \sa Z3_mk_bv_sort
	   \sa Z3_get_sort_kind

	   def_API('Z3_get_bv_sort_size', UINT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_bv_sort_size: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_datatype_sort_constructor: c _: t _: idx [
	"
		\brief Return idx'th constructor.

		\pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
		\pre idx < Z3_get_datatype_sort_num_constructors(c, t)

		\sa Z3_get_datatype_sort_num_constructors
		\sa Z3_get_datatype_sort_recognizer
		\sa Z3_get_datatype_sort_constructor_accessor

		def_API('Z3_get_datatype_sort_constructor', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_datatype_sort_constructor: c _: t _: idx.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_datatype_sort_constructor_accessor: c _: t _: idx_c _: idx_a [
	"
		\brief Return idx_a'th accessor for the idx_c'th constructor.

		\pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
		\pre idx_c < Z3_get_datatype_sort_num_constructors(c, t)
		\pre idx_a < Z3_get_domain_size(c, Z3_get_datatype_sort_constructor(c, idx_c))

		\sa Z3_get_datatype_sort_num_constructors
		\sa Z3_get_datatype_sort_constructor
		\sa Z3_get_datatype_sort_recognizer

		def_API('Z3_get_datatype_sort_constructor_accessor', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_datatype_sort_constructor_accessor: c _: t _: idx_c _: idx_a.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_datatype_sort_num_constructors: c _: t [
	"
		\brief Return number of constructors for datatype.

		\pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT

		\sa Z3_get_datatype_sort_constructor
		\sa Z3_get_datatype_sort_recognizer
		\sa Z3_get_datatype_sort_constructor_accessor

		def_API('Z3_get_datatype_sort_num_constructors', UINT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_datatype_sort_num_constructors: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_datatype_sort_recognizer: c _: t _: idx [
	"
		\brief Return idx'th recognizer.

		\pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
		\pre idx < Z3_get_datatype_sort_num_constructors(c, t)

		\sa Z3_get_datatype_sort_num_constructors
		\sa Z3_get_datatype_sort_constructor
		\sa Z3_get_datatype_sort_constructor_accessor

		def_API('Z3_get_datatype_sort_recognizer', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_datatype_sort_recognizer: c _: t _: idx.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_decl_ast_parameter: c _: d _: idx [
	"
	   \brief Return the expression value associated with an expression parameter.

	   \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_AST

	   def_API('Z3_get_decl_ast_parameter', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_ast_parameter: c _: d _: idx.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_decl_double_parameter: c _: d _: idx [
	"
	   \brief Return the double value associated with an double parameter.

	   \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_DOUBLE

	   def_API('Z3_get_decl_double_parameter', DOUBLE, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_double_parameter: c _: d _: idx.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_decl_func_decl_parameter: c _: d _: idx [
	"
	   \brief Return the expression value associated with an expression parameter.

	   \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_FUNC_DECL

	   def_API('Z3_get_decl_func_decl_parameter', FUNC_DECL, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_func_decl_parameter: c _: d _: idx.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_decl_int_parameter: c _: d _: idx [
	"
	   \brief Return the integer value associated with an integer parameter.

	   \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_INT

	   def_API('Z3_get_decl_int_parameter', INT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_int_parameter: c _: d _: idx.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_decl_kind: c _: d [
	"
	   \brief Return declaration kind corresponding to declaration.

	   def_API('Z3_get_decl_kind', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_kind: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_decl_name: c _: d [
	"
	   \brief Return the constant declaration name as a symbol.

	   def_API('Z3_get_decl_name', SYMBOL, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_name: c _: d.
	c errorCheck.
	^ Z3Symbol fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_decl_num_parameters: c _: d [
	"
	   \brief Return the number of parameters associated with a declaration.

	   def_API('Z3_get_decl_num_parameters', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_num_parameters: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_decl_parameter_kind: c _: d _: idx [
	"
	   \brief Return the parameter type associated with a declaration.

	   \param c the context
	   \param d the function declaration
	   \param idx is the index of the named parameter it should be between 0 and the number of parameters.

	   def_API('Z3_get_decl_parameter_kind', UINT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_parameter_kind: c _: d _: idx.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_decl_rational_parameter: c _: d _: idx [
	"
	   \brief Return the rational value, as a string, associated with a rational parameter.

	   \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_RATIONAL

	   def_API('Z3_get_decl_rational_parameter', STRING, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_rational_parameter: c _: d _: idx.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_decl_sort_parameter: c _: d _: idx [
	"
	   \brief Return the sort value associated with a sort parameter.

	   \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SORT

	   def_API('Z3_get_decl_sort_parameter', SORT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_sort_parameter: c _: d _: idx.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_decl_symbol_parameter: c _: d _: idx [
	"
	   \brief Return the double value associated with an double parameter.

	   \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SYMBOL

	   def_API('Z3_get_decl_symbol_parameter', SYMBOL, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_decl_symbol_parameter: c _: d _: idx.
	c errorCheck.
	^ Z3Symbol fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_denominator: c _: a [
	"
	   \brief Return the denominator (as a numeral AST) of a numeral AST of sort Real.

	   \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST

	   def_API('Z3_get_denominator', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_denominator: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_domain: c _: d _: i [
	"
	   \brief Return the sort of the i-th parameter of the given function declaration.

	   \pre i < Z3_get_domain_size(d)

	   \sa Z3_get_domain_size

	   def_API('Z3_get_domain', SORT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_domain: c _: d _: i.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_domain_size: c _: d [
	"
	   \brief Return the number of parameters of the given declaration.

	   \sa Z3_get_arity

	   def_API('Z3_get_domain_size', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_domain_size: c _: d.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_error_code: c [
	"
	   \brief Return the error code for the last API call.

	   A call to a Z3 function may return a non Z3_OK error code,
	   when it is not used correctly.

	   \sa Z3_set_error_handler

	   def_API('Z3_get_error_code', UINT, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_error_code: c.
	^ retval


]

{ #category : #API }
Z3 class >> get_error_msg: c _: err [
	"
	   \brief Return a string describing the given error code.

	   def_API('Z3_get_error_msg', STRING, (_in(CONTEXT), _in(ERROR_CODE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_error_msg: c _: err.
	^ retval


]

{ #category : #API }
Z3 class >> get_estimated_alloc_size [
	"
	\brief Return the estimated allocated memory in bytes.

	def_API('Z3_get_estimated_alloc_size', UINT64, ())
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _get_estimated_alloc_size.
	^ retval


]

{ #category : #API }
Z3 class >> get_finite_domain_sort_size: c _: s _: r [
	"
		\brief Store the size of the sort in \c r. Return \c false if the call failed.
		That is, Z3_get_sort_kind(s) == Z3_FINITE_DOMAIN_SORT

		def_API('Z3_get_finite_domain_sort_size', BOOL, (_in(CONTEXT), _in(SORT), _out(UINT64)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type UINT64 not (yet) supported'


]

{ #category : #API }
Z3 class >> get_full_version [
	"
	   \brief Return a string that fully describes the version of Z3 in use.

	   \sa Z3_get_version

	   def_API('Z3_get_full_version', STRING, ())
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _get_full_version.
	^ retval


]

{ #category : #API }
Z3 class >> get_func_decl_id: c _: f [
	"
		\brief Return a unique identifier for \c f.

		def_API('Z3_get_func_decl_id', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_func_decl_id: c _: f.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_implied_equalities: c _: s _: num_terms _: terms _: class_ids [
	"
	   \brief Retrieve congruence class representatives for terms.

	   The function can be used for relying on Z3 to identify equal terms under the current
	   set of assumptions. The array of terms and array of class identifiers should have
	   the same length. The class identifiers are numerals that are assigned to the same
	   value for their corresponding terms if the current context forces the terms to be
	   equal. You cannot deduce that terms corresponding to different numerals must be all different,
	   (especially when using non-convex theories).
	   All implied equalities are returned by this call.
	   This means that two terms map to the same class identifier if and only if
	   the current context implies that they are equal.

	   A side-effect of the function is a satisfiability check on the assertions on the solver that is passed in.
	   The function return \c Z3_L_FALSE if the current assertions are not satisfiable.

	   def_API('Z3_get_implied_equalities', INT, (_in(CONTEXT), _in(SOLVER), _in(UINT), _in_array(2, AST), _out_array(2, UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval termsExt class_idsExt |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	terms ensureValidZ3ASTArray.
	termsExt := self externalArrayFrom: terms.
	class_idsExt := Z3Object externalU32ArrayFrom: class_ids.
	retval := lib _get_implied_equalities: c _: s _: num_terms _: termsExt _: class_idsExt.
	termsExt notNil ifTrue:[termsExt free].
	1 to: class_ids size do: [ :i |
		| v |

		v := Z3Object externalArray: class_idsExt u32At: i.
		class_ids at: i put: v.
	].
	class_idsExt notNil ifTrue:[class_idsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_index_value: c _: a [
	"
	   \brief Return index of de-Bruijn bound variable.

	   \pre Z3_get_ast_kind(a) == Z3_VAR_AST

	   def_API('Z3_get_index_value', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_index_value: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_lstring: c _: s _: length [
	"
	   \brief Retrieve the string constant stored in \c s. The string can contain escape sequences.
	   Characters in the range 1 to 255 are literal. 
	   Characters in the range 0, and 256 above are escaped.

	   \pre  Z3_is_string(c, s)

	   def_API('Z3_get_lstring', CHAR_PTR, (_in(CONTEXT), _in(AST), _out(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval lengthExt |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	lengthExt := Z3Object externalU32ArrayFrom: length.
	retval := lib _get_lstring: c _: s _: lengthExt.
	1 to: length size do: [ :i |
		| v |

		v := Z3Object externalArray: lengthExt u32At: i.
		length at: i put: v.
	].
	lengthExt notNil ifTrue:[lengthExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_num_probes: c [
	"
	   \brief Return the number of builtin probes available in Z3.

	   def_API('Z3_get_num_probes', UINT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_num_probes: c.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_num_tactics: c [
	"
	   \brief Return the number of builtin tactics available in Z3.

	   def_API('Z3_get_num_tactics', UINT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_num_tactics: c.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_numeral_binary_string: c _: a [
	"
	   \brief Return numeral value, as a binary string of a numeric constant term

	   \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
	   \pre a represents a non-negative integer

	   def_API('Z3_get_numeral_binary_string', STRING, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_numeral_binary_string: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_numeral_decimal_string: c _: a _: precision [
	"
	   \brief Return numeral as a string in decimal notation.
	   The result has at most \c precision decimal places.

	   \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)

	   def_API('Z3_get_numeral_decimal_string', STRING, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_numeral_decimal_string: c _: a _: precision.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_numeral_double: c _: a [
	"
	   \brief Return numeral as a double.

	   \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)

	   def_API('Z3_get_numeral_double', DOUBLE, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_numeral_double: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_numeral_int64: c _: v _: i [
	"
	   \brief Similar to #Z3_get_numeral_string, but only succeeds if
	   the value can fit in a machine \c int64_t int. Return \c true if the call succeeded.

	   \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST

	   \sa Z3_get_numeral_string

	   def_API('Z3_get_numeral_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT64 not (yet) supported'


]

{ #category : #API }
Z3 class >> get_numeral_int: c _: v _: i [
	"
	   \brief Similar to #Z3_get_numeral_string, but only succeeds if
	   the value can fit in a machine int. Return \c true if the call succeeded.

	   \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST

	   \sa Z3_get_numeral_string

	   def_API('Z3_get_numeral_int', BOOL, (_in(CONTEXT), _in(AST), _out(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT not (yet) supported'


]

{ #category : #API }
Z3 class >> get_numeral_rational_int64: c _: v _: num _: den [
	"
	   \brief Similar to #Z3_get_numeral_string, but only succeeds if
	   the value can fit as a rational number as machine \c int64_t int. Return \c true if the call succeeded.

	   \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST

	   \sa Z3_get_numeral_string

	   def_API('Z3_get_numeral_rational_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _out(INT64)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT64 not (yet) supported'


]

{ #category : #API }
Z3 class >> get_numeral_small: c _: a _: num _: den [
	"
	   \brief Return numeral value, as a pair of 64 bit numbers if the representation fits.

	   \param c logical context.
	   \param a term.
	   \param num numerator.
	   \param den denominator.

	   Return \c true if the numeral value fits in 64 bit numerals, \c false otherwise.

	   \pre Z3_get_ast_kind(a) == Z3_NUMERAL_AST

	   def_API('Z3_get_numeral_small', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _out(INT64)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT64 not (yet) supported'


]

{ #category : #API }
Z3 class >> get_numeral_string: c _: a [
	"
	   \brief Return numeral value, as a decimal string of a numeric constant term

	   \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST

	   def_API('Z3_get_numeral_string', STRING, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_numeral_string: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_numeral_uint64: c _: v _: u [
	"
	   \brief Similar to #Z3_get_numeral_string, but only succeeds if
	   the value can fit in a machine \c uint64_t int. Return \c true if the call succeeded.

	   \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST

	   \sa Z3_get_numeral_string

	   def_API('Z3_get_numeral_uint64', BOOL, (_in(CONTEXT), _in(AST), _out(UINT64)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type UINT64 not (yet) supported'


]

{ #category : #API }
Z3 class >> get_numeral_uint: c _: v _: u [
	"
	   \brief Similar to #Z3_get_numeral_string, but only succeeds if
	   the value can fit in a machine unsigned int. Return \c true if the call succeeded.

	   \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST

	   \sa Z3_get_numeral_string

	   def_API('Z3_get_numeral_uint', BOOL, (_in(CONTEXT), _in(AST), _out(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval uExt |

	c ensureValidZ3Object.
	v ensureValidZ3AST.
	uExt := Z3Object externalU32ArrayFrom: u.
	retval := lib _get_numeral_uint: c _: v _: uExt.
	1 to: u size do: [ :i |
		| v |

		v := Z3Object externalArray: uExt u32At: i.
		u at: i put: v.
	].
	uExt notNil ifTrue:[uExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_numerator: c _: a [
	"
	   \brief Return the numerator (as a numeral AST) of a numeral AST of sort Real.

	   \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST

	   def_API('Z3_get_numerator', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_numerator: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_pattern: c _: p _: idx [
	"
	   \brief Return i'th ast in pattern.

	   def_API('Z3_get_pattern', AST, (_in(CONTEXT), _in(PATTERN), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _get_pattern: c _: p _: idx.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_pattern_num_terms: c _: p [
	"
		\brief Return number of terms in pattern.

		def_API('Z3_get_pattern_num_terms', UINT, (_in(CONTEXT), _in(PATTERN)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _get_pattern_num_terms: c _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_probe_name: c _: i [
	"
	   \brief Return the name of the \c i probe.

	   \pre i < Z3_get_num_probes(c)

	   def_API('Z3_get_probe_name', STRING, (_in(CONTEXT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_probe_name: c _: i.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_quantifier_body: c _: a [
	"
	   \brief Return body of quantifier.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_body', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_body: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_quantifier_bound_name: c _: a _: i [
	"
	   \brief Return symbol of the i'th bound variable.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_bound_name', SYMBOL, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_bound_name: c _: a _: i.
	c errorCheck.
	^ Z3Symbol fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_quantifier_bound_sort: c _: a _: i [
	"
	   \brief Return sort of the i'th bound variable.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_bound_sort', SORT, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_bound_sort: c _: a _: i.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_quantifier_no_pattern_ast: c _: a _: i [
	"
	   \brief Return i'th no_pattern.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_no_pattern_ast', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_no_pattern_ast: c _: a _: i.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_quantifier_num_bound: c _: a [
	"
	   \brief Return number of bound variables of quantifier.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_num_bound', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_num_bound: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_quantifier_num_no_patterns: c _: a [
	"
	   \brief Return number of no_patterns used in quantifier.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_num_no_patterns', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_num_no_patterns: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_quantifier_num_patterns: c _: a [
	"
	   \brief Return number of patterns used in quantifier.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_num_patterns', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_num_patterns: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_quantifier_pattern_ast: c _: a _: i [
	"
	   \brief Return i'th pattern.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_pattern_ast', PATTERN, (_in(CONTEXT), _in(AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_pattern_ast: c _: a _: i.
	c errorCheck.
	^ Z3Pattern fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_quantifier_weight: c _: a [
	"
	   \brief Obtain weight of quantifier.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_get_quantifier_weight', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _get_quantifier_weight: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_range: c _: d [
	"
	   \brief Return the range of the given declaration.

	   If \c d is a constant (i.e., has zero arguments), then this
	   function returns the sort of the constant.

	   def_API('Z3_get_range', SORT, (_in(CONTEXT), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _get_range: c _: d.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_re_sort_basis: c _: s [
	"
	   \brief Retrieve basis sort for regex sort.

	   def_API('Z3_get_re_sort_basis', SORT, (_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_re_sort_basis: c _: s.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_relation_arity: c _: s [
	"
		\brief Return arity of relation.

		\pre Z3_get_sort_kind(s) == Z3_RELATION_SORT

		\sa Z3_get_relation_column

		def_API('Z3_get_relation_arity', UINT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_relation_arity: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_relation_column: c _: s _: col [
	"
		\brief Return sort at i'th column of relation sort.

		\pre Z3_get_sort_kind(c, s) == Z3_RELATION_SORT
		\pre col < Z3_get_relation_arity(c, s)

		\sa Z3_get_relation_arity

		def_API('Z3_get_relation_column', SORT, (_in(CONTEXT), _in(SORT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_relation_column: c _: s _: col.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_seq_sort_basis: c _: s [
	"
	   \brief Retrieve basis sort for sequence sort.

	   def_API('Z3_get_seq_sort_basis', SORT, (_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_seq_sort_basis: c _: s.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_sort: c _: a [
	"
	   \brief Return the sort of an AST node.

	   The AST node must be a constant, application, numeral, bound variable, or quantifier.

	   def_API('Z3_get_sort', SORT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_sort: c _: a.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_sort_id: c _: s [
	"
		\brief Return a unique identifier for \c s.

		def_API('Z3_get_sort_id', UINT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_sort_id: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_sort_kind: c _: t [
	"
	   \brief Return the sort kind (e.g., array, tuple, int, bool, etc).

	   \sa Z3_sort_kind

	   def_API('Z3_get_sort_kind', UINT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_sort_kind: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_sort_name: c _: d [
	"
	   \brief Return the sort name as a symbol.

	   def_API('Z3_get_sort_name', SYMBOL, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_sort_name: c _: d.
	c errorCheck.
	^ Z3Symbol fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_string: c _: s [
	"
	   \brief Retrieve the string constant stored in \c s.
	   Characters outside the basic printiable ASCII range are escaped.

	   \pre  Z3_is_string(c, s)

	   def_API('Z3_get_string', STRING, (_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _get_string: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_string_contents: c _: s _: length _: contents [
	"
	   \brief Retrieve the unescaped string constant stored in \c s. 

	   \pre  Z3_is_string(c, s)

	   \pre length contains the number of characters in s

	   def_API('Z3_get_string_contents', VOID, (_in(CONTEXT), _in(AST), _in(UINT), _out_array(2, UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval contentsExt |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	contentsExt := Z3Object externalU32ArrayFrom: contents.
	retval := lib _get_string_contents: c _: s _: length _: contentsExt.
	1 to: contents size do: [ :i |
		| v |

		v := Z3Object externalArray: contentsExt u32At: i.
		contents at: i put: v.
	].
	contentsExt notNil ifTrue:[contentsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_string_length: c _: s [
	"
	   \brief Retrieve the length of the unescaped string constant stored in \c s. 

	   \pre  Z3_is_string(c, s)

	   def_API('Z3_get_string_length', UINT, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _get_string_length: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_symbol_int: c _: s [
	"
	   \brief Return the symbol int value.

	   \pre Z3_get_symbol_kind(s) == Z3_INT_SYMBOL

	   \sa Z3_mk_int_symbol

	   def_API('Z3_get_symbol_int', INT, (_in(CONTEXT), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _get_symbol_int: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_symbol_kind: c _: s [
	"
	   \brief Return \c Z3_INT_SYMBOL if the symbol was constructed
	   using #Z3_mk_int_symbol, and \c Z3_STRING_SYMBOL if the symbol
	   was constructed using #Z3_mk_string_symbol.

	   def_API('Z3_get_symbol_kind', UINT, (_in(CONTEXT), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _get_symbol_kind: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_symbol_string: c _: s [
	"
	   \brief Return the symbol name.

	   \pre Z3_get_symbol_kind(s) == Z3_STRING_SYMBOL

	   \warning The returned buffer is statically allocated by Z3. It will
	   be automatically deallocated when #Z3_del_context is invoked.
	   So, the buffer is invalidated in the next call to \c Z3_get_symbol_string.

	   \sa Z3_mk_string_symbol

	   def_API('Z3_get_symbol_string', STRING, (_in(CONTEXT), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _get_symbol_string: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_tactic_name: c _: i [
	"
	   \brief Return the name of the idx tactic.

	   \pre i < Z3_get_num_tactics(c)

	   def_API('Z3_get_tactic_name', STRING, (_in(CONTEXT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _get_tactic_name: c _: i.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_tuple_sort_field_decl: c _: t _: i [
	"
	   \brief Return the i-th field declaration (i.e., projection function declaration)
	   of the given tuple sort.

	   \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
	   \pre i < Z3_get_tuple_sort_num_fields(c, t)

	   \sa Z3_mk_tuple_sort
	   \sa Z3_get_sort_kind

	   def_API('Z3_get_tuple_sort_field_decl', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_tuple_sort_field_decl: c _: t _: i.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_tuple_sort_mk_decl: c _: t [
	"
	   \brief Return the constructor declaration of the given tuple
	   sort.

	   \pre Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT

	   \sa Z3_mk_tuple_sort
	   \sa Z3_get_sort_kind

	   def_API('Z3_get_tuple_sort_mk_decl', FUNC_DECL, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_tuple_sort_mk_decl: c _: t.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> get_tuple_sort_num_fields: c _: t [
	"
	   \brief Return the number of fields of the given tuple sort.

	   \pre Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT

	   \sa Z3_mk_tuple_sort
	   \sa Z3_get_sort_kind

	   def_API('Z3_get_tuple_sort_num_fields', UINT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _get_tuple_sort_num_fields: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> get_version: major _: minor _: build_number _: revision_number [
	"
	   \brief Return Z3 version number information.

	   \sa Z3_get_full_version

	   def_API('Z3_get_version', VOID, (_out(UINT), _out(UINT), _out(UINT), _out(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval majorExt minorExt build_numberExt revision_numberExt |

	majorExt := Z3Object externalU32ArrayFrom: major.
	minorExt := Z3Object externalU32ArrayFrom: minor.
	build_numberExt := Z3Object externalU32ArrayFrom: build_number.
	revision_numberExt := Z3Object externalU32ArrayFrom: revision_number.
	retval := lib _get_version: majorExt _: minorExt _: build_numberExt _: revision_numberExt.
	1 to: major size do: [ :i |
		| v |

		v := Z3Object externalArray: majorExt u32At: i.
		major at: i put: v.
	].
	majorExt notNil ifTrue:[majorExt free].
	1 to: minor size do: [ :i |
		| v |

		v := Z3Object externalArray: minorExt u32At: i.
		minor at: i put: v.
	].
	minorExt notNil ifTrue:[minorExt free].
	1 to: build_number size do: [ :i |
		| v |

		v := Z3Object externalArray: build_numberExt u32At: i.
		build_number at: i put: v.
	].
	build_numberExt notNil ifTrue:[build_numberExt free].
	1 to: revision_number size do: [ :i |
		| v |

		v := Z3Object externalArray: revision_numberExt u32At: i.
		revision_number at: i put: v.
	].
	revision_numberExt notNil ifTrue:[revision_numberExt free].
	^ retval


]

{ #category : #API }
Z3 class >> global_param_get: param_id _: param_value [
	"
	   \brief Get a global (or module) parameter.

	   Returns \c false if the parameter value does not exist.

	   \sa Z3_global_param_reset_all
	   \sa Z3_global_param_set

	   \remark This function cannot be invoked simultaneously from different threads without synchronization.
	   The result string stored in param_value is stored in shared location.

	   def_API('Z3_global_param_get', BOOL, (_in(STRING), _out(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type STRING not (yet) supported'


]

{ #category : #API }
Z3 class >> global_param_reset_all [
	"
	   \brief Restore the value of all global (and module) parameters.
	   This command will not affect already created objects (such as tactics and solvers).

	   \sa Z3_global_param_get
	   \sa Z3_global_param_set

	   def_API('Z3_global_param_reset_all', VOID, ())
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _global_param_reset_all.
	^ retval


]

{ #category : #API }
Z3 class >> global_param_set: param_id _: param_value [
	"
	   \brief Set a global (or module) parameter.
	   This setting is shared by all Z3 contexts.

	   When a Z3 module is initialized it will use the value of these parameters
	   when Z3_params objects are not provided.

	   The name of parameter can be composed of characters [a-z][A-Z], digits [0-9], '-' and '_'.
	   The character '.' is a delimiter (more later).

	   The parameter names are case-insensitive. The character '-' should be viewed as an 'alias' for '_'.
	   Thus, the following parameter names are considered equivalent: 'pp.decimal-precision'  and 'PP.DECIMAL_PRECISION'.

	   This function can be used to set parameters for a specific Z3 module.
	   This can be done by using <module-name>.<parameter-name>.
	   For example:
	   Z3_global_param_set('pp.decimal', 'true')
	   will set the parameter 'decimal' in the module 'pp' to true.

	   \sa Z3_global_param_get
	   \sa Z3_global_param_reset_all

	   def_API('Z3_global_param_set', VOID, (_in(STRING), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _global_param_set: param_id _: param_value.
	^ retval


]

{ #category : #API }
Z3 class >> goal_assert: c _: g _: a [
	"
	   \brief Add a new formula \c a to the given goal.
		The formula is split according to the following procedure that is applied
		until a fixed-point:
		   Conjunctions are split into separate formulas.
		   Negations are distributed over disjunctions, resulting in separate formulas.
		If the goal is \c false, adding new formulas is a no-op.
		If the formula \c a is \c true, then nothing is added.
		If the formula \c a is \c false, then the entire goal is replaced by the formula \c false.

	   def_API('Z3_goal_assert', VOID, (_in(CONTEXT), _in(GOAL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_convert_model: c _: g _: m [
	"
	   \brief Convert a model of the formulas of a goal to a model of an original goal.
	   The model may be null, in which case the returned model is valid if the goal was
	   established satisfiable.

	   def_API('Z3_goal_convert_model', MODEL, (_in(CONTEXT), _in(GOAL), _in(MODEL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_dec_ref: c _: g [
	"
	   \brief Decrement the reference counter of the given goal.

	   def_API('Z3_goal_dec_ref', VOID, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_depth: c _: g [
	"
	   \brief Return the depth of the given goal. It tracks how many transformations were applied to it.

	   def_API('Z3_goal_depth', UINT, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_formula: c _: g _: idx [
	"
	   \brief Return a formula from the given goal.

	   \pre idx < Z3_goal_size(c, g)

	   def_API('Z3_goal_formula', AST, (_in(CONTEXT), _in(GOAL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_inc_ref: c _: g [
	"
	   \brief Increment the reference counter of the given goal.

	   def_API('Z3_goal_inc_ref', VOID, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_inconsistent: c _: g [
	"
	   \brief Return \c true if the given goal contains the formula \c false.

	   def_API('Z3_goal_inconsistent', BOOL, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_is_decided_sat: c _: g [
	"
	   \brief Return \c true if the goal is empty, and it is precise or the product of a under approximation.

	   def_API('Z3_goal_is_decided_sat', BOOL, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_is_decided_unsat: c _: g [
	"
	   \brief Return \c true if the goal contains false, and it is precise or the product of an over approximation.

	   def_API('Z3_goal_is_decided_unsat', BOOL, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_num_exprs: c _: g [
	"
	   \brief Return the number of formulas, subformulas and terms in the given goal.

	   def_API('Z3_goal_num_exprs', UINT, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_precision: c _: g [
	"
	   \brief Return the 'precision' of the given goal. Goals can be transformed using over and under approximations.
	   A under approximation is applied when the objective is to find a model for a given goal.
	   An over approximation is applied when the objective is to find a proof for a given goal.

	   def_API('Z3_goal_precision', UINT, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_reset: c _: g [
	"
	   \brief Erase all formulas from the given goal.

	   def_API('Z3_goal_reset', VOID, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_size: c _: g [
	"
	   \brief Return the number of formulas in the given goal.

	   def_API('Z3_goal_size', UINT, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_to_dimacs_string: c _: g _: include_names [
	"
	   \brief Convert a goal into a DIMACS formatted string.
	   The goal must be in CNF. You can convert a goal to CNF
	   by applying the tseitin-cnf tactic. Bit-vectors are not automatically
	   converted to Booleans either, so if the caller intends to
	   preserve satisfiability, it should apply bit-blasting tactics.
	   Quantifiers and theory atoms will not be encoded.

	   def_API('Z3_goal_to_dimacs_string', STRING, (_in(CONTEXT), _in(GOAL), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_to_string: c _: g [
	"
	   \brief Convert a goal into a string.

	   def_API('Z3_goal_to_string', STRING, (_in(CONTEXT), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> goal_translate: source _: g _: target [
	"
	   \brief Copy a goal \c g from the context \c source to the context \c target.

	   def_API('Z3_goal_translate', GOAL, (_in(CONTEXT), _in(GOAL), _in(CONTEXT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> inc_ref: c _: a [
	"
	   \brief Increment the reference counter of the given AST.
	   The context \c c should have been created using #Z3_mk_context_rc.
	   This function is a NOOP if \c c was created using #Z3_mk_context.

	   def_API('Z3_inc_ref', VOID, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _inc_ref: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #initialization }
Z3 class >> initialize [
	lib := LibZ3 uniqueInstance

]

{ #category : #API }
Z3 class >> interrupt: c [
	"
	   \brief Interrupt the execution of a Z3 procedure.
	   This procedure can be used to interrupt: solvers, simplifiers and tactics.

	   def_API('Z3_interrupt', VOID, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _interrupt: c.
	c errorCheck.
	^ retval


]

{ #category : #utilities }
Z3 class >> isVersion: versionA greaterThan: versionB [
	1 to: (versionA size max: versionB size) do:[:i | 
		(versionA at: i ifAbsent: 0) > (versionB at: i ifAbsent: 0) ifTrue:[ ^ true ].
		(versionA at: i ifAbsent: 0) < (versionB at: i ifAbsent: 0) ifTrue:[ ^ false ].
	].
	^ false
]

{ #category : #utilities }
Z3 class >> isVersionGreaterThan: version [
	"Return true if current Z3 version is greater than given `version`"
	^ self isVersion: self getVersion greaterThan: version
]

{ #category : #API }
Z3 class >> is_algebraic_number: c _: a [
	"
	   \brief Return \c true if the given AST is a real algebraic number.

	   def_API('Z3_is_algebraic_number', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _is_algebraic_number: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_app: c _: a [
	"
	  def_API('Z3_is_app', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _is_app: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_as_array: c _: a [
	"
	   \brief The \ccode{(_ as-array f)} AST node is a construct for assigning interpretations for arrays in Z3.
	   It is the array such that forall indices \c i we have that \ccode{(select (_ as-array f) i)} is equal to \ccode{(f i)}.
	   This procedure returns \c true if the \c a is an \c as-array AST node.

	   Z3 current solvers have minimal support for \c as_array nodes.

	   \sa Z3_get_as_array_func_decl

	   def_API('Z3_is_as_array', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _is_as_array: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_char_sort: c _: s [
	"
	   \brief Check if \c s is a character sort.

	   def_API('Z3_is_char_sort', BOOL, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _is_char_sort: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_eq_ast: c _: t1 _: t2 [
	"
	   \brief Compare terms.

	   def_API('Z3_is_eq_ast', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _is_eq_ast: c _: t1 _: t2.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_eq_func_decl: c _: f1 _: f2 [
	"
	   \brief Compare terms.

	   def_API('Z3_is_eq_func_decl', BOOL, (_in(CONTEXT), _in(FUNC_DECL), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f1 ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	f2 ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _is_eq_func_decl: c _: f1 _: f2.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_eq_sort: c _: s1 _: s2 [
	"
	   \brief compare sorts.

	   def_API('Z3_is_eq_sort', BOOL, (_in(CONTEXT), _in(SORT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s1 ensureValidZ3ASTOfKind: SORT_AST.
	s2 ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _is_eq_sort: c _: s1 _: s2.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_lambda: c _: a [
	"
	   \brief Determine if ast is a lambda expression.

	   \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST

	   def_API('Z3_is_lambda', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _is_lambda: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_numeral_ast: c _: a [
	"
	  def_API('Z3_is_numeral_ast', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _is_numeral_ast: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_quantifier_exists: c _: a [
	"
	   \brief Determine if ast is an existential quantifier.


	   def_API('Z3_is_quantifier_exists', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _is_quantifier_exists: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_quantifier_forall: c _: a [
	"
	   \brief Determine if an ast is a universal quantifier.

	   def_API('Z3_is_quantifier_forall', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _is_quantifier_forall: c _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_re_sort: c _: s [
	"
	   \brief Check if \c s is a regular expression sort.

	   def_API('Z3_is_re_sort', BOOL, (_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _is_re_sort: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_seq_sort: c _: s [
	"
	   \brief Check if \c s is a sequence sort.

	   def_API('Z3_is_seq_sort', BOOL, (_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _is_seq_sort: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_string: c _: s [
	"
	   \brief Determine if \c s is a string constant.

	   def_API('Z3_is_string', BOOL, (_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _is_string: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_string_sort: c _: s [
	"
	   \brief Check if \c s is a string sort.

	   def_API('Z3_is_string_sort', BOOL, (_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _is_string_sort: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> is_well_sorted: c _: t [
	"
	   \brief Return \c true if the given expression \c t is well sorted.

	   def_API('Z3_is_well_sorted', BOOL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _is_well_sorted: c _: t.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> mk_add: c _: num_args _: args [
	"
	   \brief Create an AST node representing \ccode{args[0] + ... + args[num_args-1]}.

	   The array \c args must have \c num_args elements.
	   All arguments must have int or real sort.

	   \remark The number of arguments must be greater than zero.

	   def_API('Z3_mk_add', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_add: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_and: c _: num_args _: args [
	"
	   \brief Create an AST node representing \ccode{args[0] and ... and args[num_args-1]}.

	   The array \c args must have \c num_args elements.
	   All arguments must have Boolean sort.

	   \remark The number of arguments must be greater than zero.

	   def_API('Z3_mk_and', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_and: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_app: c _: d _: num_args _: args [
	"
	   \brief Create a constant or function application.

	   \sa Z3_mk_fresh_func_decl
	   \sa Z3_mk_func_decl
	   \sa Z3_mk_rec_func_decl

	   def_API('Z3_mk_app', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	d ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_app: c _: d _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_array_default: c _: array [
	"
		\brief Access the array default value.
		Produces the default range value, for arrays that can be represented as
		finite maps with a default range value.

		\param c logical context.
		\param array array value whose default range value is accessed.

		def_API('Z3_mk_array_default', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	array ensureValidZ3AST.
	retval := lib _mk_array_default: c _: array.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_array_ext: c _: arg1 _: arg2 [
	"
	   \brief Create array extensionality index given two arrays with the same sort.
			  The meaning is given by the axiom:
			  (=> (= (select A (array-ext A B)) (select B (array-ext A B))) (= A B))

	   def_API('Z3_mk_array_ext', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	arg2 ensureValidZ3AST.
	retval := lib _mk_array_ext: c _: arg1 _: arg2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_array_sort: c _: domain _: range [
	"
	   \brief Create an array type.

	   We usually represent the array type as: \ccode{[domain -> range]}.
	   Arrays are usually used to model the heap/memory in software verification.

	   \sa Z3_mk_select
	   \sa Z3_mk_store

	   def_API('Z3_mk_array_sort', SORT, (_in(CONTEXT), _in(SORT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	domain ensureValidZ3ASTOfKind: SORT_AST.
	range ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_array_sort: c _: domain _: range.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_array_sort_n: c _: n _: domain _: range [
	"
	   \brief Create an array type with N arguments

	   \sa Z3_mk_select_n
	   \sa Z3_mk_store_n

	   def_API('Z3_mk_array_sort_n', SORT, (_in(CONTEXT), _in(UINT), _in_array(1, SORT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval domainExt |

	c ensureValidZ3Object.
	domain ensureValidZ3ASTArrayOfKind: SORT_AST.
	range ensureValidZ3ASTOfKind: SORT_AST.
	domainExt := self externalArrayFrom: domain.
	retval := lib _mk_array_sort_n: c _: n _: domainExt _: range.
	domainExt notNil ifTrue:[domainExt free].
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_as_array: c _: f [
	"
	   \brief Create array with the same interpretation as a function.
	   The array satisfies the property (f x) = (select (_ as-array f) x) 
	   for every argument x.

	   def_API('Z3_mk_as_array', AST, (_in(CONTEXT), _in(FUNC_DECL)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _mk_as_array: c _: f.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_ast_map: c [
	"
	\brief Return an empty mapping from AST to AST

	\remark Reference counting must be used to manage AST maps, even when the Z3_context was
	created using #Z3_mk_context instead of #Z3_mk_context_rc.

	def_API('Z3_mk_ast_map', AST_MAP, (_in(CONTEXT),) )
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> mk_ast_vector: c [
	"
	   \brief Return an empty AST vector.

	   \remark Reference counting must be used to manage AST vectors, even when the Z3_context was
	   created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_ast_vector', AST_VECTOR, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_ast_vector: c.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_atleast: c _: num_args _: args _: k [
	"
	   \brief Pseudo-Boolean relations.

	   Encode p1 + p2 + ... + pn >= k

	   def_API('Z3_mk_atleast', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_atleast: c _: num_args _: argsExt _: k.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_atmost: c _: num_args _: args _: k [
	"
	   \brief Pseudo-Boolean relations.

	   Encode p1 + p2 + ... + pn <= k

	   def_API('Z3_mk_atmost', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_atmost: c _: num_args _: argsExt _: k.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bit2bool: c _: i _: t1 [
	"
	   \brief Extracts the bit at position \ccode{i} of a bit-vector and 
	   yields a boolean.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_bit2bool', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_bit2bool: c _: i _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bool_sort: c [
	"
	   \brief Create the Boolean type.

	   This type is used to create propositional variables and predicates.

	   def_API('Z3_mk_bool_sort', SORT, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_bool_sort: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bound: c _: index _: ty [
	"
	   \brief Create a bound variable.

	   Bound variables are indexed by de-Bruijn indices. It is perhaps easiest to explain
	   the meaning of de-Bruijn indices by indicating the compilation process from
	   non-de-Bruijn formulas to de-Bruijn format.

	   \verbatim
	   abs(forall (x1) phi) = forall (x1) abs1(phi, x1, 0)
	   abs(forall (x1, x2) phi) = abs(forall (x1) abs(forall (x2) phi))
	   abs1(x, x, n) = b_n
	   abs1(y, x, n) = y
	   abs1(f(t1,...,tn), x, n) = f(abs1(t1,x,n), ..., abs1(tn,x,n))
	   abs1(forall (x1) phi, x, n) = forall (x1) (abs1(phi, x, n+1))
	   \endverbatim

	   The last line is significant: the index of a bound variable is different depending
	   on the scope in which it appears. The deeper x appears, the higher is its
	   index.

	   \param c logical context
	   \param index de-Bruijn index
	   \param ty sort of the bound variable

	   \sa Z3_mk_forall
	   \sa Z3_mk_exists

	   def_API('Z3_mk_bound', AST, (_in(CONTEXT), _in(UINT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_bound: c _: index _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bv2int: c _: t1 _: is_signed [
	"
	   \brief Create an integer from the bit-vector argument \c t1.
	   If \c is_signed is false, then the bit-vector \c t1 is treated as unsigned.
	   So the result is non-negative
	   and in the range \ccode{[0..2^N-1]}, where N are the number of bits in \c t1.
	   If \c is_signed is true, \c t1 is treated as a signed bit-vector.


	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_bv2int', AST, (_in(CONTEXT), _in(AST), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_bv2int: c _: t1 _: is_signed.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bv_numeral: c _: sz _: bits [
	"
	   \brief create a bit-vector numeral from a vector of Booleans.
	   
	   \sa Z3_mk_numeral
	   def_API('Z3_mk_bv_numeral', AST, (_in(CONTEXT), _in(UINT), _in_array(1, BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type BOOL not (yet) supported'


]

{ #category : #API }
Z3 class >> mk_bv_sort: c _: sz [
	"
	   \brief Create a bit-vector type of the given size.

	   This type can also be seen as a machine integer.

	   \remark The size of the bit-vector type must be greater than zero.

	   def_API('Z3_mk_bv_sort', SORT, (_in(CONTEXT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_bv_sort: c _: sz.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvadd: c _: t1 _: t2 [
	"
		\brief Standard two's complement addition.

		The nodes \c t1 and \c t2 must have the same bit-vector sort.

		def_API('Z3_mk_bvadd', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvadd: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvadd_no_overflow: c _: t1 _: t2 _: is_signed [
	"
	   \brief Create a predicate that checks that the bit-wise addition
	   of \c t1 and \c t2 does not overflow.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvadd_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvadd_no_overflow: c _: t1 _: t2 _: is_signed.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvadd_no_underflow: c _: t1 _: t2 [
	"
	   \brief Create a predicate that checks that the bit-wise signed addition
	   of \c t1 and \c t2 does not underflow.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvadd_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvadd_no_underflow: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvand: c _: t1 _: t2 [
	"
	   \brief Bitwise and.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvand', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvand: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvashr: c _: t1 _: t2 [
	"
	   \brief Arithmetic shift right.

	   It is like logical shift right except that the most significant
	   bits of the result always copy the most significant bit of the
	   second argument.

	   The semantics of shift operations varies between environments. This
	   definition does not necessarily capture directly the semantics of the
	   programming language or assembly architecture you are modeling.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvashr', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvashr: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvlshr: c _: t1 _: t2 [
	"
	   \brief Logical shift right.

	   It is equivalent to unsigned division by \ccode{2^x} where \c x is the
	   value of the third argument.

	   NB. The semantics of shift operations varies between environments. This
	   definition does not necessarily capture directly the semantics of the
	   programming language or assembly architecture you are modeling.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvlshr', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvlshr: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvmul: c _: t1 _: t2 [
	"
		\brief Standard two's complement multiplication.

		The nodes \c t1 and \c t2 must have the same bit-vector sort.

		def_API('Z3_mk_bvmul', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvmul: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvmul_no_overflow: c _: t1 _: t2 _: is_signed [
	"
	   \brief Create a predicate that checks that the bit-wise multiplication
	   of \c t1 and \c t2 does not overflow.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvmul_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvmul_no_overflow: c _: t1 _: t2 _: is_signed.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvmul_no_underflow: c _: t1 _: t2 [
	"
	   \brief Create a predicate that checks that the bit-wise signed multiplication
	   of \c t1 and \c t2 does not underflow.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvmul_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvmul_no_underflow: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvnand: c _: t1 _: t2 [
	"
	   \brief Bitwise nand.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvnand', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvnand: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvneg: c _: t1 [
	"
	   \brief Standard two's complement unary minus.

	   The node \c t1 must have bit-vector sort.

	   def_API('Z3_mk_bvneg', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_bvneg: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvneg_no_overflow: c _: t1 [
	"
	   \brief Check that bit-wise negation does not overflow when
	   \c t1 is interpreted as a signed bit-vector.

	   The node \c t1 must have bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvneg_no_overflow', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_bvneg_no_overflow: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvnor: c _: t1 _: t2 [
	"
	   \brief Bitwise nor.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvnor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvnor: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvnot: c _: t1 [
	"
	   \brief Bitwise negation.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_bvnot', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_bvnot: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvor: c _: t1 _: t2 [
	"
	   \brief Bitwise or.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvor: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvredand: c _: t1 [
	"
	   \brief Take conjunction of bits in vector, return vector of length 1.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_bvredand', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_bvredand: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvredor: c _: t1 [
	"
	   \brief Take disjunction of bits in vector, return vector of length 1.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_bvredor', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_bvredor: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsdiv: c _: t1 _: t2 [
	"
		\brief Two's complement signed division.

		It is defined in the following way:

		- The \c floor of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 >= 0}.

		- The \c ceiling of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 < 0}.

		If \ccode{t2} is zero, then the result is undefined.

		The nodes \c t1 and \c t2 must have the same bit-vector sort.

		def_API('Z3_mk_bvsdiv', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsdiv: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsdiv_no_overflow: c _: t1 _: t2 [
	"
	   \brief Create a predicate that checks that the bit-wise signed division
	   of \c t1 and \c t2 does not overflow.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvsdiv_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsdiv_no_overflow: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsge: c _: t1 _: t2 [
	"
	   \brief Two's complement signed greater than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvsge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsge: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsgt: c _: t1 _: t2 [
	"
	   \brief Two's complement signed greater than.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvsgt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsgt: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvshl: c _: t1 _: t2 [
	"
	   \brief Shift left.

	   It is equivalent to multiplication by \ccode{2^x} where \c x is the value of the
	   third argument.

	   NB. The semantics of shift operations varies between environments. This
	   definition does not necessarily capture directly the semantics of the
	   programming language or assembly architecture you are modeling.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvshl', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvshl: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsle: c _: t1 _: t2 [
	"
	   \brief Two's complement signed less than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvsle', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsle: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvslt: c _: t1 _: t2 [
	"
	   \brief Two's complement signed less than.

	   It abbreviates:
	   \code
		(or (and (= (extract[|m-1|:|m-1|] t1) bit1)
				(= (extract[|m-1|:|m-1|] t2) bit0))
			(and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
				(bvult t1 t2)))
	   \endcode

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvslt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvslt: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsmod: c _: t1 _: t2 [
	"
	   \brief Two's complement signed remainder (sign follows divisor).

	   If \ccode{t2} is zero, then the result is undefined.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   \sa Z3_mk_bvsrem

	   def_API('Z3_mk_bvsmod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsmod: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsrem: c _: t1 _: t2 [
	"
	   \brief Two's complement signed remainder (sign follows dividend).

	   It is defined as \ccode{t1 - (t1 /s t2) * t2}, where \ccode{/s} represents signed division.
	   The most significant bit (sign) of the result is equal to the most significant bit of \c t1.

	   If \ccode{t2} is zero, then the result is undefined.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   \sa Z3_mk_bvsmod

	   def_API('Z3_mk_bvsrem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsrem: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsub: c _: t1 _: t2 [
	"
		\brief Standard two's complement subtraction.

		The nodes \c t1 and \c t2 must have the same bit-vector sort.

		def_API('Z3_mk_bvsub', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsub: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsub_no_overflow: c _: t1 _: t2 [
	"
	   \brief Create a predicate that checks that the bit-wise signed subtraction
	   of \c t1 and \c t2 does not overflow.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvsub_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsub_no_overflow: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvsub_no_underflow: c _: t1 _: t2 _: is_signed [
	"
	   \brief Create a predicate that checks that the bit-wise subtraction
	   of \c t1 and \c t2 does not underflow.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.
	   The returned node is of sort Bool.

	   def_API('Z3_mk_bvsub_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvsub_no_underflow: c _: t1 _: t2 _: is_signed.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvudiv: c _: t1 _: t2 [
	"
		\brief Unsigned division.

		It is defined as the \c floor of \ccode{t1/t2} if \c t2 is
		different from zero. If \ccode{t2} is zero, then the result
		is undefined.

		The nodes \c t1 and \c t2 must have the same bit-vector sort.

		def_API('Z3_mk_bvudiv', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvudiv: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvuge: c _: t1 _: t2 [
	"
	   \brief Unsigned greater than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvuge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvuge: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvugt: c _: t1 _: t2 [
	"
	   \brief Unsigned greater than.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvugt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvugt: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvule: c _: t1 _: t2 [
	"
	   \brief Unsigned less than or equal to.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvule', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvule: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvult: c _: t1 _: t2 [
	"
	   \brief Unsigned less than.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvult', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvult: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvurem: c _: t1 _: t2 [
	"
	   \brief Unsigned remainder.

	   It is defined as \ccode{t1 - (t1 /u t2) * t2}, where \ccode{/u} represents unsigned division.

	   If \ccode{t2} is zero, then the result is undefined.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvurem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvurem: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvxnor: c _: t1 _: t2 [
	"
	   \brief Bitwise xnor.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvxnor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvxnor: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_bvxor: c _: t1 _: t2 [
	"
	   \brief Bitwise exclusive-or.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_bvxor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_bvxor: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_char: c _: ch [
	"
	   \brief Create a character literal
	   def_API('Z3_mk_char', AST, (_in(CONTEXT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_char: c _: ch.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_char_from_bv: c _: bv [
	"
		 \brief Create a character from a bit-vector (code point).

		 def_API('Z3_mk_char_from_bv', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	bv ensureValidZ3AST.
	retval := lib _mk_char_from_bv: c _: bv.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_char_is_digit: c _: ch [
	"
		 \brief Create a check if the character is a digit.

		 def_API('Z3_mk_char_is_digit', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ch ensureValidZ3AST.
	retval := lib _mk_char_is_digit: c _: ch.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_char_le: c _: ch1 _: ch2 [
	"
		 \brief Create less than or equal to between two characters.

		 def_API('Z3_mk_char_le', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ch1 ensureValidZ3AST.
	ch2 ensureValidZ3AST.
	retval := lib _mk_char_le: c _: ch1 _: ch2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_char_sort: c [
	"
	   \brief Create a sort for unicode characters.

	   The sort for characters can be changed to ASCII by setting
	   the global parameter \c encoding to \c ascii, or alternative
	   to 16 bit characters by setting \c encoding to \c bmp.

	   def_API('Z3_mk_char_sort', SORT, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_char_sort: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_char_to_bv: c _: ch [
	"
		 \brief Create a bit-vector (code point) from character.

		 def_API('Z3_mk_char_to_bv', AST, (_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ch ensureValidZ3AST.
	retval := lib _mk_char_to_bv: c _: ch.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_char_to_int: c _: ch [
	"
		 \brief Create an integer (code point) from character.

		 def_API('Z3_mk_char_to_int', AST, (_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ch ensureValidZ3AST.
	retval := lib _mk_char_to_int: c _: ch.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_concat: c _: t1 _: t2 [
	"
	   \brief Concatenate the given bit-vectors.

	   The nodes \c t1 and \c t2 must have (possibly different) bit-vector sorts

	   The result is a bit-vector of size \ccode{n1+n2}, where \c n1 (\c n2) is the size
	   of \c t1 (\c t2).

	   def_API('Z3_mk_concat', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_concat: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_config [
	"
		\brief Create a configuration object for the Z3 context object.

		Configurations are created in order to assign parameters prior to creating
		contexts for Z3 interaction. For example, if the users wishes to use proof
		generation, then call:

		\ccode{Z3_set_param_value(cfg\, 'proof'\, 'true')}

		\remark In previous versions of Z3, the \c Z3_config was used to store
		global and module configurations. Now, we should use \c Z3_global_param_set.

		The following parameters can be set:

			- proof  (Boolean)           Enable proof generation
			- debug_ref_count (Boolean)  Enable debug support for Z3_ast reference counting
			- trace  (Boolean)           Tracing support for VCC
			- trace_file_name (String)   Trace out file for VCC traces
			- timeout (unsigned)         default timeout (in milliseconds) used for solvers
			- well_sorted_check          type checker
			- auto_config                use heuristics to automatically select solver and configure it
			- model                      model generation for solvers, this parameter can be overwritten when creating a solver
			- model_validate             validate models produced by solvers
			- unsat_core                 unsat-core generation for solvers, this parameter can be overwritten when creating a solver
			- encoding                   the string encoding used internally (must be either 'unicode' - 18 bit, 'bmp' - 16 bit or 'ascii' - 8 bit)

		\sa Z3_set_param_value
		\sa Z3_del_config

		def_API('Z3_mk_config', CONFIG, ())
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _mk_config.
	^ retval


]

{ #category : #API }
Z3 class >> mk_const: c _: s _: ty [
	"
	   \brief Declare and create a constant.

	   This function is a shorthand for:
	   \code
	   Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
	   Z3_ast n            = Z3_mk_app(c, d, 0, 0);
	   \endcode

	   \sa Z3_mk_app
	   \sa Z3_mk_fresh_const
	   \sa Z3_mk_func_decl

	   def_API('Z3_mk_const', AST, (_in(CONTEXT), _in(SYMBOL), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_const: c _: s _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_const_array: c _: domain _: v [
	"
		\brief Create the constant array.

		The resulting term is an array, such that a \c select on an arbitrary index
		produces the value \c v.

		\param c logical context.
		\param domain domain sort for the array.
		\param v value that the array maps to.

		def_API('Z3_mk_const_array', AST, (_in(CONTEXT), _in(SORT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	domain ensureValidZ3ASTOfKind: SORT_AST.
	v ensureValidZ3AST.
	retval := lib _mk_const_array: c _: domain _: v.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_constructor: c _: name _: recognizer _: num_fields _: field_names _: sorts _: sort_refs [
	"
	   \brief Create a constructor.

	   \param c logical context.
	   \param name constructor name.
	   \param recognizer name of recognizer function.
	   \param num_fields number of fields in constructor.
	   \param field_names names of the constructor fields.
	   \param sorts field sorts, 0 if the field sort refers to a recursive sort.
	   \param sort_refs reference to datatype sort that is an argument to the constructor; if the corresponding
						sort reference is 0, then the value in sort_refs should be an index referring to
						one of the recursive datatypes that is declared.

	   \sa Z3_del_constructor
	   \sa Z3_mk_constructor_list
	   \sa Z3_query_constructor

	   def_API('Z3_mk_constructor', CONSTRUCTOR, (_in(CONTEXT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(3, SYMBOL), _in_array(3, SORT), _in_array(3, UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval field_namesExt sortsExt sort_refsExt |

	c ensureValidZ3Object.
	name ensureValidZ3Object.
	recognizer ensureValidZ3Object.
	field_namesExt := self externalArrayFrom: field_names.
	sortsExt := self externalArrayFrom: sorts.
	sort_refsExt := Z3Object externalU32ArrayFrom: sort_refs.
	retval := lib _mk_constructor: c _: name _: recognizer _: num_fields _: field_namesExt _: sortsExt _: sort_refsExt.
	field_namesExt notNil ifTrue:[field_namesExt free].
	sortsExt notNil ifTrue:[sortsExt free].
	sort_refsExt notNil ifTrue:[sort_refsExt free].
	c errorCheck.
	^ Z3Constructor fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_constructor_list: c _: num_constructors _: constructors [
	"
	   \brief Create list of constructors.

	   \param c logical context.
	   \param num_constructors number of constructors in list.
	   \param constructors list of constructors.

	   \sa Z3_del_constructor_list
	   \sa Z3_mk_constructor

	   def_API('Z3_mk_constructor_list', CONSTRUCTOR_LIST, (_in(CONTEXT), _in(UINT), _in_array(1, CONSTRUCTOR)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval constructorsExt |

	c ensureValidZ3Object.
	constructors ensureValidZ3ObjectArray.
	constructorsExt := self externalArrayFrom: constructors.
	retval := lib _mk_constructor_list: c _: num_constructors _: constructorsExt.
	constructorsExt notNil ifTrue:[constructorsExt free].
	c errorCheck.
	^ Z3ConstructorList fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_context: c [
	"
	   \brief Create a context using the given configuration.

	   After a context is created, the configuration cannot be changed,
	   although some parameters can be changed using #Z3_update_param_value.
	   All main interaction with Z3 happens in the context of a \c Z3_context.

	   In contrast to #Z3_mk_context_rc, the life time of \c Z3_ast objects
	   are determined by the scope level of #Z3_solver_push and #Z3_solver_pop.
	   In other words, a \c Z3_ast object remains valid until there is a
	   call to #Z3_solver_pop that takes the current scope below the level where
	   the object was created.

	   Note that all other reference counted objects, including \c Z3_model,
	   \c Z3_solver, \c Z3_func_interp have to be managed by the caller.
	   Their reference counts are not handled by the context.

	   \remark Thread safety: objects created using a given context should not be 
	   accessed from different threads without synchronization. In other words, 
	   operations on a context are not thread safe. To use Z3 from different threads
	   create separate context objects. The \c Z3_translate, \c Z3_solver_translate, 
	   \c Z3_model_translate, \c Z3_goal_translate
	   methods are exposed to allow copying state from one context to another.

	   \remark
	   - \c Z3_sort, \c Z3_func_decl, \c Z3_app, \c Z3_pattern are \c Z3_ast's.
	   - Z3 uses hash-consing, i.e., when the same \c Z3_ast is created twice,
		 Z3 will return the same pointer twice.

	   \sa Z3_del_context

	   def_API('Z3_mk_context', CONTEXT, (_in(CONFIG),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_context: c.
	^ retval


]

{ #category : #API }
Z3 class >> mk_context_rc: c [
	"
	   \brief Create a context using the given configuration.
	   This function is similar to #Z3_mk_context. However,
	   in the context returned by this function, the user
	   is responsible for managing \c Z3_ast reference counters.
	   Managing reference counters is a burden and error-prone,
	   but allows the user to use the memory more efficiently.
	   The user must invoke #Z3_inc_ref for any \c Z3_ast returned
	   by Z3, and #Z3_dec_ref whenever the \c Z3_ast is not needed
	   anymore. This idiom is similar to the one used in
	   BDD (binary decision diagrams) packages such as CUDD.

	   Remarks:

	   - \c Z3_sort, \c Z3_func_decl, \c Z3_app, \c Z3_pattern are \c Z3_ast's.
	   - After a context is created, the configuration cannot be changed.
	   - All main interaction with Z3 happens in the context of a \c Z3_context.
	   - Z3 uses hash-consing, i.e., when the same \c Z3_ast is created twice,
		 Z3 will return the same pointer twice.

	   def_API('Z3_mk_context_rc', CONTEXT, (_in(CONFIG),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_context_rc: c.
	^ retval


]

{ #category : #API }
Z3 class >> mk_datatype: c _: name _: num_constructors _: constructors [
	"
	   \brief Create datatype, such as lists, trees, records, enumerations or unions of records.
	   The datatype may be recursive. Return the datatype sort.

	   \param c logical context.
	   \param name name of datatype.
	   \param num_constructors number of constructors passed in.
	   \param constructors array of constructor containers.

	   \sa Z3_mk_constructor
	   \sa Z3_mk_constructor_list
	   \sa Z3_mk_datatypes

	   def_API('Z3_mk_datatype', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _inout_array(2, CONSTRUCTOR)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval constructorsExt |

	c ensureValidZ3Object.
	name ensureValidZ3Object.
	constructors ensureValidZ3ObjectArray.
	constructorsExt := self externalArrayFrom: constructors.
	retval := lib _mk_datatype: c _: name _: num_constructors _: constructorsExt.
	1 to: constructors size do: [ :i |
		| v |

		v := Z3Constructor fromExternalAddress: (Z3Object externalArray: constructorsExt pointerAt: i) inContext: c.
		constructors at: i put: v.
	].
	constructorsExt notNil ifTrue:[constructorsExt free].
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_datatype_sort: c _: name [
	"
	   \brief create a forward reference to a recursive datatype being declared.
	   The forward reference can be used in a nested occurrence: the range of an array
	   or as element sort of a sequence. The forward reference should only be used when
	   used in an accessor for a recursive datatype that gets declared.

	   Forward references can replace the use sort references, that are unsigned integers
	   in the \c Z3_mk_constructor call

	   def_API('Z3_mk_datatype_sort', SORT, (_in(CONTEXT), _in(SYMBOL)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	name ensureValidZ3Object.
	retval := lib _mk_datatype_sort: c _: name.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_datatypes: c _: num_sorts _: sort_names _: sorts _: constructor_lists [
	"
	   \brief Create mutually recursive datatypes.

	   \param c logical context.
	   \param num_sorts number of datatype sorts.
	   \param sort_names names of datatype sorts.
	   \param sorts array of datatype sorts.
	   \param constructor_lists list of constructors, one list per sort.

	   \sa Z3_mk_constructor
	   \sa Z3_mk_constructor_list
	   \sa Z3_mk_datatype

	   def_API('Z3_mk_datatypes', VOID, (_in(CONTEXT), _in(UINT), _in_array(1, SYMBOL), _out_array(1, SORT), _inout_array(1, CONSTRUCTOR_LIST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval sort_namesExt sortsExt constructor_listsExt |

	c ensureValidZ3Object.
	sort_names ensureValidZ3ObjectArray.
	constructor_lists ensureValidZ3ObjectArray.
	sort_namesExt := self externalArrayFrom: sort_names.
	sortsExt := self externalArrayFrom: sorts.
	constructor_listsExt := self externalArrayFrom: constructor_lists.
	retval := lib _mk_datatypes: c _: num_sorts _: sort_namesExt _: sortsExt _: constructor_listsExt.
	sort_namesExt notNil ifTrue:[sort_namesExt free].
	1 to: sorts size do: [ :i |
		| v |

		v := Z3Sort fromExternalAddress: (Z3Object externalArray: sortsExt pointerAt: i) inContext: c.
		sorts at: i put: v.
	].
	sortsExt notNil ifTrue:[sortsExt free].
	1 to: constructor_lists size do: [ :i |
		| v |

		v := Z3ConstructorList fromExternalAddress: (Z3Object externalArray: constructor_listsExt pointerAt: i) inContext: c.
		constructor_lists at: i put: v.
	].
	constructor_listsExt notNil ifTrue:[constructor_listsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> mk_distinct: c _: num_args _: args [
	"
	   \brief Create an AST node representing \ccode{distinct(args[0], ..., args[num_args-1])}.

	   The \c distinct construct is used for declaring the arguments pairwise distinct.
	   That is, \ccode{Forall 0 <= i < j < num_args. not args[i] = args[j]}.

	   All arguments must have the same sort.

	   \remark The number of arguments of a distinct construct must be greater than one.

	   def_API('Z3_mk_distinct', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_distinct: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_div: c _: arg1 _: arg2 [
	"
	   \brief Create an AST node representing \ccode{arg1 div arg2}.

	   The arguments must either both have int type or both have real type.
	   If the arguments have int type, then the result type is an int type, otherwise the
	   the result type is real.

	   def_API('Z3_mk_div', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	arg2 ensureValidZ3AST.
	retval := lib _mk_div: c _: arg1 _: arg2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_divides: c _: t1 _: t2 [
	"
		\brief Create division predicate.

		The nodes \c t1 and \c t2 must be of integer sort.
		The predicate is true when \c t1 divides \c t2. For the predicate to be part of 
		linear integer arithmetic, the first argument \c t1 must be a non-zero integer.
		
		def_API('Z3_mk_divides', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_divides: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_empty_set: c _: domain [
	"
		\brief Create the empty set.

		def_API('Z3_mk_empty_set', AST, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	domain ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_empty_set: c _: domain.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_enumeration_sort: c _: name _: n _: enum_names _: enum_consts _: enum_testers [
	"
	   \brief Create a enumeration sort.

	   An enumeration sort with \c n elements.
	   This function will also declare the functions corresponding to the enumerations.

	   \param c logical context
	   \param name name of the enumeration sort.
	   \param n number of elements in enumeration sort.
	   \param enum_names names of the enumerated elements.
	   \param enum_consts constants corresponding to the enumerated elements.
	   \param enum_testers predicates testing if terms of the enumeration sort correspond to an enumeration.

	   For example, if this function is called with three symbols A, B, C and the name S, then
	   \c s is a sort whose name is S, and the function returns three terms corresponding to A, B, C in
	   \c enum_consts. The array \c enum_testers has three predicates of type \ccode{(s -> Bool)}.
	   The first predicate (corresponding to A) is true when applied to A, and false otherwise.
	   Similarly for the other predicates.

	   def_API('Z3_mk_enumeration_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SYMBOL), _out_array(2, FUNC_DECL), _out_array(2, FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval enum_namesExt enum_constsExt enum_testersExt |

	c ensureValidZ3Object.
	name ensureValidZ3Object.
	enum_names ensureValidZ3ObjectArray.
	enum_namesExt := self externalArrayFrom: enum_names.
	enum_constsExt := self externalArrayFrom: enum_consts.
	enum_testersExt := self externalArrayFrom: enum_testers.
	retval := lib _mk_enumeration_sort: c _: name _: n _: enum_namesExt _: enum_constsExt _: enum_testersExt.
	enum_namesExt notNil ifTrue:[enum_namesExt free].
	1 to: enum_consts size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: enum_constsExt pointerAt: i) inContext: c.
		enum_consts at: i put: v.
	].
	enum_constsExt notNil ifTrue:[enum_constsExt free].
	1 to: enum_testers size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: enum_testersExt pointerAt: i) inContext: c.
		enum_testers at: i put: v.
	].
	enum_testersExt notNil ifTrue:[enum_testersExt free].
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_eq: c _: l _: r [
	"
		\brief Create an AST node representing \ccode{l = r}.

		The nodes \c l and \c r must have the same type.

		def_API('Z3_mk_eq', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	l ensureValidZ3AST.
	r ensureValidZ3AST.
	retval := lib _mk_eq: c _: l _: r.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_exists: c _: weight _: num_patterns _: patterns _: num_decls _: sorts _: decl_names _: body [
	"
	   \brief Create an exists formula. Similar to #Z3_mk_forall.

	   \sa Z3_mk_pattern
	   \sa Z3_mk_bound
	   \sa Z3_mk_forall
	   \sa Z3_mk_quantifier

	   def_API('Z3_mk_exists', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, PATTERN), _in(UINT), _in_array(4, SORT), _in_array(4, SYMBOL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval patternsExt sortsExt decl_namesExt |

	c ensureValidZ3Object.
	patterns ensureValidZ3ObjectArray.
	sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	decl_names ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	patternsExt := self externalArrayFrom: patterns.
	sortsExt := self externalArrayFrom: sorts.
	decl_namesExt := self externalArrayFrom: decl_names.
	retval := lib _mk_exists: c _: weight _: num_patterns _: patternsExt _: num_decls _: sortsExt _: decl_namesExt _: body.
	patternsExt notNil ifTrue:[patternsExt free].
	sortsExt notNil ifTrue:[sortsExt free].
	decl_namesExt notNil ifTrue:[decl_namesExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_exists_const: c _: weight _: num_bound _: bound _: num_patterns _: patterns _: body [
	"
	   \brief Similar to #Z3_mk_forall_const.

	   \brief Create an existential quantifier using a list of constants that
	   will form the set of bound variables.

	   \param c logical context.
	   \param weight quantifiers are associated with weights indicating the importance of using
			  the quantifier during instantiation. By default, pass the weight 0.
	   \param num_bound number of constants to be abstracted into bound variables.
	   \param bound array of constants to be abstracted into bound variables.
	   \param num_patterns number of patterns.
	   \param patterns array containing the patterns created using #Z3_mk_pattern.
	   \param body the body of the quantifier.

	   \sa Z3_mk_pattern
	   \sa Z3_mk_forall_const

	   def_API('Z3_mk_exists_const', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, APP), _in(UINT), _in_array(4, PATTERN), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval boundExt patternsExt |

	c ensureValidZ3Object.
	bound ensureValidZ3ASTArray.
	patterns ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	boundExt := self externalArrayFrom: bound.
	patternsExt := self externalArrayFrom: patterns.
	retval := lib _mk_exists_const: c _: weight _: num_bound _: boundExt _: num_patterns _: patternsExt _: body.
	boundExt notNil ifTrue:[boundExt free].
	patternsExt notNil ifTrue:[patternsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_ext_rotate_left: c _: t1 _: t2 [
	"
	   \brief Rotate bits of \c t1 to the left \c t2 times.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_ext_rotate_left', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_ext_rotate_left: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_ext_rotate_right: c _: t1 _: t2 [
	"
	   \brief Rotate bits of \c t1 to the right \c t2 times.

	   The nodes \c t1 and \c t2 must have the same bit-vector sort.

	   def_API('Z3_mk_ext_rotate_right', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_ext_rotate_right: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_extract: c _: high _: low _: t1 [
	"
	   \brief Extract the bits \c high down to \c low from a bit-vector of
	   size \c m to yield a new bit-vector of size \c n, where \ccode{n = high - low + 1}.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_extract', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_extract: c _: high _: low _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_false: c [
	"
		\brief Create an AST node representing \c false.

		def_API('Z3_mk_false', AST, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_false: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_finite_domain_sort: c _: name _: size [
	"
	   \brief Create a named finite domain sort.

	   To create constants that belong to the finite domain,
	   use the APIs for creating numerals and pass a numeric
	   constant together with the sort returned by this call.
	   The numeric constant should be between 0 and the less
	   than the size of the domain.

	   \sa Z3_get_finite_domain_sort_size

	   def_API('Z3_mk_finite_domain_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT64)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	name ensureValidZ3Object.
	retval := lib _mk_finite_domain_sort: c _: name _: size.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fixedpoint: c [
	"
	   \brief Create a new fixedpoint context.

	   \remark User must use #Z3_fixedpoint_inc_ref and #Z3_fixedpoint_dec_ref to manage fixedpoint objects.
	   Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_fixedpoint', FIXEDPOINT, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fixedpoint: c.
	c errorCheck.
	^ Z3Fixedpoint fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_forall: c _: weight _: num_patterns _: patterns _: num_decls _: sorts _: decl_names _: body [
	"
	   \brief Create a forall formula. It takes an expression \c body that contains bound variables
	   of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created
	   using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the
	   bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array
	   refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers
	   to the variable with index 1, etc.

	   \param c logical context.
	   \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
	   \param num_patterns number of patterns.
	   \param patterns array containing the patterns created using #Z3_mk_pattern.
	   \param num_decls number of variables to be bound.
	   \param sorts the sorts of the bound variables.
	   \param decl_names names of the bound variables
	   \param body the body of the quantifier.

	   \sa Z3_mk_pattern
	   \sa Z3_mk_bound
	   \sa Z3_mk_exists

	   def_API('Z3_mk_forall', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, PATTERN), _in(UINT), _in_array(4, SORT), _in_array(4, SYMBOL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval patternsExt sortsExt decl_namesExt |

	c ensureValidZ3Object.
	patterns ensureValidZ3ObjectArray.
	sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	decl_names ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	patternsExt := self externalArrayFrom: patterns.
	sortsExt := self externalArrayFrom: sorts.
	decl_namesExt := self externalArrayFrom: decl_names.
	retval := lib _mk_forall: c _: weight _: num_patterns _: patternsExt _: num_decls _: sortsExt _: decl_namesExt _: body.
	patternsExt notNil ifTrue:[patternsExt free].
	sortsExt notNil ifTrue:[sortsExt free].
	decl_namesExt notNil ifTrue:[decl_namesExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_forall_const: c _: weight _: num_bound _: bound _: num_patterns _: patterns _: body [
	"
	   \brief Create a universal quantifier using a list of constants that
	   will form the set of bound variables.

	   \param c logical context.
	   \param weight quantifiers are associated with weights indicating the importance of using
			  the quantifier during instantiation. By default, pass the weight 0.
	   \param num_bound number of constants to be abstracted into bound variables.
	   \param bound array of constants to be abstracted into bound variables.
	   \param num_patterns number of patterns.
	   \param patterns array containing the patterns created using #Z3_mk_pattern.
	   \param body the body of the quantifier.

	   \sa Z3_mk_pattern
	   \sa Z3_mk_exists_const

	   def_API('Z3_mk_forall_const', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, APP), _in(UINT), _in_array(4, PATTERN), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval boundExt patternsExt |

	c ensureValidZ3Object.
	bound ensureValidZ3ASTArray.
	patterns ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	boundExt := self externalArrayFrom: bound.
	patternsExt := self externalArrayFrom: patterns.
	retval := lib _mk_forall_const: c _: weight _: num_bound _: boundExt _: num_patterns _: patternsExt _: body.
	boundExt notNil ifTrue:[boundExt free].
	patternsExt notNil ifTrue:[patternsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_abs: c _: t [
	"
		\brief Floating-point absolute value

		\param c logical context
		\param t term of FloatingPoint sort

		def_API('Z3_mk_fpa_abs', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_abs: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_add: c _: rm _: t1 _: t2 [
	"
		\brief Floating-point addition

		\param c logical context
		\param rm term of RoundingMode sort
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_add', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_add: c _: rm _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_div: c _: rm _: t1 _: t2 [
	"
		\brief Floating-point division

		\param c logical context
		\param rm term of RoundingMode sort
		\param t1 term of FloatingPoint sort.
		\param t2 term of FloatingPoint sort

		The nodes \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_div', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_div: c _: rm _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_eq: c _: t1 _: t2 [
	"
		\brief Floating-point equality.

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		Note that this is IEEE 754 equality (as opposed to SMT-LIB \ccode{=}).

		\c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_eq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_eq: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_fma: c _: rm _: t1 _: t2 _: t3 [
	"
		\brief Floating-point fused multiply-add.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort
		\param t3 term of FloatingPoint sort

		The result is \ccode{round((t1 * t2) + t3)}.

		\c rm must be of RoundingMode sort, \c t1, \c t2, and \c t3 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_fma', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	t3 ensureValidZ3AST.
	retval := lib _mk_fpa_fma: c _: rm _: t1 _: t2 _: t3.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_fp: c _: sgn _: exp _: sig [
	"
		\brief Create an expression of FloatingPoint sort from three bit-vector expressions.

		This is the operator named `fp' in the SMT FP theory definition.
		Note that \c sgn is required to be a bit-vector of size 1. Significand and exponent
		are required to be longer than 1 and 2 respectively. The FloatingPoint sort
		of the resulting expression is automatically determined from the bit-vector sizes
		of the arguments. The exponent is assumed to be in IEEE-754 biased representation.

		\param c logical context
		\param sgn sign
		\param exp exponent
		\param sig significand

		\sa Z3_mk_fpa_numeral_double
		\sa Z3_mk_fpa_numeral_float
		\sa Z3_mk_fpa_numeral_int
		\sa Z3_mk_fpa_numeral_int_uint
		\sa Z3_mk_fpa_numeral_int64_uint64
		\sa Z3_mk_numeral

		def_API('Z3_mk_fpa_fp', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	sgn ensureValidZ3AST.
	exp ensureValidZ3AST.
	sig ensureValidZ3AST.
	retval := lib _mk_fpa_fp: c _: sgn _: exp _: sig.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_geq: c _: t1 _: t2 [
	"
		\brief Floating-point greater than or equal.

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_geq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_geq: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_gt: c _: t1 _: t2 [
	"
		\brief Floating-point greater than.

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_gt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_gt: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_inf: c _: s _: negative [
	"
		\brief Create a floating-point infinity of sort \c s.

		\param c logical context
		\param s target sort
		\param negative indicates whether the result should be negative

		When \c negative is \c true, -oo will be generated instead of +oo.

		\sa Z3_mk_fpa_nan
		\sa Z3_mk_fpa_zero

		def_API('Z3_mk_fpa_inf', AST, (_in(CONTEXT),_in(SORT),_in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_inf: c _: s _: negative.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_is_infinite: c _: t [
	"
		\brief Predicate indicating whether \c t is a floating-point number representing +oo or -oo.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_is_infinite', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_is_infinite: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_is_nan: c _: t [
	"
		\brief Predicate indicating whether \c t is a NaN.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_is_nan', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_is_nan: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_is_negative: c _: t [
	"
		\brief Predicate indicating whether \c t is a negative floating-point number.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_is_negative', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_is_negative: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_is_normal: c _: t [
	"
		\brief Predicate indicating whether \c t is a normal floating-point number.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_is_normal', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_is_normal: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_is_positive: c _: t [
	"
		\brief Predicate indicating whether \c t is a positive floating-point number.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_is_positive', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_is_positive: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_is_subnormal: c _: t [
	"
		\brief Predicate indicating whether \c t is a subnormal floating-point number.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_is_subnormal', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_is_subnormal: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_is_zero: c _: t [
	"
		\brief Predicate indicating whether \c t is a floating-point number with zero value, i.e., +zero or -zero.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_is_zero', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_is_zero: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_leq: c _: t1 _: t2 [
	"
		\brief Floating-point less than or equal.

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_leq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_leq: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_lt: c _: t1 _: t2 [
	"
		\brief Floating-point less than.

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_lt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_lt: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_max: c _: t1 _: t2 [
	"
		\brief Maximum of floating-point numbers.

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c t1, \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_max', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_max: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_min: c _: t1 _: t2 [
	"
		\brief Minimum of floating-point numbers.

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c t1, \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_min', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_min: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_mul: c _: rm _: t1 _: t2 [
	"
		\brief Floating-point multiplication

		\param c logical context
		\param rm term of RoundingMode sort
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_mul', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_mul: c _: rm _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_nan: c _: s [
	"
		\brief Create a floating-point NaN of sort \c s.

		\param c logical context
		\param s target sort

		\sa Z3_mk_fpa_inf
		\sa Z3_mk_fpa_zero

		def_API('Z3_mk_fpa_nan', AST, (_in(CONTEXT),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_nan: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_neg: c _: t [
	"
		\brief Floating-point negation

		\param c logical context
		\param t term of FloatingPoint sort

		def_API('Z3_mk_fpa_neg', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_neg: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_numeral_double: c _: v _: ty [
	"
		\brief Create a numeral of FloatingPoint sort from a double.

		This function is used to create numerals that fit in a double value.
		It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.

		\param c logical context
		\param v value
		\param ty sort

		\c ty must be a FloatingPoint sort

		\sa Z3_mk_fpa_fp
		\sa Z3_mk_fpa_numeral_float
		\sa Z3_mk_fpa_numeral_int
		\sa Z3_mk_fpa_numeral_int_uint
		\sa Z3_mk_fpa_numeral_int64_uint64
		\sa Z3_mk_numeral

		def_API('Z3_mk_fpa_numeral_double', AST, (_in(CONTEXT), _in(DOUBLE), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_numeral_double: c _: v _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_numeral_float: c _: v _: ty [
	"
		\brief Create a numeral of FloatingPoint sort from a float.

		This function is used to create numerals that fit in a float value.
		It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.

		\param c logical context
		\param v value
		\param ty sort

		\c ty must be a FloatingPoint sort

		\sa Z3_mk_fpa_fp
		\sa Z3_mk_fpa_numeral_double
		\sa Z3_mk_fpa_numeral_int
		\sa Z3_mk_fpa_numeral_int_uint
		\sa Z3_mk_fpa_numeral_int64_uint64
		\sa Z3_mk_numeral

		def_API('Z3_mk_fpa_numeral_float', AST, (_in(CONTEXT), _in(FLOAT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_numeral_float: c _: v _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_numeral_int64_uint64: c _: sgn _: exp _: sig _: ty [
	"
		\brief Create a numeral of FloatingPoint sort from a sign bit and two 64-bit integers.

		\param c logical context
		\param sgn sign bit (true == negative)
		\param sig significand
		\param exp exponent
		\param ty result sort

		\c ty must be a FloatingPoint sort

		\sa Z3_mk_fpa_fp
		\sa Z3_mk_fpa_numeral_double
		\sa Z3_mk_fpa_numeral_float
		\sa Z3_mk_fpa_numeral_int
		\sa Z3_mk_fpa_numeral_int_uint
		\sa Z3_mk_numeral

		def_API('Z3_mk_fpa_numeral_int64_uint64', AST, (_in(CONTEXT), _in(BOOL), _in(INT64), _in(UINT64), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_numeral_int64_uint64: c _: sgn _: exp _: sig _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_numeral_int: c _: v _: ty [
	"
		\brief Create a numeral of FloatingPoint sort from a signed integer.

		\param c logical context
		\param v value
		\param ty result sort

		\c ty must be a FloatingPoint sort

		\sa Z3_mk_fpa_fp
		\sa Z3_mk_fpa_numeral_double
		\sa Z3_mk_fpa_numeral_float
		\sa Z3_mk_fpa_numeral_int_uint
		\sa Z3_mk_fpa_numeral_int64_uint64
		\sa Z3_mk_numeral

		def_API('Z3_mk_fpa_numeral_int', AST, (_in(CONTEXT), _in(INT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_numeral_int: c _: v _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_numeral_int_uint: c _: sgn _: exp _: sig _: ty [
	"
		\brief Create a numeral of FloatingPoint sort from a sign bit and two integers.

		\param c logical context
		\param sgn sign bit (true == negative)
		\param sig significand
		\param exp exponent
		\param ty result sort

		\c ty must be a FloatingPoint sort

		\sa Z3_mk_fpa_fp
		\sa Z3_mk_fpa_numeral_double
		\sa Z3_mk_fpa_numeral_float
		\sa Z3_mk_fpa_numeral_int
		\sa Z3_mk_fpa_numeral_int64_uint64
		\sa Z3_mk_numeral

		def_API('Z3_mk_fpa_numeral_int_uint', AST, (_in(CONTEXT), _in(BOOL), _in(INT), _in(UINT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_numeral_int_uint: c _: sgn _: exp _: sig _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_rem: c _: t1 _: t2 [
	"
		\brief Floating-point remainder

		\param c logical context
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_rem', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_rem: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_rna: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_rna', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_rna: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_rne: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_rne', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_rne: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_round_nearest_ties_to_away: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_round_nearest_ties_to_away', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_round_nearest_ties_to_away: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_round_nearest_ties_to_even: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_round_nearest_ties_to_even', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_round_nearest_ties_to_even: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_round_to_integral: c _: rm _: t [
	"
		\brief Floating-point roundToIntegral. Rounds a floating-point number to
		the closest integer, again represented as a floating-point number.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of FloatingPoint sort

		\c t must be of FloatingPoint sort.

		def_API('Z3_mk_fpa_round_to_integral', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_round_to_integral: c _: rm _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_round_toward_negative: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_round_toward_negative', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_round_toward_negative: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_round_toward_positive: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_round_toward_positive', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_round_toward_positive: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_round_toward_zero: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_round_toward_zero', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_round_toward_zero: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_rounding_mode_sort: c [
	"
		\brief Create the RoundingMode sort.

		\param c logical context

		def_API('Z3_mk_fpa_rounding_mode_sort', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_rounding_mode_sort: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_rtn: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_rtn', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_rtn: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_rtp: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_rtp', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_rtp: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_rtz: c [
	"
		\brief Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.

		\param c logical context

		def_API('Z3_mk_fpa_rtz', AST, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_rtz: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort: c _: ebits _: sbits [
	"
		\brief Create a FloatingPoint sort.

		\param c logical context
		\param ebits number of exponent bits
		\param sbits number of significand bits

		\remark \c ebits must be larger than 1 and \c sbits must be larger than 2.

		def_API('Z3_mk_fpa_sort', SORT, (_in(CONTEXT), _in(UINT), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort: c _: ebits _: sbits.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_128: c [
	"
		\brief Create the quadruple-precision (128-bit) FloatingPoint sort.

		\param c logical context

		def_API('Z3_mk_fpa_sort_128', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_128: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_16: c [
	"
		\brief Create the half-precision (16-bit) FloatingPoint sort.

		\param c logical context

		def_API('Z3_mk_fpa_sort_16', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_16: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_32: c [
	"
		\brief Create the single-precision (32-bit) FloatingPoint sort.

		\param c logical context

		def_API('Z3_mk_fpa_sort_32', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_32: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_64: c [
	"
		\brief Create the double-precision (64-bit) FloatingPoint sort.

		\param c logical context

		def_API('Z3_mk_fpa_sort_64', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_64: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_double: c [
	"
		\brief Create the double-precision (64-bit) FloatingPoint sort.

		\param c logical context

		def_API('Z3_mk_fpa_sort_double', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_double: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_half: c [
	"
		\brief Create the half-precision (16-bit) FloatingPoint sort.

		\param c logical context

		def_API('Z3_mk_fpa_sort_half', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_half: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_quadruple: c [
	"
		\brief Create the quadruple-precision (128-bit) FloatingPoint sort.

		\param c logical context

		def_API('Z3_mk_fpa_sort_quadruple', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_quadruple: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sort_single: c [
	"
		\brief Create the single-precision (32-bit) FloatingPoint sort.

		\param c logical context.

		def_API('Z3_mk_fpa_sort_single', SORT, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_fpa_sort_single: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sqrt: c _: rm _: t [
	"
		\brief Floating-point square root

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of FloatingPoint sort

		\c rm must be of RoundingMode sort, \c t must have FloatingPoint sort.

		def_API('Z3_mk_fpa_sqrt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_sqrt: c _: rm _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_sub: c _: rm _: t1 _: t2 [
	"
		\brief Floating-point subtraction

		\param c logical context
		\param rm term of RoundingMode sort
		\param t1 term of FloatingPoint sort
		\param t2 term of FloatingPoint sort

		\c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.

		def_API('Z3_mk_fpa_sub', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_fpa_sub: c _: rm _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_fp_bv: c _: bv _: s [
	"
		\brief Conversion of a single IEEE 754-2008 bit-vector into a floating-point number.

		Produces a term that represents the conversion of a bit-vector term \c bv to a
		floating-point term of sort \c s.

		\param c logical context
		\param bv a bit-vector term
		\param s floating-point sort

		\c s must be a FloatingPoint sort, \c t must be of bit-vector sort, and the bit-vector
		size of \c bv must be equal to \ccode{ebits+sbits} of \c s. The format of the bit-vector is
		as defined by the IEEE 754-2008 interchange format.

		def_API('Z3_mk_fpa_to_fp_bv', AST, (_in(CONTEXT),_in(AST),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	bv ensureValidZ3AST.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_to_fp_bv: c _: bv _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_fp_float: c _: rm _: t _: s [
	"
		\brief Conversion of a FloatingPoint term into another term of different FloatingPoint sort.

		Produces a term that represents the conversion of a floating-point term \c t to a
		floating-point term of sort \c s. If necessary, the result will be rounded according
		to rounding mode \c rm.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of FloatingPoint sort
		\param s floating-point sort

		\c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of floating-point sort.

		def_API('Z3_mk_fpa_to_fp_float', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_to_fp_float: c _: rm _: t _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_fp_int_real: c _: rm _: exp _: sig _: s [
	"
		\brief Conversion of a real-sorted significand and an integer-sorted exponent into a term of FloatingPoint sort.

		Produces a term that represents the conversion of \ccode{sig * 2^exp} into a
		floating-point term of sort \c s. If necessary, the result will be rounded
		according to rounding mode \c rm.

		\param c logical context
		\param rm term of RoundingMode sort
		\param exp exponent term of Int sort
		\param sig significand term of Real sort
		\param s FloatingPoint sort

		\c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c exp must be of int sort, \c sig must be of real sort.

		def_API('Z3_mk_fpa_to_fp_int_real', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	exp ensureValidZ3AST.
	sig ensureValidZ3AST.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_to_fp_int_real: c _: rm _: exp _: sig _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_fp_real: c _: rm _: t _: s [
	"
		\brief Conversion of a term of real sort into a term of FloatingPoint sort.

		Produces a term that represents the conversion of term \c t of real sort into a
		floating-point term of sort \c s. If necessary, the result will be rounded according
		to rounding mode \c rm.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of Real sort
		\param s floating-point sort

		\c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of real sort.

		def_API('Z3_mk_fpa_to_fp_real', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_to_fp_real: c _: rm _: t _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_fp_signed: c _: rm _: t _: s [
	"
		\brief Conversion of a 2's complement signed bit-vector term into a term of FloatingPoint sort.

		Produces a term that represents the conversion of the bit-vector term \c t into a
		floating-point term of sort \c s. The bit-vector \c t is taken to be in signed
		2's complement format. If necessary, the result will be rounded according
		to rounding mode \c rm.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of bit-vector sort
		\param s floating-point sort

		\c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of bit-vector sort.

		def_API('Z3_mk_fpa_to_fp_signed', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_to_fp_signed: c _: rm _: t _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_fp_unsigned: c _: rm _: t _: s [
	"
		\brief Conversion of a 2's complement unsigned bit-vector term into a term of FloatingPoint sort.

		Produces a term that represents the conversion of the bit-vector term \c t into a
		floating-point term of sort \c s. The bit-vector \c t is taken to be in unsigned
		2's complement format. If necessary, the result will be rounded according
		to rounding mode \c rm.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of bit-vector sort
		\param s floating-point sort

		\c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of bit-vector sort.

		def_API('Z3_mk_fpa_to_fp_unsigned', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_to_fp_unsigned: c _: rm _: t _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_ieee_bv: c _: t [
	"
		\brief Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format.

		\param c logical context
		\param t term of FloatingPoint sort

		\c t must have FloatingPoint sort. The size of the resulting bit-vector is automatically
		determined.

		Note that IEEE 754-2008 allows multiple different representations of NaN. This conversion
		knows only one NaN and it will always produce the same bit-vector representation of
		that NaN.

		def_API('Z3_mk_fpa_to_ieee_bv', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_to_ieee_bv: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_real: c _: t [
	"
		\brief Conversion of a floating-point term into a real-numbered term.

		Produces a term that represents the conversion of the floating-point term \c t into a
		real number. Note that this type of conversion will often result in non-linear
		constraints over real terms.

		\param c logical context
		\param t term of FloatingPoint sort

		def_API('Z3_mk_fpa_to_real', AST, (_in(CONTEXT),_in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_to_real: c _: t.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_sbv: c _: rm _: t _: sz [
	"
		\brief Conversion of a floating-point term into a signed bit-vector.

		Produces a term that represents the conversion of the floating-point term \c t into a
		bit-vector term of size \c sz in signed 2's complement format. If necessary, the result
		will be rounded according to rounding mode \c rm.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of FloatingPoint sort
		\param sz size of the resulting bit-vector

		def_API('Z3_mk_fpa_to_sbv', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_to_sbv: c _: rm _: t _: sz.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_to_ubv: c _: rm _: t _: sz [
	"
		\brief Conversion of a floating-point term into an unsigned bit-vector.

		Produces a term that represents the conversion of the floating-point term \c t into a
		bit-vector term of size \c sz in unsigned 2's complement format. If necessary, the result
		will be rounded according to rounding mode \c rm.

		\param c logical context
		\param rm term of RoundingMode sort
		\param t term of FloatingPoint sort
		\param sz size of the resulting bit-vector

		def_API('Z3_mk_fpa_to_ubv', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	rm ensureValidZ3AST.
	t ensureValidZ3AST.
	retval := lib _mk_fpa_to_ubv: c _: rm _: t _: sz.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fpa_zero: c _: s _: negative [
	"
		\brief Create a floating-point zero of sort \c s.

		\param c logical context
		\param s target sort
		\param negative indicates whether the result should be negative

		When \c negative is \c true, -zero will be generated instead of +zero.

		\sa Z3_mk_fpa_inf
		\sa Z3_mk_fpa_nan

		def_API('Z3_mk_fpa_zero', AST, (_in(CONTEXT),_in(SORT),_in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fpa_zero: c _: s _: negative.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fresh_const: c _: prefix _: ty [
	"
	   \brief Declare and create a fresh constant.

	   This function is a shorthand for:
	   \code Z3_func_decl d = Z3_mk_fresh_func_decl(c, prefix, 0, 0, ty); Z3_ast n = Z3_mk_app(c, d, 0, 0); \endcode

	   \remark If \c prefix is \c NULL, then it is assumed to be the empty string.

	   \sa Z3_mk_app
	   \sa Z3_mk_const
	   \sa Z3_mk_fresh_func_decl
	   \sa Z3_mk_func_decl

	   def_API('Z3_mk_fresh_const', AST, (_in(CONTEXT), _in(STRING), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_fresh_const: c _: prefix _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_fresh_func_decl: c _: prefix _: domain_size _: domain _: range [
	"
	   \brief Declare a fresh constant or function.

	   Z3 will generate an unique name for this function declaration.
	   If prefix is different from \c NULL, then the name generate by Z3 will start with \c prefix.

	   \remark If \c prefix is \c NULL, then it is assumed to be the empty string.

	   \sa Z3_mk_func_decl

	   def_API('Z3_mk_fresh_func_decl', FUNC_DECL, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SORT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval domainExt |

	c ensureValidZ3Object.
	domain ensureValidZ3ASTArrayOfKind: SORT_AST.
	range ensureValidZ3ASTOfKind: SORT_AST.
	domainExt := self externalArrayFrom: domain.
	retval := lib _mk_fresh_func_decl: c _: prefix _: domain_size _: domainExt _: range.
	domainExt notNil ifTrue:[domainExt free].
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_full_set: c _: domain [
	"
		\brief Create the full set.

		def_API('Z3_mk_full_set', AST, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	domain ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_full_set: c _: domain.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_func_decl: c _: s _: domain_size _: domain _: range [
	"
	   \brief Declare a constant or function.

	   \param c logical context.
	   \param s name of the constant or function.
	   \param domain_size number of arguments. It is 0 when declaring a constant.
	   \param domain array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant.
	   \param range sort of the constant or the return sort of the function.

	   After declaring a constant or function, the function
	   #Z3_mk_app can be used to create a constant or function
	   application.

	   \sa Z3_mk_app
	   \sa Z3_mk_fresh_func_decl
	   \sa Z3_mk_rec_func_decl

	   def_API('Z3_mk_func_decl', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval domainExt |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	domain ensureValidZ3ASTArrayOfKind: SORT_AST.
	range ensureValidZ3ASTOfKind: SORT_AST.
	domainExt := self externalArrayFrom: domain.
	retval := lib _mk_func_decl: c _: s _: domain_size _: domainExt _: range.
	domainExt notNil ifTrue:[domainExt free].
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_ge: c _: t1 _: t2 [
	"
		\brief Create greater than or equal to.

		The nodes \c t1 and \c t2 must have the same sort, and must be int or real.

		def_API('Z3_mk_ge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_ge: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_goal: c _: models _: unsat_cores _: proofs [
	"
	   \brief Create a goal (aka problem). A goal is essentially a set
	   of formulas, that can be solved and/or transformed using
	   tactics and solvers.

	   If \c models is \c true, then model generation is enabled for the new goal.

	   If \c unsat_cores is \c true, then unsat core generation is enabled for the new goal.

	   If \c proofs is \c true, then proof generation is enabled for the new goal. Remark, the
	   Z3 context \c c must have been created with proof generation support.

	   \remark Reference counting must be used to manage goals, even when the \c Z3_context was
	   created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_goal', GOAL, (_in(CONTEXT), _in(BOOL), _in(BOOL), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type GOAL not (yet) supported.'


]

{ #category : #API }
Z3 class >> mk_gt: c _: t1 _: t2 [
	"
		\brief Create greater than.

		The nodes \c t1 and \c t2 must have the same sort, and must be int or real.

		def_API('Z3_mk_gt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_gt: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_iff: c _: t1 _: t2 [
	"
	   \brief Create an AST node representing \ccode{t1 iff t2}.

	   The nodes \c t1 and \c t2 must have Boolean sort.

	   def_API('Z3_mk_iff', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_iff: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_implies: c _: t1 _: t2 [
	"
	   \brief Create an AST node representing \ccode{t1 implies t2}.

	   The nodes \c t1 and \c t2 must have Boolean sort.

	   def_API('Z3_mk_implies', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_implies: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_int2bv: c _: n _: t1 [
	"
	   \brief Create an \c n bit bit-vector from the integer argument \c t1.

	   The resulting bit-vector has \c n bits, where the i'th bit (counting
	   from 0 to \c n-1) is 1 if \c (t1 div 2^i) mod 2 is 1.       

	   The node \c t1 must have integer sort.

	   def_API('Z3_mk_int2bv', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_int2bv: c _: n _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_int2real: c _: t1 [
	"
		\brief Coerce an integer to a real.

		There is also a converse operation exposed.
		It follows the semantics prescribed by the SMT-LIB standard.

		You can take the floor of a real by
		creating an auxiliary integer constant \c k and
		and asserting \ccode{mk_int2real(k) <= t1 < mk_int2real(k)+1}.

		The node \c t1 must have sort integer.

		\sa Z3_mk_real2int
		\sa Z3_mk_is_int

		def_API('Z3_mk_int2real', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_int2real: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_int64: c _: v _: ty [
	"
	   \brief Create a numeral of a int, bit-vector, or finite-domain sort.

	   This function can be used to create numerals that fit in a machine \c int64_t integer.
	   It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.

	   \sa Z3_mk_numeral

	   def_API('Z3_mk_int64', AST, (_in(CONTEXT), _in(INT64), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_int64: c _: v _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_int: c _: v _: ty [
	"
	   \brief Create a numeral of an int, bit-vector, or finite-domain sort.

	   This function can be used to create numerals that fit in a machine integer.
	   It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.

	   \sa Z3_mk_numeral

	   def_API('Z3_mk_int', AST, (_in(CONTEXT), _in(INT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_int: c _: v _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_int_sort: c [
	"
	   \brief Create the integer type.

	   This type is not the int type found in programming languages.
	   A machine integer can be represented using bit-vectors. The function
	   #Z3_mk_bv_sort creates a bit-vector type.

	   \sa Z3_mk_bv_sort

	   def_API('Z3_mk_int_sort', SORT, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_int_sort: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_int_symbol: c _: i [
	"
	   \brief Create a Z3 symbol using an integer.

	   Symbols are used to name several term and type constructors.

	   NB. Not all integers can be passed to this function.
	   The legal range of unsigned integers is 0 to 2^30-1.

	   \sa Z3_get_symbol_int
	   \sa Z3_mk_string_symbol

	   def_API('Z3_mk_int_symbol', SYMBOL, (_in(CONTEXT), _in(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_int_symbol: c _: i.
	c errorCheck.
	^ Z3Symbol fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_int_to_str: c _: s [
	"
	   \brief Integer to string conversion.

	   def_API('Z3_mk_int_to_str', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _mk_int_to_str: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_is_int: c _: t1 [
	"
		\brief Check if a real number is an integer.

		\sa Z3_mk_int2real
		\sa Z3_mk_real2int

		def_API('Z3_mk_is_int', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_is_int: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_ite: c _: t1 _: t2 _: t3 [
	"
	   \brief Create an AST node representing an if-then-else: \ccode{ite(t1, t2, t3)}.

	   The node \c t1 must have Boolean sort, \c t2 and \c t3 must have the same sort.
	   The sort of the new node is equal to the sort of \c t2 and \c t3.

	   def_API('Z3_mk_ite', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	t3 ensureValidZ3AST.
	retval := lib _mk_ite: c _: t1 _: t2 _: t3.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_lambda: c _: num_decls _: sorts _: decl_names _: body [
	"
	   \brief Create a lambda expression. It takes an expression \c body that contains bound variables
	   of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created
	   using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the
	   bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array
	   refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers
	   to the variable with index 1, etc.
	   The sort of the resulting expression is \c (Array sorts range) where \c range is the sort of \c body.
	   For example, if the lambda binds two variables of sort \c Int and \c Bool, and the \c body has sort \c Real, 
	   the sort of the expression is \c (Array Int Bool Real).

	   \param c logical context
	   \param num_decls number of variables to be bound.
	   \param sorts the sorts of the bound variables.
	   \param decl_names names of the bound variables
	   \param body the body of the lambda expression.       

	   \sa Z3_mk_bound
	   \sa Z3_mk_forall
	   \sa Z3_mk_lambda_const

	   def_API('Z3_mk_lambda', AST, (_in(CONTEXT), _in(UINT), _in_array(1, SORT), _in_array(1, SYMBOL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval sortsExt decl_namesExt |

	c ensureValidZ3Object.
	sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	decl_names ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	sortsExt := self externalArrayFrom: sorts.
	decl_namesExt := self externalArrayFrom: decl_names.
	retval := lib _mk_lambda: c _: num_decls _: sortsExt _: decl_namesExt _: body.
	sortsExt notNil ifTrue:[sortsExt free].
	decl_namesExt notNil ifTrue:[decl_namesExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_lambda_const: c _: num_bound _: bound _: body [
	"
	   \brief Create a lambda expression using a list of constants that form the set
	   of bound variables

	   \param c logical context.
	   \param num_bound number of constants to be abstracted into bound variables.
	   \param bound array of constants to be abstracted into bound variables.
	   \param body the body of the lambda expression.

	   \sa Z3_mk_bound
	   \sa Z3_mk_forall
	   \sa Z3_mk_lambda

	   def_API('Z3_mk_lambda_const', AST, (_in(CONTEXT), _in(UINT), _in_array(1, APP), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval boundExt |

	c ensureValidZ3Object.
	bound ensureValidZ3ASTArray.
	body ensureValidZ3AST.
	boundExt := self externalArrayFrom: bound.
	retval := lib _mk_lambda_const: c _: num_bound _: boundExt _: body.
	boundExt notNil ifTrue:[boundExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_le: c _: t1 _: t2 [
	"
		\brief Create less than or equal to.

		The nodes \c t1 and \c t2 must have the same sort, and must be int or real.

		def_API('Z3_mk_le', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_le: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_linear_order: c _: a _: id [
	"
	   \brief create a linear ordering relation over signature \c a.
	   The relation is identified by the index \c id.

	   def_API('Z3_mk_linear_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_linear_order: c _: a _: id.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_list_sort: c _: name _: elem_sort _: nil_decl _: is_nil_decl _: cons_decl _: is_cons_decl _: head_decl _: tail_decl [
	"
	   \brief Create a list sort

	   A list sort over \c elem_sort
	   This function declares the corresponding constructors and testers for lists.

	   \param c logical context
	   \param name name of the list sort.
	   \param elem_sort sort of list elements.
	   \param nil_decl declaration for the empty list.
	   \param is_nil_decl test for the empty list.
	   \param cons_decl declaration for a cons cell.
	   \param is_cons_decl cons cell test.
	   \param head_decl list head.
	   \param tail_decl list tail.

	   def_API('Z3_mk_list_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(SORT), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval nil_declExt is_nil_declExt cons_declExt is_cons_declExt head_declExt tail_declExt |

	c ensureValidZ3Object.
	name ensureValidZ3Object.
	elem_sort ensureValidZ3ASTOfKind: SORT_AST.
	nil_declExt := self externalArrayFrom: nil_decl.
	is_nil_declExt := self externalArrayFrom: is_nil_decl.
	cons_declExt := self externalArrayFrom: cons_decl.
	is_cons_declExt := self externalArrayFrom: is_cons_decl.
	head_declExt := self externalArrayFrom: head_decl.
	tail_declExt := self externalArrayFrom: tail_decl.
	retval := lib _mk_list_sort: c _: name _: elem_sort _: nil_declExt _: is_nil_declExt _: cons_declExt _: is_cons_declExt _: head_declExt _: tail_declExt.
	1 to: nil_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: nil_declExt pointerAt: i) inContext: c.
		nil_decl at: i put: v.
	].
	nil_declExt notNil ifTrue:[nil_declExt free].
	1 to: is_nil_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: is_nil_declExt pointerAt: i) inContext: c.
		is_nil_decl at: i put: v.
	].
	is_nil_declExt notNil ifTrue:[is_nil_declExt free].
	1 to: cons_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: cons_declExt pointerAt: i) inContext: c.
		cons_decl at: i put: v.
	].
	cons_declExt notNil ifTrue:[cons_declExt free].
	1 to: is_cons_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: is_cons_declExt pointerAt: i) inContext: c.
		is_cons_decl at: i put: v.
	].
	is_cons_declExt notNil ifTrue:[is_cons_declExt free].
	1 to: head_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: head_declExt pointerAt: i) inContext: c.
		head_decl at: i put: v.
	].
	head_declExt notNil ifTrue:[head_declExt free].
	1 to: tail_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: tail_declExt pointerAt: i) inContext: c.
		tail_decl at: i put: v.
	].
	tail_declExt notNil ifTrue:[tail_declExt free].
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_lstring: c _: len _: s [
	"
	   \brief Create a string constant out of the string that is passed in
	   It takes the length of the string as well to take into account
	   0 characters. The string is treated as if it is unescaped so a sequence
	   of characters \\u{0} is treated as 5 characters and not the character 0.

	   def_API('Z3_mk_lstring', AST, (_in(CONTEXT), _in(UINT), _in(STRING)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_lstring: c _: len _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_lt: c _: t1 _: t2 [
	"
		\brief Create less than.

		The nodes \c t1 and \c t2 must have the same sort, and must be int or real.

		def_API('Z3_mk_lt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_lt: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_map: c _: f _: n _: args [
	"
	   \brief Map f on the argument arrays.

	   The \c n nodes \c args must be of array sorts \ccode{[domain_i -> range_i]}.
	   The function declaration \c f must have type \ccode{ range_1 .. range_n -> range}.
	   \c v must have sort range. The sort of the result is \ccode{[domain_i -> range]}.

	   \sa Z3_mk_array_sort
	   \sa Z3_mk_store
	   \sa Z3_mk_select

	   def_API('Z3_mk_map', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_map: c _: f _: n _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_mod: c _: arg1 _: arg2 [
	"
	   \brief Create an AST node representing \ccode{arg1 mod arg2}.

	   The arguments must have int type.

	   def_API('Z3_mk_mod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	arg2 ensureValidZ3AST.
	retval := lib _mk_mod: c _: arg1 _: arg2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_model: c [
	"
	   \brief Create a fresh model object. It has reference count 0.

	   def_API('Z3_mk_model', MODEL, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_model: c.
	c errorCheck.
	^ Z3Model fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_mul: c _: num_args _: args [
	"
	   \brief Create an AST node representing \ccode{args[0] * ... * args[num_args-1]}.

	   The array \c args must have \c num_args elements.
	   All arguments must have int or real sort.

	   \remark Z3 has limited support for non-linear arithmetic.
	   \remark The number of arguments must be greater than zero.

	   def_API('Z3_mk_mul', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_mul: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_not: c _: a [
	"
		\brief Create an AST node representing \ccode{not(a)}.

		The node \c a must have Boolean sort.

		def_API('Z3_mk_not', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _mk_not: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_numeral: c _: numeral _: ty [
	"
	   \brief Create a numeral of a given sort.

	   \param c logical context.
	   \param numeral A string representing the numeral value in decimal notation. The string may be of the form `[num]*[.[num]*][E[+|-][num]+]`.
					  If the given sort is a real, then the numeral can be a rational, that is, a string of the form `[num]* / [num]*` .
	   \param ty The sort of the numeral. In the current implementation, the given sort can be an int, real, finite-domain, or bit-vectors of arbitrary size.

	   \sa Z3_mk_int
	   \sa Z3_mk_unsigned_int

	   def_API('Z3_mk_numeral', AST, (_in(CONTEXT), _in(STRING), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_numeral: c _: numeral _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_optimize: c [
	"
	   \brief Create a new optimize context.

	   \remark User must use #Z3_optimize_inc_ref and #Z3_optimize_dec_ref to manage optimize objects.
	   Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_optimize', OPTIMIZE, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> mk_or: c _: num_args _: args [
	"
	   \brief Create an AST node representing \ccode{args[0] or ... or args[num_args-1]}.

	   The array \c args must have \c num_args elements.
	   All arguments must have Boolean sort.

	   \remark The number of arguments must be greater than zero.

	   def_API('Z3_mk_or', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_or: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_params: c [
	"
	   \brief Create a Z3 (empty) parameter set.
	   Starting at Z3 4.0, parameter sets are used to configure many components such as:
	   simplifiers, tactics, solvers, etc.

	   \remark Reference counting must be used to manage parameter sets, even when the \c Z3_context was
	   created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_params', PARAMS, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_params: c.
	c errorCheck.
	^ Z3ParameterSet fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_partial_order: c _: a _: id [
	"
	   \brief create a partial ordering relation over signature \c a and index \c id.

	   def_API('Z3_mk_partial_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_partial_order: c _: a _: id.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_pattern: c _: num_patterns _: terms [
	"
	   \brief Create a pattern for quantifier instantiation.

	   Z3 uses pattern matching to instantiate quantifiers. If a
	   pattern is not provided for a quantifier, then Z3 will
	   automatically compute a set of patterns for it. However, for
	   optimal performance, the user should provide the patterns.

	   Patterns comprise a list of terms. The list should be
	   non-empty.  If the list comprises of more than one term, it is
	   a called a multi-pattern.

	   In general, one can pass in a list of (multi-)patterns in the
	   quantifier constructor.

	   \sa Z3_mk_forall
	   \sa Z3_mk_exists

	   def_API('Z3_mk_pattern', PATTERN, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval termsExt |

	c ensureValidZ3Object.
	terms ensureValidZ3ASTArray.
	termsExt := self externalArrayFrom: terms.
	retval := lib _mk_pattern: c _: num_patterns _: termsExt.
	termsExt notNil ifTrue:[termsExt free].
	c errorCheck.
	^ Z3Pattern fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_pbeq: c _: num_args _: args _: coeffs _: k [
	"
	   \brief Pseudo-Boolean relations.

	   Encode k1*p1 + k2*p2 + ... + kn*pn = k

	   def_API('Z3_mk_pbeq', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT not (yet) supported'


]

{ #category : #API }
Z3 class >> mk_pbge: c _: num_args _: args _: coeffs _: k [
	"
	   \brief Pseudo-Boolean relations.

	   Encode k1*p1 + k2*p2 + ... + kn*pn >= k

	   def_API('Z3_mk_pbge', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT not (yet) supported'


]

{ #category : #API }
Z3 class >> mk_pble: c _: num_args _: args _: coeffs _: k [
	"
	   \brief Pseudo-Boolean relations.

	   Encode k1*p1 + k2*p2 + ... + kn*pn <= k

	   def_API('Z3_mk_pble', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: arrays of type INT not (yet) supported'


]

{ #category : #API }
Z3 class >> mk_piecewise_linear_order: c _: a _: id [
	"
	   \brief create a piecewise linear ordering relation over signature \c a and index \c id.

	   def_API('Z3_mk_piecewise_linear_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_piecewise_linear_order: c _: a _: id.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_power: c _: arg1 _: arg2 [
	"
	   \brief Create an AST node representing \ccode{arg1 ^ arg2}.

	   The arguments must have int or real type.

	   def_API('Z3_mk_power', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	arg2 ensureValidZ3AST.
	retval := lib _mk_power: c _: arg1 _: arg2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_probe: c _: name [
	"
	   \brief Return a probe associated with the given name.
	   The complete list of probes may be obtained using the procedures #Z3_get_num_probes and #Z3_get_probe_name.
	   It may also be obtained using the command \ccode{(help-tactic)} in the SMT 2.0 front-end.

	   Probes are used to inspect a goal (aka problem) and collect information that may be used to decide
	   which solver and/or preprocessing step will be used.

	   def_API('Z3_mk_probe', PROBE, (_in(CONTEXT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> mk_quantifier: c _: is_forall _: weight _: num_patterns _: patterns _: num_decls _: sorts _: decl_names _: body [
	"
	   \brief Create a quantifier - universal or existential, with pattern hints.
	   See the documentation for #Z3_mk_forall for an explanation of the parameters.

	   \param c logical context.
	   \param is_forall flag to indicate if this is a universal or existential quantifier.
	   \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
	   \param num_patterns number of patterns.
	   \param patterns array containing the patterns created using #Z3_mk_pattern.
	   \param num_decls number of variables to be bound.
	   \param sorts array of sorts of the bound variables.
	   \param decl_names names of the bound variables.
	   \param body the body of the quantifier.

	   \sa Z3_mk_pattern
	   \sa Z3_mk_bound
	   \sa Z3_mk_forall
	   \sa Z3_mk_exists

	   def_API('Z3_mk_quantifier', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(UINT), _in_array(3, PATTERN), _in(UINT), _in_array(5, SORT), _in_array(5, SYMBOL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval patternsExt sortsExt decl_namesExt |

	c ensureValidZ3Object.
	patterns ensureValidZ3ObjectArray.
	sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	decl_names ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	patternsExt := self externalArrayFrom: patterns.
	sortsExt := self externalArrayFrom: sorts.
	decl_namesExt := self externalArrayFrom: decl_names.
	retval := lib _mk_quantifier: c _: is_forall _: weight _: num_patterns _: patternsExt _: num_decls _: sortsExt _: decl_namesExt _: body.
	patternsExt notNil ifTrue:[patternsExt free].
	sortsExt notNil ifTrue:[sortsExt free].
	decl_namesExt notNil ifTrue:[decl_namesExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_quantifier_const: c _: is_forall _: weight _: num_bound _: bound _: num_patterns _: patterns _: body [
	"
	   \brief Create a universal or existential quantifier using a list of
	   constants that will form the set of bound variables.

	   def_API('Z3_mk_quantifier_const', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(UINT), _in_array(3, APP), _in(UINT), _in_array(5, PATTERN), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval boundExt patternsExt |

	c ensureValidZ3Object.
	bound ensureValidZ3ASTArray.
	patterns ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	boundExt := self externalArrayFrom: bound.
	patternsExt := self externalArrayFrom: patterns.
	retval := lib _mk_quantifier_const: c _: is_forall _: weight _: num_bound _: boundExt _: num_patterns _: patternsExt _: body.
	boundExt notNil ifTrue:[boundExt free].
	patternsExt notNil ifTrue:[patternsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_quantifier_const_ex: c _: is_forall _: weight _: quantifier_id _: skolem_id _: num_bound _: bound _: num_patterns _: patterns _: num_no_patterns _: no_patterns _: body [
	"
	   \brief Create a universal or existential quantifier using a list of
	   constants that will form the set of bound variables.

	   def_API('Z3_mk_quantifier_const_ex', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(5, APP), _in(UINT), _in_array(7, PATTERN), _in(UINT), _in_array(9, AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval boundExt patternsExt no_patternsExt |

	c ensureValidZ3Object.
	quantifier_id ensureValidZ3Object.
	skolem_id ensureValidZ3Object.
	bound ensureValidZ3ASTArray.
	patterns ensureValidZ3ObjectArray.
	no_patterns ensureValidZ3ASTArray.
	body ensureValidZ3AST.
	boundExt := self externalArrayFrom: bound.
	patternsExt := self externalArrayFrom: patterns.
	no_patternsExt := self externalArrayFrom: no_patterns.
	retval := lib _mk_quantifier_const_ex: c _: is_forall _: weight _: quantifier_id _: skolem_id _: num_bound _: boundExt _: num_patterns _: patternsExt _: num_no_patterns _: no_patternsExt _: body.
	boundExt notNil ifTrue:[boundExt free].
	patternsExt notNil ifTrue:[patternsExt free].
	no_patternsExt notNil ifTrue:[no_patternsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_quantifier_ex: c _: is_forall _: weight _: quantifier_id _: skolem_id _: num_patterns _: patterns _: num_no_patterns _: no_patterns _: num_decls _: sorts _: decl_names _: body [
	"
	   \brief Create a quantifier - universal or existential, with pattern hints, no patterns, and attributes

	   \param c logical context.
	   \param is_forall flag to indicate if this is a universal or existential quantifier.
	   \param quantifier_id identifier to identify quantifier
	   \param skolem_id identifier to identify skolem constants introduced by quantifier.
	   \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
	   \param num_patterns number of patterns.
	   \param patterns array containing the patterns created using #Z3_mk_pattern.
	   \param num_no_patterns number of no_patterns.
	   \param no_patterns array containing subexpressions to be excluded from inferred patterns.
	   \param num_decls number of variables to be bound.
	   \param sorts array of sorts of the bound variables.
	   \param decl_names names of the bound variables.
	   \param body the body of the quantifier.

	   \sa Z3_mk_pattern
	   \sa Z3_mk_bound
	   \sa Z3_mk_forall
	   \sa Z3_mk_exists

	   def_API('Z3_mk_quantifier_ex', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(5, PATTERN), _in(UINT), _in_array(7, AST), _in(UINT), _in_array(9, SORT), _in_array(9, SYMBOL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval patternsExt no_patternsExt sortsExt decl_namesExt |

	c ensureValidZ3Object.
	quantifier_id ensureValidZ3Object.
	skolem_id ensureValidZ3Object.
	patterns ensureValidZ3ObjectArray.
	no_patterns ensureValidZ3ASTArray.
	sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	decl_names ensureValidZ3ObjectArray.
	body ensureValidZ3AST.
	patternsExt := self externalArrayFrom: patterns.
	no_patternsExt := self externalArrayFrom: no_patterns.
	sortsExt := self externalArrayFrom: sorts.
	decl_namesExt := self externalArrayFrom: decl_names.
	retval := lib _mk_quantifier_ex: c _: is_forall _: weight _: quantifier_id _: skolem_id _: num_patterns _: patternsExt _: num_no_patterns _: no_patternsExt _: num_decls _: sortsExt _: decl_namesExt _: body.
	patternsExt notNil ifTrue:[patternsExt free].
	no_patternsExt notNil ifTrue:[no_patternsExt free].
	sortsExt notNil ifTrue:[sortsExt free].
	decl_namesExt notNil ifTrue:[decl_namesExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_allchar: c _: regex_sort [
	"
	   \brief Create a regular expression that accepts all singleton sequences of the regular expression sort

	  def_API('Z3_mk_re_allchar', AST, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	regex_sort ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_re_allchar: c _: regex_sort.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_complement: c _: re [
	"
	   \brief Create the complement of the regular language \c re.

	   def_API('Z3_mk_re_complement', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	re ensureValidZ3AST.
	retval := lib _mk_re_complement: c _: re.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_concat: c _: n _: args [
	"
	   \brief Create the concatenation of the regular languages.

	   \pre n > 0

	   def_API('Z3_mk_re_concat', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_re_concat: c _: n _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_diff: c _: re1 _: re2 [
	"
	   \brief Create the difference of regular expressions.

	   def_API('Z3_mk_re_diff', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	re1 ensureValidZ3AST.
	re2 ensureValidZ3AST.
	retval := lib _mk_re_diff: c _: re1 _: re2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_empty: c _: re [
	"
	   \brief Create an empty regular expression of sort \c re.

	   \pre re is a regular expression sort.

	   def_API('Z3_mk_re_empty', AST ,(_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	re ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_re_empty: c _: re.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_full: c _: re [
	"
	   \brief Create an universal regular expression of sort \c re.

	   \pre re is a regular expression sort.

	   def_API('Z3_mk_re_full', AST ,(_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	re ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_re_full: c _: re.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_intersect: c _: n _: args [
	"
	   \brief Create the intersection of the regular languages.

	   \pre n > 0

	   def_API('Z3_mk_re_intersect', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_re_intersect: c _: n _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_loop: c _: r _: lo _: hi [
	"
	   \brief Create a regular expression loop. The supplied regular expression \c r is repeated
	   between \c lo and \c hi times. The \c lo should be below \c hi with one exception: when
	   supplying the value \c hi as 0, the meaning is to repeat the argument \c r at least
	   \c lo number of times, and with an unbounded upper bound.

	   def_API('Z3_mk_re_loop', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	r ensureValidZ3AST.
	retval := lib _mk_re_loop: c _: r _: lo _: hi.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_option: c _: re [
	"
	   \brief Create the regular language \c [re].

	   def_API('Z3_mk_re_option', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	re ensureValidZ3AST.
	retval := lib _mk_re_option: c _: re.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_plus: c _: re [
	"
	   \brief Create the regular language \c re+.

	   def_API('Z3_mk_re_plus', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	re ensureValidZ3AST.
	retval := lib _mk_re_plus: c _: re.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_power: c _: arg1 _: n [
	"
	   \brief Create a power regular expression.

	   def_API('Z3_mk_re_power', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	retval := lib _mk_re_power: c _: arg1 _: n.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_range: c _: lo _: hi [
	"
	   \brief Create the range regular expression over two sequences of length 1.

	   def_API('Z3_mk_re_range', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	lo ensureValidZ3AST.
	hi ensureValidZ3AST.
	retval := lib _mk_re_range: c _: lo _: hi.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_sort: c _: seq [
	"
	   \brief Create a regular expression sort out of a sequence sort.

	   def_API('Z3_mk_re_sort', SORT, (_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	seq ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_re_sort: c _: seq.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_star: c _: re [
	"
	   \brief Create the regular language \c re*.

	   def_API('Z3_mk_re_star', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	re ensureValidZ3AST.
	retval := lib _mk_re_star: c _: re.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_re_union: c _: n _: args [
	"
	   \brief Create the union of the regular languages.

	   \pre n > 0

	   def_API('Z3_mk_re_union', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_re_union: c _: n _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_real2int: c _: t1 [
	"
		\brief Coerce a real to an integer.

		The semantics of this function follows the SMT-LIB standard
		for the function to_int

		\sa Z3_mk_int2real
		\sa Z3_mk_is_int

		def_API('Z3_mk_real2int', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_real2int: c _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_real: c _: num _: den [
	"
	   \brief Create a real from a fraction.

	   \param c logical context.
	   \param num numerator of rational.
	   \param den denominator of rational.

	   \pre den != 0

	   \sa Z3_mk_numeral
	   \sa Z3_mk_int
	   \sa Z3_mk_unsigned_int

	   def_API('Z3_mk_real', AST, (_in(CONTEXT), _in(INT), _in(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_real: c _: num _: den.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_real_sort: c [
	"
	   \brief Create the real type.

	   Note that this type is not a floating point number.

	   def_API('Z3_mk_real_sort', SORT, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_real_sort: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_rec_func_decl: c _: s _: domain_size _: domain _: range [
	"
	   \brief Declare a recursive function

	   \param c logical context.
	   \param s name of the function.
	   \param domain_size number of arguments. It should be greater than 0.
	   \param domain array containing the sort of each argument. The array must contain domain_size elements. 
	   \param range sort of the constant or the return sort of the function.

	   After declaring recursive function, it should be associated with a recursive definition #Z3_add_rec_def.
	   The function #Z3_mk_app can be used to create a constant or function
	   application.

	   \sa Z3_add_rec_def
	   \sa Z3_mk_app
	   \sa Z3_mk_func_decl

	   def_API('Z3_mk_rec_func_decl', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval domainExt |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	domain ensureValidZ3ASTArrayOfKind: SORT_AST.
	range ensureValidZ3ASTOfKind: SORT_AST.
	domainExt := self externalArrayFrom: domain.
	retval := lib _mk_rec_func_decl: c _: s _: domain_size _: domainExt _: range.
	domainExt notNil ifTrue:[domainExt free].
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_rem: c _: arg1 _: arg2 [
	"
	   \brief Create an AST node representing \ccode{arg1 rem arg2}.

	   The arguments must have int type.

	   def_API('Z3_mk_rem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	arg2 ensureValidZ3AST.
	retval := lib _mk_rem: c _: arg1 _: arg2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_repeat: c _: i _: t1 [
	"
	   \brief Repeat the given bit-vector up length \ccode{i}.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_repeat', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_repeat: c _: i _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_rotate_left: c _: i _: t1 [
	"
	   \brief Rotate bits of \c t1 to the left \c i times.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_rotate_left', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_rotate_left: c _: i _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_rotate_right: c _: i _: t1 [
	"
	   \brief Rotate bits of \c t1 to the right \c i times.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_rotate_right', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_rotate_right: c _: i _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_sbv_to_str: c _: s [
	"
	   \brief Signed bit-vector to string conversion.

	   def_API('Z3_mk_sbv_to_str', AST ,(_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _mk_sbv_to_str: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_select: c _: a _: i [
	"
	   \brief Array read.
	   The argument \c a is the array and \c i is the index of the array that gets read.

	   The node \c a must have an array sort \ccode{[domain -> range]},
	   and \c i must have the sort \c domain.
	   The sort of the result is \c range.

	   \sa Z3_mk_array_sort
	   \sa Z3_mk_store

	   def_API('Z3_mk_select', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	i ensureValidZ3AST.
	retval := lib _mk_select: c _: a _: i.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_select_n: c _: a _: n _: idxs [
	"
	   \brief n-ary Array read.
	   The argument \c a is the array and \c idxs are the indices of the array that gets read.

	   def_API('Z3_mk_select_n', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))

	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval idxsExt |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	idxs ensureValidZ3ASTArray.
	idxsExt := self externalArrayFrom: idxs.
	retval := lib _mk_select_n: c _: a _: n _: idxsExt.
	idxsExt notNil ifTrue:[idxsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_at: c _: s _: index [
	"
	   \brief Retrieve from \c s the unit sequence positioned at position \c index.
	   The sequence is empty if the index is out of bounds.

	   def_API('Z3_mk_seq_at', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	index ensureValidZ3AST.
	retval := lib _mk_seq_at: c _: s _: index.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_concat: c _: n _: args [
	"
	   \brief Concatenate sequences.

	   \pre n > 0

	   def_API('Z3_mk_seq_concat', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_seq_concat: c _: n _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_contains: c _: container _: containee [
	"
	   \brief Check if \c container contains \c containee.

	   \pre \c container and \c containee are the same sequence sorts.

	   def_API('Z3_mk_seq_contains', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	container ensureValidZ3AST.
	containee ensureValidZ3AST.
	retval := lib _mk_seq_contains: c _: container _: containee.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_empty: c _: seq [
	"
	   \brief Create an empty sequence of the sequence sort \c seq.

	   \pre s is a sequence sort.

	   def_API('Z3_mk_seq_empty', AST ,(_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	seq ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_seq_empty: c _: seq.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_extract: c _: s _: offset _: length [
	"
	   \brief Extract subsequence starting at \c offset of \c length.

	   def_API('Z3_mk_seq_extract', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	offset ensureValidZ3AST.
	length ensureValidZ3AST.
	retval := lib _mk_seq_extract: c _: s _: offset _: length.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_in_re: c _: seq _: re [
	"
	   \brief Check if \c seq is in the language generated by the regular expression \c re.

	   def_API('Z3_mk_seq_in_re', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	seq ensureValidZ3AST.
	re ensureValidZ3AST.
	retval := lib _mk_seq_in_re: c _: seq _: re.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_index: c _: s _: substr _: offset [
	"
	   \brief Return index of the first occurrence of \c substr in \c s starting from offset \c offset.
	   If \c s does not contain \c substr, then the value is -1, if \c offset is the length of \c s, then the value is -1 as well.
	   The value is -1 if \c offset is negative or larger than the length of \c s.

	   def_API('Z3_mk_seq_index', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	substr ensureValidZ3AST.
	offset ensureValidZ3AST.
	retval := lib _mk_seq_index: c _: s _: substr _: offset.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_last_index: c _: arg1 _: substr [
	"
	   \brief Return index of the last occurrence of \c substr in \c s.
	   If \c s does not contain \c substr, then the value is -1, 
	   def_API('Z3_mk_seq_last_index', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	substr ensureValidZ3AST.
	retval := lib _mk_seq_last_index: c _: arg1 _: substr.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_length: c _: s [
	"
	   \brief Return the length of the sequence \c s.

	   def_API('Z3_mk_seq_length', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _mk_seq_length: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_nth: c _: s _: index [
	"
	   \brief Retrieve from \c s the element positioned at position \c index.
	   The function is under-specified if the index is out of bounds.

	   def_API('Z3_mk_seq_nth', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	index ensureValidZ3AST.
	retval := lib _mk_seq_nth: c _: s _: index.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_prefix: c _: prefix _: s [
	"
	   \brief Check if \c prefix is a prefix of \c s.

	   \pre prefix and s are the same sequence sorts.

	   def_API('Z3_mk_seq_prefix', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	prefix ensureValidZ3AST.
	s ensureValidZ3AST.
	retval := lib _mk_seq_prefix: c _: prefix _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_replace: c _: s _: src _: dst [
	"
	   \brief Replace the first occurrence of \c src with \c dst in \c s.

	   def_API('Z3_mk_seq_replace', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	src ensureValidZ3AST.
	dst ensureValidZ3AST.
	retval := lib _mk_seq_replace: c _: s _: src _: dst.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_sort: c _: s [
	"
	   \brief Create a sequence sort out of the sort for the elements.

	   def_API('Z3_mk_seq_sort', SORT, (_in(CONTEXT), _in(SORT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_seq_sort: c _: s.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_suffix: c _: suffix _: s [
	"
	   \brief Check if \c suffix is a suffix of \c s.

	   \pre \c suffix and \c s are the same sequence sorts.

	   def_API('Z3_mk_seq_suffix', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	suffix ensureValidZ3AST.
	s ensureValidZ3AST.
	retval := lib _mk_seq_suffix: c _: suffix _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_to_re: c _: seq [
	"
	   \brief Create a regular expression that accepts the sequence \c seq.

	   def_API('Z3_mk_seq_to_re', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	seq ensureValidZ3AST.
	retval := lib _mk_seq_to_re: c _: seq.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_seq_unit: c _: a [
	"
	   \brief Create a unit sequence of \c a.

	   def_API('Z3_mk_seq_unit', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _mk_seq_unit: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_add: c _: set _: elem [
	"
	   \brief Add an element to a set.

	   The first argument must be a set, the second an element.

	   def_API('Z3_mk_set_add', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	set ensureValidZ3AST.
	elem ensureValidZ3AST.
	retval := lib _mk_set_add: c _: set _: elem.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_complement: c _: arg [
	"
	   \brief Take the complement of a set.

	   def_API('Z3_mk_set_complement', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg ensureValidZ3AST.
	retval := lib _mk_set_complement: c _: arg.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_del: c _: set _: elem [
	"
	   \brief Remove an element to a set.

	   The first argument must be a set, the second an element.

	   def_API('Z3_mk_set_del', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	set ensureValidZ3AST.
	elem ensureValidZ3AST.
	retval := lib _mk_set_del: c _: set _: elem.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_difference: c _: arg1 _: arg2 [
	"
	   \brief Take the set difference between two sets.

	   def_API('Z3_mk_set_difference', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	arg2 ensureValidZ3AST.
	retval := lib _mk_set_difference: c _: arg1 _: arg2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_has_size: c _: set _: k [
	"
	   \brief Create predicate that holds if Boolean array \c set has \c k elements set to true.       

	   def_API('Z3_mk_set_has_size', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	set ensureValidZ3AST.
	k ensureValidZ3AST.
	retval := lib _mk_set_has_size: c _: set _: k.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_intersect: c _: num_args _: args [
	"
	   \brief Take the intersection of a list of sets.

	   def_API('Z3_mk_set_intersect', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_set_intersect: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_member: c _: elem _: set [
	"
	   \brief Check for set membership.

	   The first argument should be an element type of the set.

	   def_API('Z3_mk_set_member', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	elem ensureValidZ3AST.
	set ensureValidZ3AST.
	retval := lib _mk_set_member: c _: elem _: set.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_sort: c _: ty [
	"
	   \brief Create Set type.

	   def_API('Z3_mk_set_sort', SORT, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_set_sort: c _: ty.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_subset: c _: arg1 _: arg2 [
	"
	   \brief Check for subsetness of sets.

	   def_API('Z3_mk_set_subset', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg1 ensureValidZ3AST.
	arg2 ensureValidZ3AST.
	retval := lib _mk_set_subset: c _: arg1 _: arg2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_set_union: c _: num_args _: args [
	"
	   \brief Take the union of a list of sets.

	   def_API('Z3_mk_set_union', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_set_union: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_sign_ext: c _: i _: t1 [
	"
	   \brief Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of
	   size \ccode{m+i}, where \c m is the size of the given
	   bit-vector.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_sign_ext', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_sign_ext: c _: i _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_simple_solver: c [
	"
	   \brief Create a new incremental solver.

	   This is equivalent to applying the 'smt' tactic.

	   Unlike #Z3_mk_solver() this solver
		 - Does not attempt to apply any logic specific tactics.
		 - Does not change its behaviour based on whether it used
		   incrementally/non-incrementally.

	   Note that these differences can result in very different performance
	   compared to #Z3_mk_solver().

	   The function #Z3_solver_get_model retrieves a model if the
	   assertions is satisfiable (i.e., the result is \c
	   Z3_L_TRUE) and model construction is enabled.
	   The function #Z3_solver_get_model can also be used even
	   if the result is \c Z3_L_UNDEF, but the returned model
	   is not guaranteed to satisfy quantified assertions.

	   \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
	   Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_simple_solver', SOLVER, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_simple_solver: c.
	c errorCheck.
	^ Z3Solver fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_solver: c [
	"
	   \brief Create a new solver. This solver is a 'combined solver' (see
	   combined_solver module) that internally uses a non-incremental (solver1) and an
	   incremental solver (solver2). This combined solver changes its behaviour based
	   on how it is used and how its parameters are set.

	   If the solver is used in a non incremental way (i.e. no calls to
	   #Z3_solver_push() or #Z3_solver_pop(), and no calls to
	   #Z3_solver_assert() or #Z3_solver_assert_and_track() after checking
	   satisfiability without an intervening #Z3_solver_reset()) then solver1
	   will be used. This solver will apply Z3's 'default' tactic.

	   The 'default' tactic will attempt to probe the logic used by the
	   assertions and will apply a specialized tactic if one is supported.
	   Otherwise the general `(and-then simplify smt)` tactic will be used.

	   If the solver is used in an incremental way then the combined solver
	   will switch to using solver2 (which behaves similarly to the general
	   'smt' tactic).

	   Note however it is possible to set the `solver2_timeout`,
	   `solver2_unknown`, and `ignore_solver1` parameters of the combined
	   solver to change its behaviour.

	   The function #Z3_solver_get_model retrieves a model if the
	   assertions is satisfiable (i.e., the result is \c
	   Z3_L_TRUE) and model construction is enabled.
	   The function #Z3_solver_get_model can also be used even
	   if the result is \c Z3_L_UNDEF, but the returned model
	   is not guaranteed to satisfy quantified assertions.

	   \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
	   Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_solver', SOLVER, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_solver: c.
	c errorCheck.
	^ Z3Solver fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_solver_for_logic: c _: logic [
	"
	   \brief Create a new solver customized for the given logic.
	   It behaves like #Z3_mk_solver if the logic is unknown or unsupported.

	   \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
	   Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_solver_for_logic', SOLVER, (_in(CONTEXT), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	logic ensureValidZ3Object.
	retval := lib _mk_solver_for_logic: c _: logic.
	c errorCheck.
	^ Z3Solver fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_solver_from_tactic: c _: t [
	"
	   \brief Create a new solver that is implemented using the given tactic.
	   The solver supports the commands #Z3_solver_push and #Z3_solver_pop, but it
	   will always solve each #Z3_solver_check from scratch.

	   \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
	   Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_mk_solver_from_tactic', SOLVER, (_in(CONTEXT), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> mk_store: c _: a _: i _: v [
	"
	   \brief Array update.

	   The node \c a must have an array sort \ccode{[domain -> range]}, \c i must have sort \c domain,
	   \c v must have sort range. The sort of the result is \ccode{[domain -> range]}.
	   The semantics of this function is given by the theory of arrays described in the SMT-LIB
	   standard. See http://smtlib.org for more details.
	   The result of this function is an array that is equal to \c a (with respect to \c select)
	   on all indices except for \c i, where it maps to \c v (and the \c select of \c a with
	   respect to \c i may be a different value).

	   \sa Z3_mk_array_sort
	   \sa Z3_mk_select

	   def_API('Z3_mk_store', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	i ensureValidZ3AST.
	v ensureValidZ3AST.
	retval := lib _mk_store: c _: a _: i _: v.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_store_n: c _: a _: n _: idxs _: v [
	"
	   \brief n-ary Array update.

	   def_API('Z3_mk_store_n', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST), _in(AST)))

	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval idxsExt |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	idxs ensureValidZ3ASTArray.
	v ensureValidZ3AST.
	idxsExt := self externalArrayFrom: idxs.
	retval := lib _mk_store_n: c _: a _: n _: idxsExt _: v.
	idxsExt notNil ifTrue:[idxsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_str_le: c _: prefix _: s [
	"
	   \brief Check if \c s1 is equal or lexicographically strictly less than \c s2.

	   \pre \c s1 and \c s2 are strings

	   def_API('Z3_mk_str_le', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	prefix ensureValidZ3AST.
	s ensureValidZ3AST.
	retval := lib _mk_str_le: c _: prefix _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_str_lt: c _: prefix _: s [
	"
	   \brief Check if \c s1 is lexicographically strictly less than \c s2.

	   \pre \c s1 and \c s2 are strings

	   def_API('Z3_mk_str_lt', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	prefix ensureValidZ3AST.
	s ensureValidZ3AST.
	retval := lib _mk_str_lt: c _: prefix _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_str_to_int: c _: s [
	"
	   \brief Convert string to integer.

	   def_API('Z3_mk_str_to_int', AST ,(_in(CONTEXT), _in(AST)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _mk_str_to_int: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_string: c _: s [
	"
	   \brief Create a string constant out of the string that is passed in
	   The string may contain escape encoding for non-printable characters
	   or characters outside of the basic printable ASCII range. For example, 
	   the escape encoding \\u{0} represents the character 0 and the encoding
	   \\u{100} represents the character 256.

	   def_API('Z3_mk_string', AST, (_in(CONTEXT), _in(STRING)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_string: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_string_from_code: c _: a [
	"
	   \brief Code to string conversion.
	   
	   def_API('Z3_mk_string_from_code', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _mk_string_from_code: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_string_sort: c [
	"
	   \brief Create a sort for unicode strings.

	   The sort for characters can be changed to ASCII by setting
	   the global parameter \c encoding to \c ascii, or alternative
	   to 16 bit characters by setting \c encoding to \c bmp.

	   def_API('Z3_mk_string_sort', SORT, (_in(CONTEXT), ))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_string_sort: c.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_string_symbol: c _: s [
	"
	   \brief Create a Z3 symbol using a C string.

	   Symbols are used to name several term and type constructors.

	   \sa Z3_get_symbol_string
	   \sa Z3_mk_int_symbol

	   def_API('Z3_mk_string_symbol', SYMBOL, (_in(CONTEXT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_string_symbol: c _: s.
	c errorCheck.
	^ Z3Symbol fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_string_to_code: c _: a [
	"
	   \brief String to code conversion.
	   
	   def_API('Z3_mk_string_to_code', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _mk_string_to_code: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_sub: c _: num_args _: args [
	"
	   \brief Create an AST node representing \ccode{args[0] - ... - args[num_args - 1]}.

	   The array \c args must have \c num_args elements.
	   All arguments must have int or real sort.

	   \remark The number of arguments must be greater than zero.

	   def_API('Z3_mk_sub', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _mk_sub: c _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_tactic: c _: name [
	"
	   \brief Return a tactic associated with the given name.
	   The complete list of tactics may be obtained using the procedures #Z3_get_num_tactics and #Z3_get_tactic_name.
	   It may also be obtained using the command \ccode{(help-tactic)} in the SMT 2.0 front-end.

	   Tactics are the basic building block for creating custom solvers for specific problem domains.

	   def_API('Z3_mk_tactic', TACTIC, (_in(CONTEXT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> mk_transitive_closure: c _: f [
	"
	   \brief create transitive closure of binary relation.

	   \pre f is a binary relation, such that the two arguments have the same sorts.

	   The resulting relation f+ represents the transitive closure of f.

	   def_API('Z3_mk_transitive_closure', FUNC_DECL ,(_in(CONTEXT), _in(FUNC_DECL)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	f ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _mk_transitive_closure: c _: f.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_tree_order: c _: a _: id [
	"
	   \brief create a tree ordering relation over signature \c a identified using index \c id.

	   def_API('Z3_mk_tree_order', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_tree_order: c _: a _: id.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_true: c [
	"
		\brief Create an AST node representing \c true.

		def_API('Z3_mk_true', AST, (_in(CONTEXT), ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _mk_true: c.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_tuple_sort: c _: mk_tuple_name _: num_fields _: field_names _: field_sorts _: mk_tuple_decl _: proj_decl [
	"
	   \brief Create a tuple type.

	   A tuple with \c n fields has a constructor and \c n projections.
	   This function will also declare the constructor and projection functions.

	   \param c logical context
	   \param mk_tuple_name name of the constructor function associated with the tuple type.
	   \param num_fields number of fields in the tuple type.
	   \param field_names name of the projection functions.
	   \param field_sorts type of the tuple fields.
	   \param mk_tuple_decl output parameter that will contain the constructor declaration.
	   \param proj_decl output parameter that will contain the projection function declarations. This field must be a buffer of size \c num_fields allocated by the user.

	   def_API('Z3_mk_tuple_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _out(FUNC_DECL), _out_array(2, FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval field_namesExt field_sortsExt mk_tuple_declExt proj_declExt |

	c ensureValidZ3Object.
	mk_tuple_name ensureValidZ3Object.
	field_names ensureValidZ3ObjectArray.
	field_sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	field_namesExt := self externalArrayFrom: field_names.
	field_sortsExt := self externalArrayFrom: field_sorts.
	mk_tuple_declExt := self externalArrayFrom: mk_tuple_decl.
	proj_declExt := self externalArrayFrom: proj_decl.
	retval := lib _mk_tuple_sort: c _: mk_tuple_name _: num_fields _: field_namesExt _: field_sortsExt _: mk_tuple_declExt _: proj_declExt.
	field_namesExt notNil ifTrue:[field_namesExt free].
	field_sortsExt notNil ifTrue:[field_sortsExt free].
	1 to: mk_tuple_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: mk_tuple_declExt pointerAt: i) inContext: c.
		mk_tuple_decl at: i put: v.
	].
	mk_tuple_declExt notNil ifTrue:[mk_tuple_declExt free].
	1 to: proj_decl size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: proj_declExt pointerAt: i) inContext: c.
		proj_decl at: i put: v.
	].
	proj_declExt notNil ifTrue:[proj_declExt free].
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_u32string: c _: len _: chars [
	"
	   \brief Create a string constant out of the string that is passed in
	   It takes the length of the string as well to take into account
	   0 characters. The string is unescaped.

	   def_API('Z3_mk_u32string', AST, (_in(CONTEXT), _in(UINT), _in_array(1, UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval charsExt |

	c ensureValidZ3Object.
	charsExt := Z3Object externalU32ArrayFrom: chars.
	retval := lib _mk_u32string: c _: len _: charsExt.
	charsExt notNil ifTrue:[charsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_ubv_to_str: c _: s [
	"
	   \brief Unsigned bit-vector to string conversion.

	   def_API('Z3_mk_ubv_to_str', AST ,(_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3AST.
	retval := lib _mk_ubv_to_str: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_unary_minus: c _: arg [
	"
	   \brief Create an AST node representing \ccode{- arg}.

	   The arguments must have int or real type.

	   def_API('Z3_mk_unary_minus', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	arg ensureValidZ3AST.
	retval := lib _mk_unary_minus: c _: arg.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_uninterpreted_sort: c _: s [
	"
	   \brief Create a free (uninterpreted) type using the given name (symbol).

	   Two free types are considered the same iff the have the same name.

	   def_API('Z3_mk_uninterpreted_sort', SORT, (_in(CONTEXT), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _mk_uninterpreted_sort: c _: s.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_unsigned_int64: c _: v _: ty [
	"
	   \brief Create a numeral of a int, bit-vector, or finite-domain sort.

	   This function can be used to create numerals that fit in a machine \c uint64_t integer.
	   It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.

	   \sa Z3_mk_numeral

	   def_API('Z3_mk_unsigned_int64', AST, (_in(CONTEXT), _in(UINT64), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_unsigned_int64: c _: v _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_unsigned_int: c _: v _: ty [
	"
	   \brief Create a numeral of a int, bit-vector, or finite-domain sort.

	   This function can be used to create numerals that fit in a machine unsigned integer.
	   It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.

	   \sa Z3_mk_numeral

	   def_API('Z3_mk_unsigned_int', AST, (_in(CONTEXT), _in(UINT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	ty ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _mk_unsigned_int: c _: v _: ty.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_xor: c _: t1 _: t2 [
	"
	   \brief Create an AST node representing \ccode{t1 xor t2}.

	   The nodes \c t1 and \c t2 must have Boolean sort.

	   def_API('Z3_mk_xor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	t2 ensureValidZ3AST.
	retval := lib _mk_xor: c _: t1 _: t2.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> mk_zero_ext: c _: i _: t1 [
	"
	   \brief Extend the given bit-vector with zeros to the (unsigned) equivalent
	   bit-vector of size \ccode{m+i}, where \c m is the size of the
	   given bit-vector.

	   The node \c t1 must have a bit-vector sort.

	   def_API('Z3_mk_zero_ext', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	t1 ensureValidZ3AST.
	retval := lib _mk_zero_ext: c _: i _: t1.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> model_dec_ref: c _: m [
	"
	   \brief Decrement the reference counter of the given model.

	   def_API('Z3_model_dec_ref', VOID, (_in(CONTEXT), _in(MODEL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_dec_ref: c _: m.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_eval: c _: m _: t _: model_completion _: v [
	"
	   \brief Evaluate the AST node \c t in the given model.
	   Return \c true if succeeded, and store the result in \c v.

	   If \c model_completion is \c true, then Z3 will assign an interpretation for any constant or function that does
	   not have an interpretation in \c m. These constants and functions were essentially don't cares.

	   If \c model_completion is \c false, then Z3 will not assign interpretations to constants for functions that do
	   not have interpretations in \c m. Evaluation behaves as the identify function in this case.

	   The evaluation may fail for the following reasons:

	   - \c t contains a quantifier.

	   - the model \c m is partial, that is, it doesn't have a complete interpretation for uninterpreted functions.
	   That is, the option \ccode{MODEL_PARTIAL=true} was used.

	   - \c t is type incorrect.

	   - \c Z3_interrupt was invoked during evaluation.

	   def_API('Z3_model_eval', BOOL, (_in(CONTEXT), _in(MODEL), _in(AST), _in(BOOL), _out(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval vExt |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	t ensureValidZ3AST.
	vExt := self externalArrayFrom: v.
	retval := lib _model_eval: c _: m _: t _: model_completion _: vExt.
	1 to: v size do: [ :i |
		| value |

		value := Z3AST fromExternalAddress: (Z3Object externalArray: vExt pointerAt: i) inContext: c.
		v at: i put: value.
	].
	vExt notNil ifTrue:[vExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_extrapolate: c _: m _: fml [
	"
	   \brief Extrapolates a model of a formula

	   def_API('Z3_model_extrapolate', AST, (_in(CONTEXT), _in(MODEL), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	fml ensureValidZ3AST.
	retval := lib _model_extrapolate: c _: m _: fml.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> model_get_const_decl: c _: m _: i [
	"
	   \brief Return the i-th constant in the given model.

	   \pre i < Z3_model_get_num_consts(c, m)

	   \sa Z3_model_eval

	   def_API('Z3_model_get_const_decl', FUNC_DECL, (_in(CONTEXT), _in(MODEL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_get_const_decl: c _: m _: i.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> model_get_const_interp: c _: m _: a [
	"
	   \brief Return the interpretation (i.e., assignment) of constant \c a in the model \c m.
	   Return \c NULL, if the model does not assign an interpretation for \c a.
	   That should be interpreted as: the value of \c a does not matter.

	   \pre Z3_get_arity(c, a) == 0

	   def_API('Z3_model_get_const_interp', AST, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	a ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _model_get_const_interp: c _: m _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> model_get_func_decl: c _: m _: i [
	"
	   \brief Return the declaration of the i-th function in the given model.

	   \pre i < Z3_model_get_num_funcs(c, m)

	   \sa Z3_model_get_num_funcs

	   def_API('Z3_model_get_func_decl', FUNC_DECL, (_in(CONTEXT), _in(MODEL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_get_func_decl: c _: m _: i.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> model_get_func_interp: c _: m _: f [
	"
	   \brief Return the interpretation of the function \c f in the model \c m.
	   Return \c NULL, if the model does not assign an interpretation for \c f.
	   That should be interpreted as: the \c f does not matter.

	   \pre Z3_get_arity(c, f) > 0

	   \remark Reference counting must be used to manage Z3_func_interp objects, even when the Z3_context was
	   created using #Z3_mk_context instead of #Z3_mk_context_rc.

	   def_API('Z3_model_get_func_interp', FUNC_INTERP, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type FUNC_INTERP not (yet) supported.'


]

{ #category : #API }
Z3 class >> model_get_num_consts: c _: m [
	"
	   \brief Return the number of constants assigned by the given model.

	   \sa Z3_model_get_const_decl

	   def_API('Z3_model_get_num_consts', UINT, (_in(CONTEXT), _in(MODEL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_get_num_consts: c _: m.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_get_num_funcs: c _: m [
	"
	   \brief Return the number of function interpretations in the given model.

	   A function interpretation is represented as a finite map and an 'else' value.
	   Each entry in the finite map represents the value of a function given a set of arguments.

	   def_API('Z3_model_get_num_funcs', UINT, (_in(CONTEXT), _in(MODEL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_get_num_funcs: c _: m.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_get_num_sorts: c _: m [
	"
	   \brief Return the number of uninterpreted sorts that \c m assigns an interpretation to.

	   Z3 also provides an interpretation for uninterpreted sorts used in a formula.
	   The interpretation for a sort \c s is a finite set of distinct values. We say this finite set is
	   the 'universe' of \c s.

	   \sa Z3_model_get_sort
	   \sa Z3_model_get_sort_universe

	   def_API('Z3_model_get_num_sorts', UINT, (_in(CONTEXT), _in(MODEL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_get_num_sorts: c _: m.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_get_sort: c _: m _: i [
	"
	   \brief Return a uninterpreted sort that \c m assigns an interpretation.

	   \pre i < Z3_model_get_num_sorts(c, m)

	   \sa Z3_model_get_num_sorts
	   \sa Z3_model_get_sort_universe

	   def_API('Z3_model_get_sort', SORT, (_in(CONTEXT), _in(MODEL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_get_sort: c _: m _: i.
	c errorCheck.
	^ Z3Sort fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> model_get_sort_universe: c _: m _: s [
	"
	   \brief Return the finite set of distinct values that represent the interpretation for sort \c s.

	   \sa Z3_model_get_num_sorts
	   \sa Z3_model_get_sort

	   def_API('Z3_model_get_sort_universe', AST_VECTOR, (_in(CONTEXT), _in(MODEL), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _model_get_sort_universe: c _: m _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> model_has_interp: c _: m _: a [
	"
	   \brief Test if there exists an interpretation (i.e., assignment) for \c a in the model \c m.

	   def_API('Z3_model_has_interp', BOOL, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	a ensureValidZ3ASTOfKind: FUNC_DECL_AST.
	retval := lib _model_has_interp: c _: m _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_inc_ref: c _: m [
	"
	   \brief Increment the reference counter of the given model.

	   def_API('Z3_model_inc_ref', VOID, (_in(CONTEXT), _in(MODEL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_inc_ref: c _: m.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_to_string: c _: m [
	"
	   \brief Convert the given model into a string.

	   \warning The result buffer is statically allocated by Z3. It will
	   be automatically deallocated when #Z3_del_context is invoked.
	   So, the buffer is invalidated in the next call to \c Z3_model_to_string.

	   def_API('Z3_model_to_string', STRING, (_in(CONTEXT), _in(MODEL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	retval := lib _model_to_string: c _: m.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> model_translate: c _: m _: dst [
	"
	   \brief translate model from context \c c to context \c dst.

	   \remark Use this method for cloning state between contexts. Note that 
	   operations on contexts are not thread safe and therefore all operations
	   that related to a given context have to be synchronized (or run in the same thread).

	   def_API('Z3_model_translate', MODEL, (_in(CONTEXT), _in(MODEL), _in(CONTEXT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	dst ensureValidZ3Object.
	retval := lib _model_translate: c _: m _: dst.
	c errorCheck.
	^ Z3Model fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> optimize_assert: c _: o _: a [
	"
	   \brief Assert hard constraint to the optimization context.

	   \sa Z3_optimize_assert_soft
	   \sa Z3_optimize_assert_and_track

	   def_API('Z3_optimize_assert', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_assert_and_track: c _: o _: a _: t [
	"
	   \brief Assert tracked hard constraint to the optimization context.

	   \sa Z3_optimize_assert
	   \sa Z3_optimize_assert_soft

	   def_API('Z3_optimize_assert_and_track', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_assert_soft: c _: o _: a _: weight _: id [
	"
	   \brief Assert soft constraint to the optimization context.
	   \param c - context
	   \param o - optimization context
	   \param a - formula
	   \param weight - a penalty for violating soft constraint. Negative weights convert into rewards.
	   \param id - optional identifier to group soft constraints

	   \sa Z3_optimize_assert
	   \sa Z3_optimize_assert_and_track

	   def_API('Z3_optimize_assert_soft', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST), _in(STRING), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_check: c _: o _: num_assumptions _: assumptions [
	"
	   \brief Check consistency and produce optimal values.
	   \param c - context
	   \param o - optimization context
	   \param num_assumptions - number of additional assumptions
	   \param assumptions - the additional assumptions

	   \sa Z3_optimize_get_reason_unknown
	   \sa Z3_optimize_get_model
	   \sa Z3_optimize_get_statistics
	   \sa Z3_optimize_get_unsat_core

	   def_API('Z3_optimize_check', INT, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_dec_ref: c _: d [
	"
	   \brief Decrement the reference counter of the given optimize context.

	   def_API('Z3_optimize_dec_ref', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_from_file: c _: o _: s [
	"
	   \brief Parse an SMT-LIB2 file with assertions,
	   soft constraints and optimization objectives.
	   Add the parsed constraints and objectives to the optimization context.

	   \param c - context.
	   \param o - optimize context.
	   \param s - path to file containing SMT2 specification.

	   \sa Z3_optimize_from_string
	   \sa Z3_optimize_to_string

	   def_API('Z3_optimize_from_file', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_from_string: c _: o _: s [
	"
	   \brief Parse an SMT-LIB2 string with assertions,
	   soft constraints and optimization objectives.
	   Add the parsed constraints and objectives to the optimization context.

	   \param c - context.
	   \param o - optimize context.
	   \param s - string containing SMT2 specification.

	   \sa Z3_optimize_from_file
	   \sa Z3_optimize_to_string

	   def_API('Z3_optimize_from_string', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_assertions: c _: o [
	"
	   \brief Return the set of asserted formulas on the optimization context.

	   def_API('Z3_optimize_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_help: c _: t [
	"
	   \brief Return a string containing a description of parameters accepted by optimize.

	   \sa Z3_optimize_get_param_descrs
	   \sa Z3_optimize_set_params

	   def_API('Z3_optimize_get_help', STRING, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_lower: c _: o _: idx [
	"
	   \brief Retrieve lower bound value or approximation for the i'th optimization objective.

	   \param c - context
	   \param o - optimization context
	   \param idx - index of optimization objective

	   \sa Z3_optimize_get_upper
	   \sa Z3_optimize_get_lower_as_vector
	   \sa Z3_optimize_get_upper_as_vector

	   def_API('Z3_optimize_get_lower', AST, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_lower_as_vector: c _: o _: idx [
	"
	   \brief Retrieve lower bound value or approximation for the i'th optimization objective.
			  The returned vector is of length 3. It always contains numerals.
			  The three numerals are coefficients \c a, \c b, \c c and encode the result of
			  #Z3_optimize_get_lower \ccode{a * infinity + b + c * epsilon}.
			  
	   \param c - context
	   \param o - optimization context
	   \param idx - index of optimization objective

	   \sa Z3_optimize_get_lower
	   \sa Z3_optimize_get_upper
	   \sa Z3_optimize_get_upper_as_vector

	   def_API('Z3_optimize_get_lower_as_vector', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_model: c _: o [
	"
	   \brief Retrieve the model for the last #Z3_optimize_check

	   The error handler is invoked if a model is not available because
	   the commands above were not invoked for the given optimization
	   solver, or if the result was \c Z3_L_FALSE.

	   def_API('Z3_optimize_get_model', MODEL, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_objectives: c _: o [
	"
	   \brief Return objectives on the optimization context.
	   If the objective function is a max-sat objective it is returned
	   as a Pseudo-Boolean (minimization) sum of the form \ccode{(+ (if f1 w1 0) (if f2 w2 0) ...)}
	   If the objective function is entered as a maximization objective, then return
	   the corresponding minimization objective. In this way the resulting objective
	   function is always returned as a minimization objective.

	   def_API('Z3_optimize_get_objectives', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_param_descrs: c _: o [
	"
	   \brief Return the parameter description set for the given optimize object.

	   \param c - context
	   \param o - optimization context

	   \sa Z3_optimize_get_help
	   \sa Z3_optimize_set_params

	   def_API('Z3_optimize_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_reason_unknown: c _: d [
	"
	   \brief Retrieve a string that describes the last status returned by #Z3_optimize_check.

	   Use this method when #Z3_optimize_check returns \c Z3_L_UNDEF.

	   def_API('Z3_optimize_get_reason_unknown', STRING, (_in(CONTEXT), _in(OPTIMIZE) ))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_statistics: c _: d [
	"
	   \brief Retrieve statistics information from the last call to #Z3_optimize_check

	   def_API('Z3_optimize_get_statistics', STATS, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_upper: c _: o _: idx [
	"
	   \brief Retrieve upper bound value or approximation for the i'th optimization objective.

	   \param c - context
	   \param o - optimization context
	   \param idx - index of optimization objective

	   \sa Z3_optimize_get_lower
	   \sa Z3_optimize_get_lower_as_vector
	   \sa Z3_optimize_get_upper_as_vector

	   def_API('Z3_optimize_get_upper', AST, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_get_upper_as_vector: c _: o _: idx [
	"
	   \brief Retrieve upper bound value or approximation for the i'th optimization objective.

	   \param c - context
	   \param o - optimization context
	   \param idx - index of optimization objective

	   \sa Z3_optimize_get_lower
	   \sa Z3_optimize_get_upper
	   \sa Z3_optimize_get_lower_as_vector

	   def_API('Z3_optimize_get_upper_as_vector', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_inc_ref: c _: d [
	"
	   \brief Increment the reference counter of the given optimize context

	   def_API('Z3_optimize_inc_ref', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_maximize: c _: o _: t [
	"
	   \brief Add a maximization constraint.
	   \param c - context
	   \param o - optimization context
	   \param t - arithmetical term

	   \sa Z3_optimize_minimize

	   def_API('Z3_optimize_maximize', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_minimize: c _: o _: t [
	"
	   \brief Add a minimization constraint.
	   \param c - context
	   \param o - optimization context
	   \param t - arithmetical term

	   \sa Z3_optimize_maximize

	   def_API('Z3_optimize_minimize', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_pop: c _: d [
	"
	   \brief Backtrack one level.

	   \sa Z3_optimize_push

	   \pre The number of calls to pop cannot exceed calls to push.

	   def_API('Z3_optimize_pop', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_push: c _: d [
	"
	   \brief Create a backtracking point.

	   The optimize solver contains a set of rules, added facts and assertions.
	   The set of rules, facts and assertions are restored upon calling #Z3_optimize_pop.

	   \sa Z3_optimize_pop

	   def_API('Z3_optimize_push', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_set_params: c _: o _: p [
	"
	   \brief Set parameters on optimization context.

	   \param c - context
	   \param o - optimization context
	   \param p - parameters

	   \sa Z3_optimize_get_help
	   \sa Z3_optimize_get_param_descrs

	   def_API('Z3_optimize_set_params', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> optimize_to_string: c _: o [
	"
	   \brief Print the current context as a string.
	   \param c - context.
	   \param o - optimization context.

	   \sa Z3_optimize_from_file
	   \sa Z3_optimize_from_string

	   def_API('Z3_optimize_to_string', STRING, (_in(CONTEXT), _in(OPTIMIZE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type OPTIMIZE not (yet) supported.'


]

{ #category : #API }
Z3 class >> param_descrs_dec_ref: c _: p [
	"
	   \brief Decrement the reference counter of the given parameter description set.

	   def_API('Z3_param_descrs_dec_ref', VOID, (_in(CONTEXT), _in(PARAM_DESCRS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> param_descrs_get_documentation: c _: p _: s [
	"
	   \brief Retrieve documentation string corresponding to parameter name \c s.

	   def_API('Z3_param_descrs_get_documentation', STRING, (_in(CONTEXT), _in(PARAM_DESCRS), _in(SYMBOL)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> param_descrs_get_kind: c _: p _: n [
	"
	   \brief Return the kind associated with the given parameter name \c n.

	   def_API('Z3_param_descrs_get_kind', UINT, (_in(CONTEXT), _in(PARAM_DESCRS), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> param_descrs_get_name: c _: p _: i [
	"
	   \brief Return the name of the parameter at given index \c i.

	   \pre i < Z3_param_descrs_size(c, p)

	   def_API('Z3_param_descrs_get_name', SYMBOL, (_in(CONTEXT), _in(PARAM_DESCRS), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> param_descrs_inc_ref: c _: p [
	"
	   \brief Increment the reference counter of the given parameter description set.

	   def_API('Z3_param_descrs_inc_ref', VOID, (_in(CONTEXT), _in(PARAM_DESCRS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> param_descrs_size: c _: p [
	"
	   \brief Return the number of parameters in the given parameter description set.

	   def_API('Z3_param_descrs_size', UINT, (_in(CONTEXT), _in(PARAM_DESCRS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> param_descrs_to_string: c _: p [
	"
	   \brief Convert a parameter description set into a string. This function is mainly used for printing the
	   contents of a parameter description set.

	   def_API('Z3_param_descrs_to_string', STRING, (_in(CONTEXT), _in(PARAM_DESCRS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> params_dec_ref: c _: p [
	"
	   \brief Decrement the reference counter of the given parameter set.

	   def_API('Z3_params_dec_ref', VOID, (_in(CONTEXT), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _params_dec_ref: c _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> params_inc_ref: c _: p [
	"
	   \brief Increment the reference counter of the given parameter set.

	   def_API('Z3_params_inc_ref', VOID, (_in(CONTEXT), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _params_inc_ref: c _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> params_set_bool: c _: p _: k _: v [
	"
	   \brief Add a Boolean parameter \c k with value \c v to the parameter set \c p.

	   def_API('Z3_params_set_bool', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	k ensureValidZ3Object.
	retval := lib _params_set_bool: c _: p _: k _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> params_set_double: c _: p _: k _: v [
	"
	   \brief Add a double parameter \c k with value \c v to the parameter set \c p.

	   def_API('Z3_params_set_double', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(DOUBLE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	k ensureValidZ3Object.
	retval := lib _params_set_double: c _: p _: k _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> params_set_symbol: c _: p _: k _: v [
	"
	   \brief Add a symbol parameter \c k with value \c v to the parameter set \c p.

	   def_API('Z3_params_set_symbol', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(SYMBOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	k ensureValidZ3Object.
	v ensureValidZ3Object.
	retval := lib _params_set_symbol: c _: p _: k _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> params_set_uint: c _: p _: k _: v [
	"
	   \brief Add a unsigned parameter \c k with value \c v to the parameter set \c p.

	   def_API('Z3_params_set_uint', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	k ensureValidZ3Object.
	retval := lib _params_set_uint: c _: p _: k _: v.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> params_to_string: c _: p [
	"
	   \brief Convert a parameter set into a string. This function is mainly used for printing the
	   contents of a parameter set.

	   def_API('Z3_params_to_string', STRING, (_in(CONTEXT), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _params_to_string: c _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> params_validate: c _: p _: d [
	"
	   \brief Validate the parameter set \c p against the parameter description set \c d.

	   The procedure invokes the error handler if \c p is invalid.

	   def_API('Z3_params_validate', VOID, (_in(CONTEXT), _in(PARAMS), _in(PARAM_DESCRS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> parse_smtlib2_file: c _: file_name _: num_sorts _: sort_names _: sorts _: num_decls _: decl_names _: decls [
	"
	   \brief Similar to #Z3_parse_smtlib2_string, but reads the benchmark from a file.

	   def_API('Z3_parse_smtlib2_file', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval sort_namesExt sortsExt decl_namesExt declsExt |

	c ensureValidZ3Object.
	sort_names ensureValidZ3ObjectArray.
	sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	decl_names ensureValidZ3ObjectArray.
	decls ensureValidZ3ASTArrayOfKind: FUNC_DECL_AST.
	sort_namesExt := self externalArrayFrom: sort_names.
	sortsExt := self externalArrayFrom: sorts.
	decl_namesExt := self externalArrayFrom: decl_names.
	declsExt := self externalArrayFrom: decls.
	retval := lib _parse_smtlib2_file: c _: file_name _: num_sorts _: sort_namesExt _: sortsExt _: num_decls _: decl_namesExt _: declsExt.
	sort_namesExt notNil ifTrue:[sort_namesExt free].
	sortsExt notNil ifTrue:[sortsExt free].
	decl_namesExt notNil ifTrue:[decl_namesExt free].
	declsExt notNil ifTrue:[declsExt free].
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> parse_smtlib2_string: c _: str _: num_sorts _: sort_names _: sorts _: num_decls _: decl_names _: decls [
	"
	   \brief Parse the given string using the SMT-LIB2 parser.

	   It returns a formula comprising of the conjunction of assertions in the scope
	   (up to push/pop) at the end of the string.

	   def_API('Z3_parse_smtlib2_string', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval sort_namesExt sortsExt decl_namesExt declsExt |

	c ensureValidZ3Object.
	sort_names ensureValidZ3ObjectArray.
	sorts ensureValidZ3ASTArrayOfKind: SORT_AST.
	decl_names ensureValidZ3ObjectArray.
	decls ensureValidZ3ASTArrayOfKind: FUNC_DECL_AST.
	sort_namesExt := self externalArrayFrom: sort_names.
	sortsExt := self externalArrayFrom: sorts.
	decl_namesExt := self externalArrayFrom: decl_names.
	declsExt := self externalArrayFrom: decls.
	retval := lib _parse_smtlib2_string: c _: str _: num_sorts _: sort_namesExt _: sortsExt _: num_decls _: decl_namesExt _: declsExt.
	sort_namesExt notNil ifTrue:[sort_namesExt free].
	sortsExt notNil ifTrue:[sortsExt free].
	decl_namesExt notNil ifTrue:[decl_namesExt free].
	declsExt notNil ifTrue:[declsExt free].
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> pattern_to_ast: c _: p [
	"
	   \brief Convert a Z3_pattern into Z3_ast. This is just type casting.

	   def_API('Z3_pattern_to_ast', AST, (_in(CONTEXT), _in(PATTERN)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _pattern_to_ast: c _: p.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> pattern_to_string: c _: p [
	"
	  def_API('Z3_pattern_to_string', STRING, (_in(CONTEXT), _in(PATTERN)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _pattern_to_string: c _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> polynomial_subresultants: c _: p _: q _: x [
	"
	   \brief Return the nonzero subresultants of \c p and \c q with respect to the 'variable' \c x.

	   \pre \c p, \c q and \c x are Z3 expressions where \c p and \c q are arithmetic terms.
	   Note that, any subterm that cannot be viewed as a polynomial is assumed to be a variable.
	   Example: \ccode{f(a)} is a considered to be a variable in the polynomial \ccode{
	   f(a)*f(a) + 2*f(a) + 1}

	   def_API('Z3_polynomial_subresultants', AST_VECTOR, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	p ensureValidZ3AST.
	q ensureValidZ3AST.
	x ensureValidZ3AST.
	retval := lib _polynomial_subresultants: c _: p _: q _: x.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> probe_and: x _: p1 _: p2 [
	"
	   \brief Return a probe that evaluates to 'true' when \c p1 and \c p2 evaluates to true.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_and', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_apply: c _: p _: g [
	"
	   \brief Execute the probe over the goal. The probe always produce a double value.
	   'Boolean' probes return 0.0 for false, and a value different from 0.0 for true.

	   def_API('Z3_probe_apply', DOUBLE, (_in(CONTEXT), _in(PROBE), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_const: x _: val [
	"
	   \brief Return a probe that always evaluates to val.

	   def_API('Z3_probe_const', PROBE, (_in(CONTEXT), _in(DOUBLE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_dec_ref: c _: p [
	"
	   \brief Decrement the reference counter of the given probe.

	   def_API('Z3_probe_dec_ref', VOID, (_in(CONTEXT), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_eq: x _: p1 _: p2 [
	"
	   \brief Return a probe that evaluates to 'true' when the value returned by \c p1 is equal to the value returned by \c p2.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_eq', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_ge: x _: p1 _: p2 [
	"
	   \brief Return a probe that evaluates to 'true' when the value returned by \c p1 is greater than or equal to the value returned by \c p2.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_ge', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_get_descr: c _: name [
	"
	   \brief Return a string containing a description of the probe with the given name.

	   def_API('Z3_probe_get_descr', STRING, (_in(CONTEXT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _probe_get_descr: c _: name.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> probe_gt: x _: p1 _: p2 [
	"
	   \brief Return a probe that evaluates to 'true' when the value returned by \c p1 is greater than the value returned by \c p2.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_gt', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_inc_ref: c _: p [
	"
	   \brief Increment the reference counter of the given probe.

	   def_API('Z3_probe_inc_ref', VOID, (_in(CONTEXT), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_le: x _: p1 _: p2 [
	"
	   \brief Return a probe that evaluates to 'true' when the value returned by \c p1 is less than or equal to the value returned by \c p2.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_le', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_lt: x _: p1 _: p2 [
	"
	   \brief Return a probe that evaluates to 'true' when the value returned by \c p1 is less than the value returned by \c p2.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_lt', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_not: x _: p [
	"
	   \brief Return a probe that evaluates to 'true' when \c p does not evaluate to true.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_not', PROBE, (_in(CONTEXT), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> probe_or: x _: p1 _: p2 [
	"
	   \brief Return a probe that evaluates to 'true' when \c p1 or \c p2 evaluates to true.

	   \remark For probes, 'true' is any value different from 0.0.

	   def_API('Z3_probe_or', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PROBE not (yet) supported.'


]

{ #category : #API }
Z3 class >> qe_model_project: c _: m _: num_bounds _: bound _: body [
	"
	   \brief Project variables given a model

	   def_API('Z3_qe_model_project', AST, (_in(CONTEXT), _in(MODEL), _in(UINT), _in_array(2, APP), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval boundExt |

	c ensureValidZ3Object.
	m ensureValidZ3Object.
	bound ensureValidZ3ASTArray.
	body ensureValidZ3AST.
	boundExt := self externalArrayFrom: bound.
	retval := lib _qe_model_project: c _: m _: num_bounds _: boundExt _: body.
	boundExt notNil ifTrue:[boundExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> qe_model_project_skolem: c _: m _: num_bounds _: bound _: body _: map [
	"
	   \brief Project variables given a model

	   def_API('Z3_qe_model_project_skolem', AST, (_in(CONTEXT), _in(MODEL), _in(UINT), _in_array(2, APP), _in(AST), _in(AST_MAP)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type AST_MAP not (yet) supported.'


]

{ #category : #API }
Z3 class >> query_constructor: c _: constr _: num_fields _: constructor _: tester _: accessors [
	"
	   \brief Query constructor for declared functions.

	   \param c logical context.
	   \param constr constructor container. The container must have been passed in to a #Z3_mk_datatype call.
	   \param num_fields number of accessor fields in the constructor.
	   \param constructor constructor function declaration, allocated by user.
	   \param tester constructor test function declaration, allocated by user.
	   \param accessors array of accessor function declarations allocated by user. The array must contain num_fields elements.

	   \sa Z3_mk_constructor

	   def_API('Z3_query_constructor', VOID, (_in(CONTEXT), _in(CONSTRUCTOR), _in(UINT), _out(FUNC_DECL), _out(FUNC_DECL), _out_array(2, FUNC_DECL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval constructorExt testerExt accessorsExt |

	c ensureValidZ3Object.
	constr ensureValidZ3Object.
	constructorExt := self externalArrayFrom: constructor.
	testerExt := self externalArrayFrom: tester.
	accessorsExt := self externalArrayFrom: accessors.
	retval := lib _query_constructor: c _: constr _: num_fields _: constructorExt _: testerExt _: accessorsExt.
	1 to: constructor size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: constructorExt pointerAt: i) inContext: c.
		constructor at: i put: v.
	].
	constructorExt notNil ifTrue:[constructorExt free].
	1 to: tester size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: testerExt pointerAt: i) inContext: c.
		tester at: i put: v.
	].
	testerExt notNil ifTrue:[testerExt free].
	1 to: accessors size do: [ :i |
		| v |

		v := Z3FuncDecl fromExternalAddress: (Z3Object externalArray: accessorsExt pointerAt: i) inContext: c.
		accessors at: i put: v.
	].
	accessorsExt notNil ifTrue:[accessorsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> rcf_add: c _: a _: b [
	"
	   \brief Return the value \ccode{a + b}.

	   def_API('Z3_rcf_add', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_del: c _: a [
	"
	   \brief Delete a RCF numeral created using the RCF API.

	   def_API('Z3_rcf_del', VOID, (_in(CONTEXT), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_div: c _: a _: b [
	"
	   \brief Return the value \ccode{a / b}.

	   def_API('Z3_rcf_div', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_eq: c _: a _: b [
	"
	   \brief Return \c true if \ccode{a == b}.

	   def_API('Z3_rcf_eq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_ge: c _: a _: b [
	"
	   \brief Return \c true if \ccode{a >= b}.

	   def_API('Z3_rcf_ge', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_get_numerator_denominator: c _: a _: n _: d [
	"
	   \brief Extract the 'numerator' and 'denominator' of the given RCF numeral.
	   We have that \ccode{a = n/d}, moreover \c n and \c d are not represented using rational functions.

	   def_API('Z3_rcf_get_numerator_denominator', VOID, (_in(CONTEXT), _in(RCF_NUM), _out(RCF_NUM), _out(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_gt: c _: a _: b [
	"
	   \brief Return \c true if \ccode{a > b}.

	   def_API('Z3_rcf_gt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_inv: c _: a [
	"
	   \brief Return the value \ccode{1/a}.

	   def_API('Z3_rcf_inv', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_le: c _: a _: b [
	"
	   \brief Return \c true if \ccode{a <= b}.

	   def_API('Z3_rcf_le', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_lt: c _: a _: b [
	"
	   \brief Return \c true if \ccode{a < b}.

	   def_API('Z3_rcf_lt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_mk_e: c [
	"
	   \brief Return e (Euler's constant)

	   def_API('Z3_rcf_mk_e', RCF_NUM, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_mk_infinitesimal: c [
	"
	   \brief Return a new infinitesimal that is smaller than all elements in the Z3 field.

	   def_API('Z3_rcf_mk_infinitesimal', RCF_NUM, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_mk_pi: c [
	"
	   \brief Return Pi

	   def_API('Z3_rcf_mk_pi', RCF_NUM, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_mk_rational: c _: val [
	"
	   \brief Return a RCF rational using the given string.

	   def_API('Z3_rcf_mk_rational', RCF_NUM, (_in(CONTEXT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_mk_roots: c _: n _: a _: roots [
	"
	   \brief Store in roots the roots of the polynomial \ccode{a[n-1]*x^{n-1} + ... + a[0]}.
	   The output vector \c roots must have size \c n.
	   It returns the number of roots of the polynomial.

	   \pre The input polynomial is not the zero polynomial.

	   def_API('Z3_rcf_mk_roots', UINT, (_in(CONTEXT), _in(UINT), _in_array(1, RCF_NUM), _out_array(1, RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_mk_small_int: c _: val [
	"
	   \brief Return a RCF small integer.

	   def_API('Z3_rcf_mk_small_int', RCF_NUM, (_in(CONTEXT), _in(INT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_mul: c _: a _: b [
	"
	   \brief Return the value \ccode{a * b}.

	   def_API('Z3_rcf_mul', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_neg: c _: a [
	"
	   \brief Return the value \ccode{-a}.

	   def_API('Z3_rcf_neg', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_neq: c _: a _: b [
	"
	   \brief Return \c true if \ccode{a != b}.

	   def_API('Z3_rcf_neq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_num_to_decimal_string: c _: a _: prec [
	"
	   \brief Convert the RCF numeral into a string in decimal notation.

	   def_API('Z3_rcf_num_to_decimal_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_num_to_string: c _: a _: compact _: html [
	"
	   \brief Convert the RCF numeral into a string.

	   def_API('Z3_rcf_num_to_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(BOOL), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_power: c _: a _: k [
	"
	   \brief Return the value \ccode{a^k}.

	   def_API('Z3_rcf_power', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> rcf_sub: c _: a _: b [
	"
	   \brief Return the value \ccode{a - b}.

	   def_API('Z3_rcf_sub', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type RCF_NUM not (yet) supported.'


]

{ #category : #API }
Z3 class >> reset_memory [
	"
	   \brief Reset all allocated resources.

	   Use this facility on out-of memory errors.
	   It allows discharging the previous state and resuming afresh.
	   Any pointers previously returned by the API
	   become invalid.

	   def_API('Z3_reset_memory', VOID, ())
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _reset_memory.
	^ retval


]

{ #category : #API }
Z3 class >> set_ast_print_mode: c _: mode [
	"
	   \brief Select mode for the format used for pretty-printing AST nodes.

	   The default mode for pretty printing AST nodes is to produce
	   SMT-LIB style output where common subexpressions are printed
	   at each occurrence. The mode is called \c Z3_PRINT_SMTLIB_FULL.
	   To print shared common subexpressions only once,
	   use the \c Z3_PRINT_LOW_LEVEL mode.
	   To print in way that conforms to SMT-LIB standards and uses let
	   expressions to share common sub-expressions use \c Z3_PRINT_SMTLIB2_COMPLIANT.

	   \sa Z3_ast_to_string
	   \sa Z3_pattern_to_string
	   \sa Z3_func_decl_to_string

	   def_API('Z3_set_ast_print_mode', VOID, (_in(CONTEXT), _in(PRINT_MODE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PRINT_MODE not (yet) supported.'


]

{ #category : #API }
Z3 class >> set_error: c _: e [
	"
	   \brief Set an error.

	   def_API('Z3_set_error', VOID, (_in(CONTEXT), _in(ERROR_CODE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _set_error: c _: e.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> set_error_handler: c _: h [
	"
	   \brief Register a Z3 error handler.

	   A call to a Z3 function may return a non \c Z3_OK error code, when
	   it is not used correctly.  An error handler can be registered
	   and will be called in this case.  To disable the use of the
	   error handler, simply register with \c h=NULL.

	   \warning Log files, created using #Z3_open_log, may be potentially incomplete/incorrect if error handlers are used.

	   \sa Z3_get_error_code    

	   WARNING: This method hand-written since Z3 headers do not contain
	   `def_API` directive for this function. Maybe a bug.
	"
	^ lib _set_error_handler: c _: h.

]

{ #category : #API }
Z3 class >> set_param_value: c _: param_id _: param_value [
	"
		\brief Set a configuration parameter.

		The following parameters can be set for

		\sa Z3_mk_config

		def_API('Z3_set_param_value', VOID, (_in(CONFIG), _in(STRING), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _set_param_value: c _: param_id _: param_value.
	^ retval


]

{ #category : #API }
Z3 class >> simplify: c _: a [
	"
		\brief Interface to simplifier.

		Provides an interface to the AST simplifier used by Z3.
		It returns an AST object which is equal to the argument.
		The returned AST is simplified using algebraic simplification rules,
		such as constant propagation (propagating true/false over logical connectives).

		\sa Z3_simplify_ex

		def_API('Z3_simplify', AST, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _simplify: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> simplify_ex: c _: a _: p [
	"
		\brief Interface to simplifier.

		Provides an interface to the AST simplifier used by Z3.
		This procedure is similar to #Z3_simplify, but the behavior of the simplifier
		can be configured using the given parameter set.

		\sa Z3_simplify
		\sa Z3_simplify_get_help
		\sa Z3_simplify_get_param_descrs

		def_API('Z3_simplify_ex', AST, (_in(CONTEXT), _in(AST), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	p ensureValidZ3Object.
	retval := lib _simplify_ex: c _: a _: p.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> simplify_get_help: c [
	"
	   \brief Return a string describing all available parameters.

		\sa Z3_simplify_ex
		\sa Z3_simplify_get_param_descrs

	   def_API('Z3_simplify_get_help', STRING, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _simplify_get_help: c.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> simplify_get_param_descrs: c [
	"
	   \brief Return the parameter description set for the simplify procedure.

		\sa Z3_simplify_ex
		\sa Z3_simplify_get_help

	   def_API('Z3_simplify_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> solver_assert: c _: s _: a [
	"
	   \brief Assert a constraint into the solver.

	   The functions #Z3_solver_check and #Z3_solver_check_assumptions should be
	   used to check whether the logical context is consistent or not.

	   \sa Z3_solver_assert_and_track
	   \sa Z3_solver_reset

	   def_API('Z3_solver_assert', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _solver_assert: c _: s _: a.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_assert_and_track: c _: s _: a _: p [
	"
	   \brief Assert a constraint \c a into the solver, and track it (in the unsat) core using
	   the Boolean constant \c p.

	   This API is an alternative to #Z3_solver_check_assumptions for extracting unsat cores.
	   Both APIs can be used in the same solver. The unsat core will contain a combination
	   of the Boolean variables provided using Z3_solver_assert_and_track and the Boolean literals
	   provided using #Z3_solver_check_assumptions.

	   \pre \c a must be a Boolean expression
	   \pre \c p must be a Boolean constant (aka variable).

	   \sa Z3_solver_assert
	   \sa Z3_solver_reset

	   def_API('Z3_solver_assert_and_track', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	a ensureValidZ3AST.
	p ensureValidZ3AST.
	retval := lib _solver_assert_and_track: c _: s _: a _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_check: c _: s [
	"
	   \brief Check whether the assertions in a given solver are consistent or not.

	   The function #Z3_solver_get_model retrieves a model if the
	   assertions is satisfiable (i.e., the result is \c
	   Z3_L_TRUE) and model construction is enabled.
	   Note that if the call returns \c Z3_L_UNDEF, Z3 does not
	   ensure that calls to #Z3_solver_get_model succeed and any models
	   produced in this case are not guaranteed to satisfy the assertions.

	   The function #Z3_solver_get_proof retrieves a proof if proof
	   generation was enabled when the context was created, and the
	   assertions are unsatisfiable (i.e., the result is \c Z3_L_FALSE).

	   \sa Z3_solver_check_assumptions

	   def_API('Z3_solver_check', INT, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_check: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_check_assumptions: c _: s _: num_assumptions _: assumptions [
	"
	   \brief Check whether the assertions in the given solver and
	   optional assumptions are consistent or not.

	   The function #Z3_solver_get_unsat_core retrieves the subset of the
	   assumptions used in the unsatisfiability proof produced by Z3.

	   \sa Z3_solver_check

	   def_API('Z3_solver_check_assumptions', INT, (_in(CONTEXT), _in(SOLVER), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval assumptionsExt |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	assumptions ensureValidZ3ASTArray.
	assumptionsExt := self externalArrayFrom: assumptions.
	retval := lib _solver_check_assumptions: c _: s _: num_assumptions _: assumptionsExt.
	assumptionsExt notNil ifTrue:[assumptionsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_cube: c _: s _: vars _: backtrack_level [
	"
	   \brief extract a next cube for a solver. The last cube is the constant \c true or \c false.
	   The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled
	   using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction.
	   
	   The third argument is a vector of variables that may be used for cubing.
	   The contents of the vector is only used in the first call. The initial list of variables
	   is used in subsequent calls until it returns the unsatisfiable cube. 
	   The vector is modified to contain a set of Autarky variables that occur in clauses that
	   are affected by the (last literal in the) cube. These variables could be used by a different
	   cuber (on a different solver object) for further recursive cubing. 

	   The last argument is a backtracking level. It instructs the cube process to backtrack below
	   the indicated level for the next cube.
	   
	   def_API('Z3_solver_cube', AST_VECTOR, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	vars ensureValidZ3Object.
	retval := lib _solver_cube: c _: s _: vars _: backtrack_level.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_dec_ref: c _: s [
	"
	   \brief Decrement the reference counter of the given solver.

	   def_API('Z3_solver_dec_ref', VOID, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_dec_ref: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_from_file: c _: s _: file_name [
	"
	   \brief load solver assertions from a file.

	   \sa Z3_solver_from_string
	   \sa Z3_solver_to_string

	   def_API('Z3_solver_from_file', VOID, (_in(CONTEXT), _in(SOLVER), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_from_file: c _: s _: file_name.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_from_string: c _: s _: file_name [
	"
	   \brief load solver assertions from a string.

	   \sa Z3_solver_from_file
	   \sa Z3_solver_to_string

	   def_API('Z3_solver_from_string', VOID, (_in(CONTEXT), _in(SOLVER), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_from_string: c _: s _: file_name.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_get_assertions: c _: s [
	"
	   \brief Return the set of asserted formulas on the solver.

	   def_API('Z3_solver_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_assertions: c _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_get_consequences: c _: s _: assumptions _: variables _: consequences [
	"
	   \brief retrieve consequences from solver that determine values of the supplied function symbols.

	   def_API('Z3_solver_get_consequences', INT, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(AST_VECTOR), _in(AST_VECTOR)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	assumptions ensureValidZ3Object.
	variables ensureValidZ3Object.
	consequences ensureValidZ3Object.
	retval := lib _solver_get_consequences: c _: s _: assumptions _: variables _: consequences.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_get_help: c _: s [
	"
	   \brief Return a string describing all solver available parameters.

	   \sa Z3_solver_get_param_descrs
	   \sa Z3_solver_set_params

	   def_API('Z3_solver_get_help', STRING, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_help: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_get_levels: c _: s _: literals _: sz _: levels [
	"
	   \brief retrieve the decision depth of Boolean literals (variables or their negations).
	   Assumes a check-sat call and no other calls (to extract models) have been invoked.
	   
	   def_API('Z3_solver_get_levels', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(UINT), _in_array(3, UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval levelsExt |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	literals ensureValidZ3Object.
	levelsExt := Z3Object externalU32ArrayFrom: levels.
	retval := lib _solver_get_levels: c _: s _: literals _: sz _: levelsExt.
	levelsExt notNil ifTrue:[levelsExt free].
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_get_model: c _: s [
	"
	   \brief Retrieve the model for the last #Z3_solver_check or #Z3_solver_check_assumptions

	   The error handler is invoked if a model is not available because
	   the commands above were not invoked for the given solver, or if the result was \c Z3_L_FALSE.

	   def_API('Z3_solver_get_model', MODEL, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_model: c _: s.
	c errorCheck.
	^ Z3Model fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_get_non_units: c _: s [
	"
	   \brief Return the set of non units in the solver state.

	   def_API('Z3_solver_get_non_units', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_non_units: c _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_get_num_scopes: c _: s [
	"
	   \brief Return the number of backtracking points.

	   \sa Z3_solver_push
	   \sa Z3_solver_pop

	   def_API('Z3_solver_get_num_scopes', UINT, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_num_scopes: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_get_param_descrs: c _: s [
	"
	   \brief Return the parameter description set for the given solver object.

	   \sa Z3_solver_get_help
	   \sa Z3_solver_set_params

	   def_API('Z3_solver_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> solver_get_proof: c _: s [
	"
	   \brief Retrieve the proof for the last #Z3_solver_check or #Z3_solver_check_assumptions

	   The error handler is invoked if proof generation is not enabled,
	   or if the commands above were not invoked for the given solver,
	   or if the result was different from \c Z3_L_FALSE.

	   def_API('Z3_solver_get_proof', AST, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_proof: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_get_reason_unknown: c _: s [
	"
	   \brief Return a brief justification for an 'unknown' result (i.e., \c Z3_L_UNDEF) for
	   the commands #Z3_solver_check and #Z3_solver_check_assumptions

	   def_API('Z3_solver_get_reason_unknown', STRING, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_reason_unknown: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_get_statistics: c _: s [
	"
	   \brief Return statistics for the given solver.

	   \remark User must use #Z3_stats_inc_ref and #Z3_stats_dec_ref to manage Z3_stats objects.

	   def_API('Z3_solver_get_statistics', STATS, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> solver_get_trail: c _: s [
	"
	   \brief Return the trail modulo model conversion, in order of decision level
	   The decision level can be retrieved using \c Z3_solver_get_level based on the trail.

	   def_API('Z3_solver_get_trail', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_trail: c _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_get_units: c _: s [
	"
	   \brief Return the set of units modulo model conversion.

	   def_API('Z3_solver_get_units', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_units: c _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_get_unsat_core: c _: s [
	"
	   \brief Retrieve the unsat core for the last #Z3_solver_check_assumptions
	   The unsat core is a subset of the assumptions \c a.

	   By default, the unsat core will not be minimized. Generation of a minimized
	   unsat core can be enabled via the `'sat.core.minimize'` and `'smt.core.minimize'`
	   settings for SAT and SMT cores respectively. Generation of minimized unsat cores
	   will be more expensive.

	   def_API('Z3_solver_get_unsat_core', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_get_unsat_core: c _: s.
	c errorCheck.
	^ Z3ASTVector fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_import_model_converter: ctx _: src _: dst [
	"
	   \brief Ad-hoc method for importing model conversion from solver.

	   This method is used for scenarios where \c src has been used to solve a set
	   of formulas and was interrupted. The \c dst solver may be a strengthening of \c src
	   obtained from cubing (assigning a subset of literals or adding constraints over the 
	   assertions available in \c src). If \c dst ends up being satisfiable, the model for \c dst
	   may not correspond to a model of the original formula due to inprocessing in \c src.
	   This method is used to take the side-effect of inprocessing into account when returning
	   a model for \c dst.
	   
	   def_API('Z3_solver_import_model_converter', VOID, (_in(CONTEXT), _in(SOLVER), _in(SOLVER)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	ctx ensureValidZ3Object.
	src ensureValidZ3Object.
	dst ensureValidZ3Object.
	retval := lib _solver_import_model_converter: ctx _: src _: dst.
	ctx errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_inc_ref: c _: s [
	"
	   \brief Increment the reference counter of the given solver.

	   def_API('Z3_solver_inc_ref', VOID, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_inc_ref: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_interrupt: c _: s [
	"
	   \brief Solver local interrupt.
	   Normally you should use Z3_interrupt to cancel solvers because only
	   one solver is enabled concurrently per context.
	   However, per GitHub issue #1006, there are use cases where
	   it is more convenient to cancel a specific solver. Solvers 
	   that are not selected for interrupts are left alone.

	   def_API('Z3_solver_interrupt', VOID, (_in(CONTEXT), _in(SOLVER)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_interrupt: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_pop: c _: s _: n [
	"
	   \brief Backtrack \c n backtracking points.

	   \sa Z3_solver_get_num_scopes
	   \sa Z3_solver_push

	   \pre n <= Z3_solver_get_num_scopes(c, s)

	   def_API('Z3_solver_pop', VOID, (_in(CONTEXT), _in(SOLVER), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_pop: c _: s _: n.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_propagate_consequence: c _: arg1 _: num_fixed _: fixed _: num_eqs _: eq_lhs _: eq_rhs _: conseq [
	"
	   \brief propagate a consequence based on fixed values.
	   This is a callback a client may invoke during the fixed_eh callback. 
	   The callback adds a propagation consequence based on the fixed values of the
	   \c ids. 
	   
	   def_API('Z3_solver_propagate_consequence', VOID, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(UINT), _in_array(2, AST), _in(UINT), _in_array(4, AST), _in_array(4, AST), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type SOLVER_CALLBACK not (yet) supported.'


]

{ #category : #API }
Z3 class >> solver_propagate_declare: c _: name _: n _: domain _: range [
	"
		Create uninterpreted function declaration for the user propagator.
		When expressions using the function are created by the solver invoke a callback
		to \ref \Z3_solver_progate_created with arguments
		1. context and callback solve
		2. declared_expr: expression using function that was used as the top-level symbol
		3. declared_id: a unique identifier (unique within the current scope) to track the expression.
	 
	  def_API('Z3_solver_propagate_declare', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval domainExt |

	c ensureValidZ3Object.
	name ensureValidZ3Object.
	domain ensureValidZ3ASTArrayOfKind: SORT_AST.
	range ensureValidZ3ASTOfKind: SORT_AST.
	domainExt := self externalArrayFrom: domain.
	retval := lib _solver_propagate_declare: c _: name _: n _: domainExt _: range.
	domainExt notNil ifTrue:[domainExt free].
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> solver_propagate_register: c _: s _: e [
	"
	   \brief register an expression to propagate on with the solver.
	   Only expressions of type Bool and type Bit-Vector can be registered for propagation.

	   def_API('Z3_solver_propagate_register', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	e ensureValidZ3AST.
	retval := lib _solver_propagate_register: c _: s _: e.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_propagate_register_cb: c _: cb _: e [
	"
		\brief register an expression to propagate on with the solver.
		Only expressions of type Bool and type Bit-Vector can be registered for propagation.
		Unlike \ref Z3_solver_propagate_register, this function takes a solver callback context
		as argument. It can be invoked during a callback to register new expressions.

		def_API('Z3_solver_propagate_register_cb', VOID, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type SOLVER_CALLBACK not (yet) supported.'


]

{ #category : #API }
Z3 class >> solver_push: c _: s [
	"
	   \brief Create a backtracking point.

	   The solver contains a stack of assertions.

	   \sa Z3_solver_get_num_scopes
	   \sa Z3_solver_pop

	   def_API('Z3_solver_push', VOID, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_push: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_reset: c _: s [
	"
	   \brief Remove all assertions from the solver.

	   \sa Z3_solver_assert
	   \sa Z3_solver_assert_and_track

	   def_API('Z3_solver_reset', VOID, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_reset: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_set_params: c _: s _: p [
	"
	   \brief Set the given solver using the given parameters.

	   \sa Z3_solver_get_help
	   \sa Z3_solver_get_param_descrs

	   def_API('Z3_solver_set_params', VOID, (_in(CONTEXT), _in(SOLVER), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	p ensureValidZ3Object.
	retval := lib _solver_set_params: c _: s _: p.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_to_dimacs_string: c _: s _: include_names [
	"
	   \brief Convert a solver into a DIMACS formatted string.
	   \sa Z3_goal_to_diamcs_string for requirements.

	   def_API('Z3_solver_to_dimacs_string', STRING, (_in(CONTEXT), _in(SOLVER), _in(BOOL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_to_dimacs_string: c _: s _: include_names.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_to_string: c _: s [
	"
	   \brief Convert a solver into a string.

	   \sa Z3_solver_from_file
	   \sa Z3_solver_from_string

	   def_API('Z3_solver_to_string', STRING, (_in(CONTEXT), _in(SOLVER)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3Object.
	retval := lib _solver_to_string: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> solver_translate: source _: s _: target [
	"
	   \brief Copy a solver \c s from the context \c source to the context \c target.

	   def_API('Z3_solver_translate', SOLVER, (_in(CONTEXT), _in(SOLVER), _in(CONTEXT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	source ensureValidZ3Object.
	s ensureValidZ3Object.
	target ensureValidZ3Object.
	retval := lib _solver_translate: source _: s _: target.
	source errorCheck.
	^ Z3Solver fromExternalAddress: retval inContext: source.
	


]

{ #category : #API }
Z3 class >> sort_to_ast: c _: s [
	"
	   \brief Convert a \c Z3_sort into \c Z3_ast. This is just type casting.

	   def_API('Z3_sort_to_ast', AST, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _sort_to_ast: c _: s.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> sort_to_string: c _: s [
	"
	  def_API('Z3_sort_to_string', STRING, (_in(CONTEXT), _in(SORT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	s ensureValidZ3ASTOfKind: SORT_AST.
	retval := lib _sort_to_string: c _: s.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> stats_dec_ref: c _: s [
	"
	   \brief Decrement the reference counter of the given statistics object.

	   def_API('Z3_stats_dec_ref', VOID, (_in(CONTEXT), _in(STATS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_get_double_value: c _: s _: idx [
	"
	   \brief Return the double value of the given statistical data.

	   \pre idx < Z3_stats_size(c, s) && Z3_stats_is_double(c, s)

	   def_API('Z3_stats_get_double_value', DOUBLE, (_in(CONTEXT), _in(STATS), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_get_key: c _: s _: idx [
	"
	   \brief Return the key (a string) for a particular statistical data.

	   \pre idx < Z3_stats_size(c, s)

	   def_API('Z3_stats_get_key', STRING, (_in(CONTEXT), _in(STATS), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_get_uint_value: c _: s _: idx [
	"
	   \brief Return the unsigned value of the given statistical data.

	   \pre idx < Z3_stats_size(c, s) && Z3_stats_is_uint(c, s)

	   def_API('Z3_stats_get_uint_value', UINT, (_in(CONTEXT), _in(STATS), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_inc_ref: c _: s [
	"
	   \brief Increment the reference counter of the given statistics object.

	   def_API('Z3_stats_inc_ref', VOID, (_in(CONTEXT), _in(STATS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_is_double: c _: s _: idx [
	"
	   \brief Return \c true if the given statistical data is a double.

	   \pre idx < Z3_stats_size(c, s)

	   def_API('Z3_stats_is_double', BOOL, (_in(CONTEXT), _in(STATS), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_is_uint: c _: s _: idx [
	"
	   \brief Return \c true if the given statistical data is a unsigned integer.

	   \pre idx < Z3_stats_size(c, s)

	   def_API('Z3_stats_is_uint', BOOL, (_in(CONTEXT), _in(STATS), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_size: c _: s [
	"
	   \brief Return the number of statistical data in \c s.

	   def_API('Z3_stats_size', UINT, (_in(CONTEXT), _in(STATS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> stats_to_string: c _: s [
	"
	   \brief Convert a statistics into a string.

	   def_API('Z3_stats_to_string', STRING, (_in(CONTEXT), _in(STATS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type STATS not (yet) supported.'


]

{ #category : #API }
Z3 class >> substitute: c _: a _: num_exprs _: from _: to [
	"
	   \brief Substitute every occurrence of \ccode{from[i]} in \c a with \ccode{to[i]}, for \c i smaller than \c num_exprs.
	   The result is the new AST. The arrays \c from and \c to must have size \c num_exprs.
	   For every \c i smaller than \c num_exprs, we must have that sort of \ccode{from[i]} must be equal to sort of \ccode{to[i]}.

	   def_API('Z3_substitute', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval fromExt toExt |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	from ensureValidZ3ASTArray.
	to ensureValidZ3ASTArray.
	fromExt := self externalArrayFrom: from.
	toExt := self externalArrayFrom: to.
	retval := lib _substitute: c _: a _: num_exprs _: fromExt _: toExt.
	fromExt notNil ifTrue:[fromExt free].
	toExt notNil ifTrue:[toExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> substitute_vars: c _: a _: num_exprs _: to [
	"
	   \brief Substitute the free variables in \c a with the expressions in \c to.
	   For every \c i smaller than \c num_exprs, the variable with de-Bruijn index \c i is replaced with term \ccode{to[i]}.

	   def_API('Z3_substitute_vars', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval toExt |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	to ensureValidZ3ASTArray.
	toExt := self externalArrayFrom: to.
	retval := lib _substitute_vars: c _: a _: num_exprs _: toExt.
	toExt notNil ifTrue:[toExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> tactic_and_then: c _: t1 _: t2 [
	"
	   \brief Return a tactic that applies \c t1 to a given goal and \c t2
	   to every subgoal produced by \c t1.

	   def_API('Z3_tactic_and_then', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_apply: c _: t _: g [
	"
	   \brief Apply tactic \c t to the goal \c g.

	   def_API('Z3_tactic_apply', APPLY_RESULT, (_in(CONTEXT), _in(TACTIC), _in(GOAL)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type APPLY_RESULT not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_apply_ex: c _: t _: g _: p [
	"
	   \brief Apply tactic \c t to the goal \c g using the parameter set \c p.

	   def_API('Z3_tactic_apply_ex', APPLY_RESULT, (_in(CONTEXT), _in(TACTIC), _in(GOAL), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type APPLY_RESULT not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_cond: c _: p _: t1 _: t2 [
	"
	   \brief Return a tactic that applies \c t1 to a given goal if the probe \c p evaluates to true,
	   and \c t2 if \c p evaluates to false.

	   def_API('Z3_tactic_cond', TACTIC, (_in(CONTEXT), _in(PROBE), _in(TACTIC), _in(TACTIC)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_dec_ref: c _: g [
	"
	   \brief Decrement the reference counter of the given tactic.

	   def_API('Z3_tactic_dec_ref', VOID, (_in(CONTEXT), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_fail: c [
	"
	   \brief Return a tactic that always fails.

	   def_API('Z3_tactic_fail', TACTIC, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_fail_if: c _: p [
	"
	   \brief Return a tactic that fails if the probe \c p evaluates to false.

	   def_API('Z3_tactic_fail_if', TACTIC, (_in(CONTEXT), _in(PROBE)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_fail_if_not_decided: c [
	"
	   \brief Return a tactic that fails if the goal is not trivially satisfiable (i.e., empty) or
	   trivially unsatisfiable (i.e., contains false).

	   def_API('Z3_tactic_fail_if_not_decided', TACTIC, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_get_descr: c _: name [
	"
	   \brief Return a string containing a description of the tactic with the given name.

	   def_API('Z3_tactic_get_descr', STRING, (_in(CONTEXT), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _tactic_get_descr: c _: name.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> tactic_get_help: c _: t [
	"
	   \brief Return a string containing a description of parameters accepted by the given tactic.

	   def_API('Z3_tactic_get_help', STRING, (_in(CONTEXT), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_get_param_descrs: c _: t [
	"
	   \brief Return the parameter description set for the given tactic object.

	   def_API('Z3_tactic_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type PARAM_DESCRS not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_inc_ref: c _: t [
	"
	   \brief Increment the reference counter of the given tactic.

	   def_API('Z3_tactic_inc_ref', VOID, (_in(CONTEXT), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_or_else: c _: t1 _: t2 [
	"
	   \brief Return a tactic that first applies \c t1 to a given goal,
	   if it fails then returns the result of \c t2 applied to the given goal.

	   def_API('Z3_tactic_or_else', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_par_and_then: c _: t1 _: t2 [
	"
	   \brief Return a tactic that applies \c t1 to a given goal and then \c t2
	   to every subgoal produced by \c t1. The subgoals are processed in parallel.

	   def_API('Z3_tactic_par_and_then', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_par_or: c _: num _: ts [
	"
	   \brief Return a tactic that applies the given tactics in parallel.

	   def_API('Z3_tactic_par_or', TACTIC, (_in(CONTEXT), _in(UINT), _in_array(1, TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_repeat: c _: t _: max [
	"
	   \brief Return a tactic that keeps applying \c t until the goal is not modified anymore or the maximum
	   number of iterations \c max is reached.

	   def_API('Z3_tactic_repeat', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(UINT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_skip: c [
	"
	   \brief Return a tactic that just return the given goal.

	   def_API('Z3_tactic_skip', TACTIC, (_in(CONTEXT),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_try_for: c _: t _: ms [
	"
	   \brief Return a tactic that applies \c t to a given goal for \c ms milliseconds.
	   If \c t does not terminate in \c ms milliseconds, then it fails.

	   def_API('Z3_tactic_try_for', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(UINT)))
	 

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_using_params: c _: t _: p [
	"
	   \brief Return a tactic that applies \c t using the given set of parameters.

	   def_API('Z3_tactic_using_params', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(PARAMS)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> tactic_when: c _: p _: t [
	"
	   \brief Return a tactic that applies \c t to a given goal is the probe \c p evaluates to true.
	   If \c p evaluates to false, then the new tactic behaves like the skip tactic.

	   def_API('Z3_tactic_when', TACTIC, (_in(CONTEXT), _in(PROBE), _in(TACTIC)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	^ self error: 'API not (yet) supported: Type TACTIC not (yet) supported.'


]

{ #category : #API }
Z3 class >> to_app: c _: a [
	"
	   \brief Convert an \c ast into an \c APP_AST. This is just type casting.

	   \pre \code Z3_get_ast_kind(c, a) == \c Z3_APP_AST \endcode

	   def_API('Z3_to_app', APP, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _to_app: c _: a.
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> to_func_decl: c _: a [
	"
	   \brief Convert an AST into a FUNC_DECL_AST. This is just type casting.

	   \pre \code Z3_get_ast_kind(c, a) == Z3_FUNC_DECL_AST \endcode

	   def_API('Z3_to_func_decl', FUNC_DECL, (_in(CONTEXT), _in(AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	retval := lib _to_func_decl: c _: a.
	c errorCheck.
	^ Z3FuncDecl fromExternalAddress: retval inContext: c.
	


]

{ #category : #API }
Z3 class >> toggle_warning_messages: enabled [
	"
	   \brief Enable/disable printing warning messages to the console.

	   Warnings are printed after passing \c true, warning messages are
	   suppressed after calling this method with \c false.

	   def_API('Z3_toggle_warning_messages', VOID, (_in(BOOL),))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	retval := lib _toggle_warning_messages: enabled.
	^ retval


]

{ #category : #API }
Z3 class >> translate: source _: a _: target [
	"
	   \brief Translate/Copy the AST \c a from context \c source to context \c target.
	   AST \c a must have been created using context \c source.
	   \pre source != target

	   def_API('Z3_translate', AST, (_in(CONTEXT), _in(AST), _in(CONTEXT)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	source ensureValidZ3Object.
	a ensureValidZ3AST.
	target ensureValidZ3Object.
	retval := lib _translate: source _: a _: target.
	source errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: source.
	


]

{ #category : #API }
Z3 class >> update_param_value: c _: param_id _: param_value [
	"
	   \brief Set a value of a context parameter.

	   \sa Z3_global_param_set

	   def_API('Z3_update_param_value', VOID, (_in(CONTEXT), _in(STRING), _in(STRING)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval |

	c ensureValidZ3Object.
	retval := lib _update_param_value: c _: param_id _: param_value.
	c errorCheck.
	^ retval


]

{ #category : #API }
Z3 class >> update_term: c _: a _: num_args _: args [
	"
	   \brief Update the arguments of term \c a using the arguments \c args.
	   The number of arguments \c num_args should coincide
	   with the number of arguments to \c a.
	   If \c a is a quantifier, then num_args has to be 1.

	   def_API('Z3_update_term', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
	

		AUTOMATICALLY GENERATED BY apigen.py. DO NOT EDIT!
	"
	| retval argsExt |

	c ensureValidZ3Object.
	a ensureValidZ3AST.
	args ensureValidZ3ASTArray.
	argsExt := self externalArrayFrom: args.
	retval := lib _update_term: c _: a _: num_args _: argsExt.
	argsExt notNil ifTrue:[argsExt free].
	c errorCheck.
	^ Z3AST fromExternalAddress: retval inContext: c.
	


]
