Extension { #name : #Object }

{ #category : #'*Refinements' }
Object >> dCut [
	^Elims
		cuts: (Set with: self)
		nonCuts: Set new
]

{ #category : #'*Refinements' }
Object >> dNonCut [
	^Elims
		cuts: Set new
		nonCuts: (Set with: self)
]

{ #category : #'*Refinements' }
Object >> isJunkFxEVar [
	^false
]

{ #category : #'*Refinements' }
Object >> mapKVars: aBlock [
	^self mapKVars1: [ :kv1__ |
		| kv1 |
		kv1 := kv1__ first.
		aBlock value: kv1 ]
]

{ #category : #'*Refinements' }
Object >> predReft [
	"View the receiver as a Predicate, and construct a dummy-named Reft.
	 In practice this is used on Expr, but works on any Predicate receiver
	 i.e. any receiver who responds to #prop, cf Refinements.hs:
	
	predReft      :: (Predicate a) => a -> Reft
	"
	^Reft symbol: String vv_ expr: self prop
]

{ #category : #'*Refinements' }
Object >> printStringInHotel: h [
	^self printString
]

{ #category : #'*Refinements' }
Object >> propReft [
"
propReft      ::  (Predicate a) => a -> Reft
cf. Refinements.hs
"
	^Reft symbol: String vv_ expr: self shouldBeImplemented
]

{ #category : #'*Refinements' }
Object >> subst: θ [
	self error: 'Dont know how to substitute in ', self class name
]

{ #category : #'*Refinements' }
Object >> subst: θ exceptAll: xes [
"
substExcept  :: Subst -> [Symbol] -> Subst
-- substExcept  (Su m) xs = Su (foldr M.delete m xs)
substExcept (Su xes) xs = Su $ M.filterWithKey (const . not . (`elem` xs)) xes
"
	^self subst: (θ exceptAll: xes)
]

{ #category : #'*Refinements' }
Object >> ≛ [ y
	"Assuming both the receiver and the argument respond to #expr
	 (equivalently in LH parlance, 'have F.Expression typeclass'),
	 construct the Horn Reft stating the receiver is equal to the
	 argument. "
	| atom |
	atom := PAtomEq x: self expr y: y expr.
	^HReft expr: atom
"
peq :: (F.Expression a, F.Expression b) => a -> b -> H.Pred
Cf. Check.hs.
In LH this is part of SpriteLang; however, this author believes
#≛ belongs quite logically in Fixpoint.
"
]
